<html><head><style>.diff{overflow:auto;}
.diff ul{background:#fff;overflow:auto;font-size:13px;list-style:none;margin:0;padding:0;display:table;width:100%;}
.diff del, .diff ins{display:block;text-decoration:none;}
.diff li{padding:0; display:table-row;margin: 0;height:1em;}
.diff li.ins{background:#dfd; color:#080}
.diff li.del{background:#fee; color:#b00}
.diff li:hover{background:#ffc}
/* try 'whitespace:pre;' if you don't want lines to wrap */
.diff del, .diff ins, .diff span{white-space:pre-wrap;font-family:courier;}
.diff del strong{font-weight:normal;background:#fcc;}
.diff ins strong{font-weight:normal;background:#9f9;}
.diff li.diff-comment { display: none; }
.diff li.diff-block-info { background: none repeat scroll 0 0 gray; }
</style></head><body><div class="diff">
  <ul>
    <li class="unchanged"><span>    self.ERC20.constructor(name: &quot;FacetSwap V1 ERC20&quot;, symbol: &quot;FACET-V1&quot;, decimals: 18)</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>}</span></li>
    <li class="del"><del>contract(:IFacetSwapV1Factory, abstract: true) {</del></li>
    <li class="ins"><ins>contract(:IFacetSwapV1Factory<strong>02</strong>, abstract: true) {</ins></li>
    <li class="unchanged"><span>  function(:feeTo, :external, :view, returns: :address)</span></li>
    <li class="ins"><ins>  function(:lpFeeBPS, :external, :view, returns: :uint256)</ins></li>
    <li class="unchanged"><span>}</span></li>
    <li class="unchanged"><span>contract(:Upgradeable, abstract: true) {</span></li>
    <li class="unchanged"><span>  address(:public, :upgradeAdmin)</span></li>
    <li class="unchanged"><span>    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>}</span></li>
    <li class="del"><del>contract(:FacetSwapV1Pair, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {</del></li>
    <li class="ins"><ins>contract(:FacetSwapV1Pair<strong>02</strong>, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {</ins></li>
    <li class="unchanged"><span>  uint256(:public, :MINIMUM_LIQUIDITY)</span></li>
    <li class="unchanged"><span>  address(:public, :factory)</span></li>
    <li class="unchanged"><span>  address(:public, :token0)</span></li>
    <li class="unchanged"><span>    return x / uint224(y)</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {</span></li>
    <li class="del"><del>    feeTo = IFacetSwapV1Factory(s.factory).feeTo</del></li>
    <li class="ins"><ins>    feeTo = IFacetSwapV1Factory<strong>02</strong>(s.factory).feeTo</ins></li>
    <li class="unchanged"><span>    feeOn = feeTo != address(0)</span></li>
    <li class="unchanged"><span>    _kLast = s.kLast</span></li>
    <li class="unchanged"><span>    if feeOn</span></li>
    <li class="unchanged"><span>      0</span></li>
    <li class="unchanged"><span>    end</span></li>
    <li class="unchanged"><span>    require(amount0In &gt; 0 || amount1In &gt; 0, &quot;FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT&quot;)</span></li>
    <li class="del"><del>    balance0Adjusted = balance0 * 1000 - amount0In<strong>.*(3</strong>)</del></li>
    <li class="del"><del>    balance1Adjusted = balance1 * 1000 - amount1In<strong>.*(3</strong>)</del></li>
    <li class="ins"><ins>    <strong>lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS</strong></ins></li>
    <li class="ins"><ins><strong>    </strong>balance0Adjusted = balance0 * 1000 - <strong>(</strong>amount0In<strong> * lpFeeBPS).div(10</strong>)</ins></li>
    <li class="ins"><ins>    balance1Adjusted = balance1 * 1000 - <strong>(</strong>amount1In<strong> * lpFeeBPS).div(10</strong>)</ins></li>
    <li class="unchanged"><span>    require(balance0Adjusted * balance1Adjusted &gt;= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), &quot;FacetSwapV1: K&quot;)</span></li>
    <li class="unchanged"><span>    _update(balance0, balance1, _reserve0, _reserve1)</span></li>
    <li class="unchanged"><span>    s.unlocked=1</span></li>
    <li class="unchanged"><span>    nil</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>}</span></li>
    <li class="del"><del>contract(:FacetSwapV1Factory, is: :Upgradeable, upgradeable: true) {</del></li>
    <li class="ins"><ins>contract(:FacetSwapV1Factory<strong>02</strong>, is: :Upgradeable, upgradeable: true) {</ins></li>
    <li class="unchanged"><span>  address(:public, :feeTo)</span></li>
    <li class="unchanged"><span>  address(:public, :feeToSetter)</span></li>
    <li class="ins"><ins>  uint256(:public, :lpFeeBPS)</ins></li>
    <li class="unchanged"><span>  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)</span></li>
    <li class="unchanged"><span>  array(:address, :public, :allPairs)</span></li>
    <li class="unchanged"><span>  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })</span></li>
    <li class="unchanged"><span>    s.feeToSetter=_feeToSetter</span></li>
    <li class="unchanged"><span>    self.Upgradeable.constructor(upgradeAdmin: msg.sender)</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="ins"><ins>  function(:setLpFeeBPS, { lpFeeBPS: :uint256 }, :public) {</ins></li>
    <li class="ins"><ins>    require(msg.sender == feeToSetter, &quot;FacetSwapV1: FORBIDDEN&quot;)</ins></li>
    <li class="ins"><ins>    require(lpFeeBPS &lt;= 10000, &quot;Fees cannot exceed 100%&quot;)</ins></li>
    <li class="ins"><ins>    s.lpFeeBPS=lpFeeBPS</ins></li>
    <li class="ins"><ins>    return nil</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="unchanged"><span>  function(:allPairsLength, :public, :view, returns: :uint256) {</span></li>
    <li class="unchanged"><span>    return s.allPairs.length</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="del"><del>  function(:getAllPairs, :public, :view, returns: [:address]) {</del></li>
    <li class="del"><del>    return s.allPairs</del></li>
    <li class="del"><del>  }</del></li>
    <li class="unchanged"><span>  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {</span></li>
    <li class="unchanged"><span>    require(tokenA != tokenB, &quot;FacetSwapV1: IDENTICAL_ADDRESSES&quot;)</span></li>
    <li class="unchanged"><span>    (token0, token1) = if tokenA.cast(:uint256) &lt; tokenB.cast(:uint256)</span></li>
    <li class="unchanged"><span>    require(token0 != address(0), &quot;FacetSwapV1: ZERO_ADDRESS&quot;)</span></li>
    <li class="unchanged"><span>    require(s.getPair[token0][token1] == address(0), &quot;FacetSwapV1: PAIR_EXISTS&quot;)</span></li>
    <li class="unchanged"><span>    salt = keccak256(abi.encodePacked(token0, token1))</span></li>
    <li class="del"><del>    pair = new(FacetSwapV1Pair({ salt: salt }))</del></li>
    <li class="ins"><ins>    pair = new(FacetSwapV1Pair<strong>02</strong>({ salt: salt }))</ins></li>
    <li class="unchanged"><span>    pair.init(token0, token1)</span></li>
    <li class="unchanged"><span>    s.getPair[token0][token1] = pair</span></li>
    <li class="unchanged"><span>    s.getPair[token1][token0] = pair</span></li>
    <li class="unchanged"><span>    s.feeToSetter=_feeToSetter</span></li>
    <li class="unchanged"><span>    return nil</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="ins"><ins>  function(:upgradePairs, { pairs: [:address], newHash: :bytes32, newSource: :string }, :public) {</ins></li>
    <li class="ins"><ins>    require(msg.sender == s.upgradeAdmin, &quot;NOT_AUTHORIZED&quot;)</ins></li>
    <li class="ins"><ins>    require(pairs.length &lt;= 10, &quot;Too many pairs to upgrade at once&quot;)</ins></li>
    <li class="ins"><ins>    forLoop(condition: -&gt;(i) {</ins></li>
    <li class="ins"><ins>      i &lt; pairs.length</ins></li>
    <li class="ins"><ins>    }) { |i|</ins></li>
    <li class="ins"><ins>      pair = pairs[i]</ins></li>
    <li class="ins"><ins>      sourceToUse = if i == 0</ins></li>
    <li class="ins"><ins>        newSource</ins></li>
    <li class="ins"><ins>      else</ins></li>
    <li class="ins"><ins>        &quot;&quot;</ins></li>
    <li class="ins"><ins>      end</ins></li>
    <li class="ins"><ins>      upgradePair(pair: pair, newHash: newHash, newSource: sourceToUse)</ins></li>
    <li class="ins"><ins>    }</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:upgradePair, { pair: :address, newHash: :bytes32, newSource: :string }, :public) {</ins></li>
    <li class="ins"><ins>    require(msg.sender == s.upgradeAdmin, &quot;NOT_AUTHORIZED&quot;)</ins></li>
    <li class="ins"><ins>    Upgradeable(pair).upgrade(newHash: newHash, newSource: newSource)</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="unchanged"><span>}</span></li>
  </ul>
</div>
</body></html>