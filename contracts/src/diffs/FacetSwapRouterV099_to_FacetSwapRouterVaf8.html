<html><head><style>.diff{overflow:auto;}
.diff ul{background:#fff;overflow:auto;font-size:13px;list-style:none;margin:0;padding:0;display:table;width:100%;}
.diff del, .diff ins{display:block;text-decoration:none;}
.diff li{padding:0; display:table-row;margin: 0;height:1em;}
.diff li.ins{background:#dfd; color:#080}
.diff li.del{background:#fee; color:#b00}
.diff li:hover{background:#ffc}
/* try 'whitespace:pre;' if you don't want lines to wrap */
.diff del, .diff ins, .diff span{white-space:pre-wrap;font-family:courier;}
.diff del strong{font-weight:normal;background:#fcc;}
.diff ins strong{font-weight:normal;background:#9f9;}
.diff li.diff-comment { display: none; }
.diff li.diff-block-info { background: none repeat scroll 0 0 gray; }
</style></head><body><div class="diff">
  <ul>
    <li class="unchanged"><span>    self.ERC20.constructor(name: &quot;FacetSwap V1 ERC20&quot;, symbol: &quot;FACET-V1&quot;, decimals: 18)</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>}</span></li>
    <li class="del"><del>contract(:IFacetSwapV1Factory, abstract: true) {</del></li>
    <li class="ins"><ins>contract(:IFacetSwapV1Factory<strong>02</strong>, abstract: true) {</ins></li>
    <li class="unchanged"><span>  function(:feeTo, :external, :view, returns: :address)</span></li>
    <li class="ins"><ins>  function(:lpFeeBPS, :external, :view, returns: :uint256)</ins></li>
    <li class="unchanged"><span>}</span></li>
    <li class="unchanged"><span>contract(:Upgradeable, abstract: true) {</span></li>
    <li class="unchanged"><span>  address(:public, :upgradeAdmin)</span></li>
    <li class="unchanged"><span>    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>}</span></li>
    <li class="del"><del>contract(:FacetSwapV1Pair, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {</del></li>
    <li class="ins"><ins>contract(:FacetSwapV1Pair<strong>02</strong>, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {</ins></li>
    <li class="unchanged"><span>  uint256(:public, :MINIMUM_LIQUIDITY)</span></li>
    <li class="unchanged"><span>  address(:public, :factory)</span></li>
    <li class="unchanged"><span>  address(:public, :token0)</span></li>
    <li class="unchanged"><span>    return x / uint224(y)</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {</span></li>
    <li class="del"><del>    feeTo = IFacetSwapV1Factory(s.factory).feeTo</del></li>
    <li class="ins"><ins>    feeTo = IFacetSwapV1Factory<strong>02</strong>(s.factory).feeTo</ins></li>
    <li class="unchanged"><span>    feeOn = feeTo != address(0)</span></li>
    <li class="unchanged"><span>    _kLast = s.kLast</span></li>
    <li class="unchanged"><span>    if feeOn</span></li>
    <li class="unchanged"><span>      0</span></li>
    <li class="unchanged"><span>    end</span></li>
    <li class="unchanged"><span>    require(amount0In &gt; 0 || amount1In &gt; 0, &quot;FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT&quot;)</span></li>
    <li class="del"><del>    balance0Adjusted = balance0 * 1000 - amount0In<strong>.*(3</strong>)</del></li>
    <li class="del"><del>    balance1Adjusted = balance1 * 1000 - amount1In<strong>.*(3</strong>)</del></li>
    <li class="ins"><ins>    <strong>lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS</strong></ins></li>
    <li class="ins"><ins><strong>    </strong>balance0Adjusted = balance0 * 1000 - <strong>(</strong>amount0In<strong> * lpFeeBPS).div(10</strong>)</ins></li>
    <li class="ins"><ins>    balance1Adjusted = balance1 * 1000 - <strong>(</strong>amount1In<strong> * lpFeeBPS).div(10</strong>)</ins></li>
    <li class="unchanged"><span>    require(balance0Adjusted * balance1Adjusted &gt;= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), &quot;FacetSwapV1: K&quot;)</span></li>
    <li class="unchanged"><span>    _update(balance0, balance1, _reserve0, _reserve1)</span></li>
    <li class="unchanged"><span>    s.unlocked=1</span></li>
    <li class="unchanged"><span>    nil</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>}</span></li>
    <li class="del"><del>contract(:FacetSwapV1Factory, is: :Upgradeable, upgradeable: true) {</del></li>
    <li class="ins"><ins>contract(:FacetSwapV1Factory<strong>02</strong>, is: :Upgradeable, upgradeable: true) {</ins></li>
    <li class="unchanged"><span>  address(:public, :feeTo)</span></li>
    <li class="unchanged"><span>  address(:public, :feeToSetter)</span></li>
    <li class="ins"><ins>  uint256(:public, :lpFeeBPS)</ins></li>
    <li class="unchanged"><span>  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)</span></li>
    <li class="unchanged"><span>  array(:address, :public, :allPairs)</span></li>
    <li class="unchanged"><span>  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })</span></li>
    <li class="unchanged"><span>    s.feeToSetter=_feeToSetter</span></li>
    <li class="unchanged"><span>    self.Upgradeable.constructor(upgradeAdmin: msg.sender)</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="ins"><ins>  function(:setLpFeeBPS, { lpFeeBPS: :uint256 }, :public) {</ins></li>
    <li class="ins"><ins>    require(msg.sender == feeToSetter, &quot;FacetSwapV1: FORBIDDEN&quot;)</ins></li>
    <li class="ins"><ins>    require(lpFeeBPS &lt;= 10000, &quot;Fees cannot exceed 100%&quot;)</ins></li>
    <li class="ins"><ins>    s.lpFeeBPS=lpFeeBPS</ins></li>
    <li class="ins"><ins>    return nil</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="unchanged"><span>  function(:allPairsLength, :public, :view, returns: :uint256) {</span></li>
    <li class="unchanged"><span>    return s.allPairs.length</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="del"><del>  function(:getAllPairs, :public, :view, returns: [:address]) {</del></li>
    <li class="del"><del>    return s.allPairs</del></li>
    <li class="del"><del>  }</del></li>
    <li class="unchanged"><span>  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {</span></li>
    <li class="unchanged"><span>    require(tokenA != tokenB, &quot;FacetSwapV1: IDENTICAL_ADDRESSES&quot;)</span></li>
    <li class="unchanged"><span>    (token0, token1) = if tokenA.cast(:uint256) &lt; tokenB.cast(:uint256)</span></li>
    <li class="unchanged"><span>    require(token0 != address(0), &quot;FacetSwapV1: ZERO_ADDRESS&quot;)</span></li>
    <li class="unchanged"><span>    require(s.getPair[token0][token1] == address(0), &quot;FacetSwapV1: PAIR_EXISTS&quot;)</span></li>
    <li class="unchanged"><span>    salt = keccak256(abi.encodePacked(token0, token1))</span></li>
    <li class="del"><del>    pair = new(FacetSwapV1Pair({ salt: salt }))</del></li>
    <li class="ins"><ins>    pair = new(FacetSwapV1Pair<strong>02</strong>({ salt: salt }))</ins></li>
    <li class="unchanged"><span>    pair.init(token0, token1)</span></li>
    <li class="unchanged"><span>    s.getPair[token0][token1] = pair</span></li>
    <li class="unchanged"><span>    s.getPair[token1][token0] = pair</span></li>
    <li class="unchanged"><span>    s.feeToSetter=_feeToSetter</span></li>
    <li class="unchanged"><span>    return nil</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="ins"><ins>  function(:upgradePairs, { pairs: [:address], newHash: :bytes32, newSource: :string }, :public) {</ins></li>
    <li class="ins"><ins>    require(msg.sender == s.upgradeAdmin, &quot;NOT_AUTHORIZED&quot;)</ins></li>
    <li class="ins"><ins>    require(pairs.length &lt;= 10, &quot;Too many pairs to upgrade at once&quot;)</ins></li>
    <li class="ins"><ins>    forLoop(condition: -&gt;(i) {</ins></li>
    <li class="ins"><ins>      i &lt; pairs.length</ins></li>
    <li class="ins"><ins>    }) { |i|</ins></li>
    <li class="ins"><ins>      pair = pairs[i]</ins></li>
    <li class="ins"><ins>      sourceToUse = if i == 0</ins></li>
    <li class="ins"><ins>        newSource</ins></li>
    <li class="ins"><ins>      else</ins></li>
    <li class="ins"><ins>        &quot;&quot;</ins></li>
    <li class="ins"><ins>      end</ins></li>
    <li class="ins"><ins>      upgradePair(pair: pair, newHash: newHash, newSource: sourceToUse)</ins></li>
    <li class="ins"><ins>    }</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:upgradePair, { pair: :address, newHash: :bytes32, newSource: :string }, :public) {</ins></li>
    <li class="ins"><ins>    require(msg.sender == s.upgradeAdmin, &quot;NOT_AUTHORIZED&quot;)</ins></li>
    <li class="ins"><ins>    Upgradeable(pair).upgrade(newHash: newHash, newSource: newSource)</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="unchanged"><span>}</span></li>
    <li class="del"><del>c<strong>ontract(:</strong>FacetSwapV1Router, is: <strong>:</strong>Upgradeable, <strong>u</strong>pgradeable: true) {</del></li>
    <li class="ins"><ins><strong>contract(:Ownable, abstract: true) {</strong></ins></li>
    <li class="ins"><ins><strong>  address(:public, :owner)</strong></ins></li>
    <li class="ins"><ins><strong>  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })</strong></ins></li>
    <li class="ins"><ins><strong>  constructor(owner: :address) {</strong></ins></li>
    <li class="ins"><ins><strong>    s.owner=owner</strong></ins></li>
    <li class="ins"><ins><strong>  }</strong></ins></li>
    <li class="ins"><ins><strong>  function(:transferOwnership, { newOwner: :address }, :public) {</strong></ins></li>
    <li class="ins"><ins><strong>    onlyOwner!</strong></ins></li>
    <li class="ins"><ins><strong>    previousOwner = s.owner</strong></ins></li>
    <li class="ins"><ins><strong>    s.owner=newOwner</strong></ins></li>
    <li class="ins"><ins><strong>    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)</strong></ins></li>
    <li class="ins"><ins><strong>  }</strong></ins></li>
    <li class="ins"><ins><strong>  function(:onlyOwner!, :internal) {</strong></ins></li>
    <li class="ins"><ins><strong>    require(msg.sender == s.owner, &quot;msg.sender is not the owner&quot;)</strong></ins></li>
    <li class="ins"><ins><strong>  }</strong></ins></li>
    <li class="ins"><ins><strong>}</strong></ins></li>
    <li class="ins"><ins><strong>contract(:Pausable, abstract: true) {</strong></ins></li>
    <li class="ins"><ins><strong>  bool(:public, :paused)</strong></ins></li>
    <li class="ins"><ins><strong>  event(:Paused, { account: :address })</strong></ins></li>
    <li class="ins"><ins><strong>  event(:Unpaused, { account: :address })</strong></ins></li>
    <li class="ins"><ins><strong>  constructor(initialPauseState: :bool) {</strong></ins></li>
    <li class="ins"><ins><strong>    s.paused=initialPauseState</strong></ins></li>
    <li class="ins"><ins><strong>  }</strong></ins></li>
    <li class="ins"><ins><strong>  function(:_pause, :internal) {</strong></ins></li>
    <li class="ins"><ins><strong>    s.paused=true</strong></ins></li>
    <li class="ins"><ins><strong>    emit(:Paused, account: msg.sender)</strong></ins></li>
    <li class="ins"><ins><strong>  }</strong></ins></li>
    <li class="ins"><ins><strong>  function(:_unpause, :internal) {</strong></ins></li>
    <li class="ins"><ins><strong>    s.paused=false</strong></ins></li>
    <li class="ins"><ins><strong>    emit(:Unpaused, a</strong>c<strong>count: msg.sender)</strong></ins></li>
    <li class="ins"><ins><strong>  }</strong></ins></li>
    <li class="ins"><ins><strong>  function(:whenPaused!, :internal) {</strong></ins></li>
    <li class="ins"><ins><strong>    require(s.paused, &quot;Contract is not paused&quot;)</strong></ins></li>
    <li class="ins"><ins><strong>  }</strong></ins></li>
    <li class="ins"><ins><strong>  function(:whenNotPaused!, :internal) {</strong></ins></li>
    <li class="ins"><ins><strong>    require(!s.paused, &quot;Contract is paused&quot;)</strong></ins></li>
    <li class="ins"><ins><strong>  }</strong></ins></li>
    <li class="ins"><ins><strong>}</strong></ins></li>
    <li class="ins"><ins><strong>contract(:</strong>FacetSwapV1Router<strong>02</strong>, is: <strong>[:Ownable, :</strong>Upgradeable, <strong>:Pausable], u</strong>pgradeable: true) {</ins></li>
    <li class="unchanged"><span>  address(:public, :factory)</span></li>
    <li class="unchanged"><span>  address(:public, :WETH)</span></li>
    <li class="unchanged"><span>  uint8(:public, :maxPathLength)</span></li>
    <li class="del"><del>  <strong>construct</strong>or(_factory: :address, _WETH: :address) {</del></li>
    <li class="ins"><ins>  <strong>uint256(:public, :protocolFeeBPS)</strong></ins></li>
    <li class="ins"><ins><strong>  event(:FeeAdjustedSwap, { inputToken: :address, outputToken: :address, inputAmount: :uint256, outputAmount: :uint256, feeAmount: :uint256, to: :address })</strong></ins></li>
    <li class="ins"><ins><strong>  construct</strong>or(_factory: :address, _WETH: :address<strong>, protocolFeeBPS: :uint256, initialPauseState: :bool</strong>) {</ins></li>
    <li class="unchanged"><span>    s.factory=_factory</span></li>
    <li class="unchanged"><span>    s.WETH=_WETH</span></li>
    <li class="unchanged"><span>    self.Upgradeable.constructor(upgradeAdmin: msg.sender)</span></li>
    <li class="ins"><ins>    self.Ownable.constructor(owner: msg.sender)</ins></li>
    <li class="ins"><ins>    updateProtocolFee(protocolFeeBPS: protocolFeeBPS)</ins></li>
    <li class="ins"><ins>    self.Pausable.constructor(initialPauseState: initialPauseState)</ins></li>
    <li class="unchanged"><span>    s.maxPathLength=3</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="ins"><ins>  function(:onUpgrade, { owner: :address, initialPauseState: :bool }, :public) {</ins></li>
    <li class="ins"><ins>    require(msg.sender == address(this), &quot;Only the contract itself can upgrade&quot;)</ins></li>
    <li class="ins"><ins>    s.owner=owner</ins></li>
    <li class="ins"><ins>    if initialPauseState</ins></li>
    <li class="ins"><ins>      _pause</ins></li>
    <li class="ins"><ins>    else</ins></li>
    <li class="ins"><ins>      _unpause</ins></li>
    <li class="ins"><ins>    end</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="unchanged"><span>  function(:_addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256 }, :internal, :virtual, returns: { amountA: :uint256, amountB: :uint256 }) {</span></li>
    <li class="del"><del>    if FacetSwapV1Factory(factory).getPair(tokenA, tokenB) == address(0)</del></li>
    <li class="del"><del>      FacetSwapV1Factory(factory).createPair(tokenA, tokenB)</del></li>
    <li class="ins"><ins>    if FacetSwapV1Factory<strong>02</strong>(factory).getPair(tokenA, tokenB) == address(0)</ins></li>
    <li class="ins"><ins>      FacetSwapV1Factory<strong>02</strong>(factory).createPair(tokenA, tokenB)</ins></li>
    <li class="unchanged"><span>    end</span></li>
    <li class="unchanged"><span>    (reserveA, reserveB) = getReserves(s.factory, tokenA, tokenB)</span></li>
    <li class="unchanged"><span>    if reserveA == 0 &amp;&amp; reserveB == 0</span></li>
    <li class="unchanged"><span>    end</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, :virtual, returns: { amountA: :uint256, amountB: :uint256, liquidity: :uint256 }) {</span></li>
    <li class="ins"><ins>    whenNotPaused!</ins></li>
    <li class="unchanged"><span>    require(deadline &gt;= block.timestamp, &quot;FacetSwapV1Router: EXPIRED&quot;)</span></li>
    <li class="unchanged"><span>    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin)</span></li>
    <li class="unchanged"><span>    pair = pairFor(s.factory, tokenA, tokenB)</span></li>
    <li class="unchanged"><span>    _safeTransferFrom(token: tokenA, from: msg.sender, to: pair, value: amountA)</span></li>
    <li class="unchanged"><span>    _safeTransferFrom(token: tokenB, from: msg.sender, to: pair, value: amountB)</span></li>
    <li class="del"><del>    liquidity = FacetSwapV1Pair(pair).mint(to: to)</del></li>
    <li class="ins"><ins>    liquidity = FacetSwapV1Pair<strong>02</strong>(pair).mint(to: to)</ins></li>
    <li class="unchanged"><span>    return { amountA: amountA, amountB: amountB, liquidity: liquidity }</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:removeLiquidity, { tokenA: :address, tokenB: :address, liquidity: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, :virtual, returns: { amountA: :uint256, amountB: :uint256 }) {</span></li>
    <li class="ins"><ins>    whenNotPaused!</ins></li>
    <li class="unchanged"><span>    require(deadline &gt;= block.timestamp, &quot;FacetSwapV1Router: EXPIRED&quot;)</span></li>
    <li class="unchanged"><span>    pair = pairFor(s.factory, tokenA, tokenB)</span></li>
    <li class="del"><del>    FacetSwapV1Pair(pair).transferFrom(msg.sender, pair, liquidity)</del></li>
    <li class="del"><del>    (amount0, amount1) = FacetSwapV1Pair(pair).burn(to)</del></li>
    <li class="ins"><ins>    FacetSwapV1Pair<strong>02</strong>(pair).transferFrom(msg.sender, pair, liquidity)</ins></li>
    <li class="ins"><ins>    (amount0, amount1) = FacetSwapV1Pair<strong>02</strong>(pair).burn(to)</ins></li>
    <li class="unchanged"><span>    (token0, _) = sortTokens(tokenA, tokenB)</span></li>
    <li class="unchanged"><span>    (amountA, amountB) = if tokenA == token0</span></li>
    <li class="unchanged"><span>      [amount0, amount1]</span></li>
    <li class="unchanged"><span>    return { amountA: amountA, amountB: amountB }</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:swapExactTokensForTokens, { amountIn: :uint256, amountOutMin: :uint256, path: [:address], to: :address, deadline: :uint256 }, :public, :virtual, returns: [:uint256]) {</span></li>
    <li class="ins"><ins>    whenNotPaused!</ins></li>
    <li class="ins"><ins>    require(path[0] == s.WETH || path[path.length - 1] == s.WETH, &quot;Must have WETH as either the first or last token in the path&quot;)</ins></li>
    <li class="ins"><ins>    amountInWithFee = if path[0] == s.WETH</ins></li>
    <li class="ins"><ins>      amountIn - calculateFeeAmount(amountIn)</ins></li>
    <li class="ins"><ins>    else</ins></li>
    <li class="ins"><ins>      amountIn</ins></li>
    <li class="ins"><ins>    end</ins></li>
    <li class="ins"><ins>    amounts = _swapExactTokensForTokens(amountIn: amountInWithFee, amountOutMin: amountOutMin, path: path, to: to, deadline: deadline)</ins></li>
    <li class="ins"><ins>    amountToChargeFeeOn = if path[0] == s.WETH</ins></li>
    <li class="ins"><ins>      amountIn</ins></li>
    <li class="ins"><ins>    else</ins></li>
    <li class="ins"><ins>      amounts[amounts.length - 1]</ins></li>
    <li class="ins"><ins>    end</ins></li>
    <li class="ins"><ins>    feeAmount = calculateFeeAmount(amountToChargeFeeOn)</ins></li>
    <li class="ins"><ins>    chargeWethFee(feeAmount)</ins></li>
    <li class="ins"><ins>    if path[0] == s.WETH</ins></li>
    <li class="ins"><ins>      amounts[0] = amountIn</ins></li>
    <li class="ins"><ins>    else</ins></li>
    <li class="ins"><ins>      amounts[amounts.length - 1] -= feeAmount</ins></li>
    <li class="ins"><ins>    end</ins></li>
    <li class="ins"><ins>    emit(:FeeAdjustedSwap, inputToken: path[0], outputToken: path[path.length - 1], inputAmount: amounts[0], outputAmount: amounts[amounts.length - 1], feeAmount: feeAmount, to: to)</ins></li>
    <li class="ins"><ins>    amounts</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:_swapExactTokensForTokens, { amountIn: :uint256, amountOutMin: :uint256, path: [:address], to: :address, deadline: :uint256 }, :internal, :virtual, returns: [:uint256]) {</ins></li>
    <li class="unchanged"><span>    require(deadline &gt;= block.timestamp, &quot;FacetSwapV1Router: EXPIRED&quot;)</span></li>
    <li class="unchanged"><span>    amounts = getAmountsOut(factory, amountIn, path)</span></li>
    <li class="unchanged"><span>    require(amounts[amounts.length - 1] &gt;= amountOutMin, &quot;FacetSwapV1Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;)</span></li>
    <li class="unchanged"><span>    return amounts</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:swapTokensForExactTokens, { amountOut: :uint256, amountInMax: :uint256, path: [:address], to: :address, deadline: :uint256 }, :public, :virtual, returns: [:uint256]) {</span></li>
    <li class="ins"><ins>    whenNotPaused!</ins></li>
    <li class="ins"><ins>    require(path[0] == s.WETH || path[path.length - 1] == s.WETH, &quot;Must have WETH as either the first or last token in the path&quot;)</ins></li>
    <li class="ins"><ins>    amountOutWithFee = if path[path.length - 1] == s.WETH</ins></li>
    <li class="ins"><ins>      amountOut + calculateFeeAmount(amountOut)</ins></li>
    <li class="ins"><ins>    else</ins></li>
    <li class="ins"><ins>      amountOut</ins></li>
    <li class="ins"><ins>    end</ins></li>
    <li class="ins"><ins>    amounts = _swapTokensForExactTokens(amountOut: amountOutWithFee, amountInMax: amountInMax, path: path, to: to, deadline: deadline)</ins></li>
    <li class="ins"><ins>    amountToChargeFeeOn = if path[0] == s.WETH</ins></li>
    <li class="ins"><ins>      amounts[0]</ins></li>
    <li class="ins"><ins>    else</ins></li>
    <li class="ins"><ins>      amountOut</ins></li>
    <li class="ins"><ins>    end</ins></li>
    <li class="ins"><ins>    feeAmount = calculateFeeAmount(amountToChargeFeeOn)</ins></li>
    <li class="ins"><ins>    chargeWethFee(feeAmount)</ins></li>
    <li class="ins"><ins>    if path[0] == s.WETH</ins></li>
    <li class="ins"><ins>      amounts[0] += feeAmount</ins></li>
    <li class="ins"><ins>    else</ins></li>
    <li class="ins"><ins>      amounts[amounts.length - 1] = amountOut</ins></li>
    <li class="ins"><ins>    end</ins></li>
    <li class="ins"><ins>    emit(:FeeAdjustedSwap, inputToken: path[0], outputToken: path[path.length - 1], inputAmount: amounts[0], outputAmount: amounts[amounts.length - 1], feeAmount: feeAmount, to: to)</ins></li>
    <li class="ins"><ins>    amounts</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:_swapTokensForExactTokens, { amountOut: :uint256, amountInMax: :uint256, path: [:address], to: :address, deadline: :uint256 }, :internal, :virtual, returns: [:uint256]) {</ins></li>
    <li class="unchanged"><span>    require(deadline &gt;= block.timestamp, &quot;FacetSwapV1Router: EXPIRED&quot;)</span></li>
    <li class="unchanged"><span>    amounts = getAmountsIn(factory, amountOut, path)</span></li>
    <li class="unchanged"><span>    require(amounts[0] &lt;= amountInMax, &quot;FacetSwapV1Router: EXCESSIVE_INPUT_AMOUNT&quot;)</span></li>
    <li class="unchanged"><span>      else</span></li>
    <li class="unchanged"><span>        _to</span></li>
    <li class="unchanged"><span>      end</span></li>
    <li class="del"><del>      FacetSwapV1Pair(pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, &quot;&quot;)</del></li>
    <li class="ins"><ins>      FacetSwapV1Pair<strong>02</strong>(pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, &quot;&quot;)</ins></li>
    <li class="unchanged"><span>    }</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:_safeTransferFrom, { token: :address, from: :address, to: :address, value: :uint256 }, :private) {</span></li>
    <li class="unchanged"><span>  function(:getAmountOut, { amountIn: :uint256, reserveIn: :uint256, reserveOut: :uint256 }, :public, :view, returns: :uint256) {</span></li>
    <li class="unchanged"><span>    require(amountIn &gt; 0, &quot;FacetSwapV1Library: INSUFFICIENT_INPUT_AMOUNT&quot;)</span></li>
    <li class="unchanged"><span>    require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &quot;FacetSwapV1Library: INSUFFICIENT_LIQUIDITY&quot;)</span></li>
    <li class="del"><del>    <strong>a</strong>mountInWithFee = amountIn * <strong>997</strong></del></li>
    <li class="ins"><ins>    <strong>lpFeeBPS = FacetSwapV1Factory02(s.factory).lpFeeBPS</strong></ins></li>
    <li class="ins"><ins><strong>    totalFeeFactor = 1000 - lpFeeBPS.div(10)</strong></ins></li>
    <li class="ins"><ins><strong>    a</strong>mountInWithFee = amountIn * <strong>totalFeeFactor</strong></ins></li>
    <li class="unchanged"><span>    numerator = amountInWithFee * reserveOut</span></li>
    <li class="unchanged"><span>    denominator = reserveIn * 1000 + amountInWithFee</span></li>
    <li class="unchanged"><span>    amountOut = numerator.div(denominator)</span></li>
    <li class="unchanged"><span>  function(:getAmountIn, { amountOut: :uint256, reserveIn: :uint256, reserveOut: :uint256 }, :public, :view, returns: :uint256) {</span></li>
    <li class="unchanged"><span>    require(amountOut &gt; 0, &quot;FacetSwapV1Library: INSUFFICIENT_OUTPUT_AMOUNT&quot;)</span></li>
    <li class="unchanged"><span>    require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &quot;FacetSwapV1Library: INSUFFICIENT_LIQUIDITY&quot;)</span></li>
    <li class="ins"><ins>    lpFeeBPS = FacetSwapV1Factory02(s.factory).lpFeeBPS</ins></li>
    <li class="ins"><ins>    totalFeeFactor = 1000 - lpFeeBPS.div(10)</ins></li>
    <li class="unchanged"><span>    numerator = reserveIn * amountOut * 1000</span></li>
    <li class="del"><del>    denominator = (reserveOut - amountOut) * <strong>997</strong></del></li>
    <li class="ins"><ins>    denominator = (reserveOut - amountOut) * <strong>totalFeeFactor</strong></ins></li>
    <li class="unchanged"><span>    amountIn = (numerator.div(denominator)) + 1</span></li>
    <li class="unchanged"><span>    return amountIn</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:getReserves, { factory: :address, tokenA: :address, tokenB: :address }, :public, :view, returns: { reserveA: :uint256, reserveB: :uint256 }) {</span></li>
    <li class="unchanged"><span>    (token0, _) = sortTokens(tokenA, tokenB)</span></li>
    <li class="del"><del>    (reserve0, reserve1, _) = FacetSwapV1Pair(pairFor(factory, tokenA, tokenB)).getReserves</del></li>
    <li class="ins"><ins>    (reserve0, reserve1, _) = FacetSwapV1Pair<strong>02</strong>(pairFor(factory, tokenA, tokenB)).getReserves</ins></li>
    <li class="unchanged"><span>    (reserveA, reserveB) = if tokenA == token0</span></li>
    <li class="unchanged"><span>      [reserve0, reserve1]</span></li>
    <li class="unchanged"><span>    else</span></li>
    <li class="unchanged"><span>    end</span></li>
    <li class="unchanged"><span>    return { reserveA: reserveA, reserveB: reserveB }</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="del"><del>  function(:pairFor, { factory: :address, tokenA: :address, tokenB: :address }, :internal, :<strong>pure</strong>, returns: :address) {</del></li>
    <li class="del"><del>    <strong>(token0, token1) = sortTokens(tokenA, tokenB)</strong></del></li>
    <li class="del"><del><strong>    ret</strong>urn <strong>create2_address(salt: keccak256(abi.encodePacked</strong>(token<strong>0</strong>, token<strong>1)), deployer: factory, contract_type: &quot;FacetSwapV1Pair&quot;)</strong></del></li>
    <li class="ins"><ins>  function(:pairFor, { factory: :address, tokenA: :address, tokenB: :address }, :internal, :<strong>view</strong>, returns: :address) {</ins></li>
    <li class="ins"><ins>    <strong>ret</strong>urn <strong>FacetSwapV1Factory02(s.factory).getPair</strong>(token<strong>A</strong>, token<strong>B)</strong></ins></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="unchanged"><span>  function(:sortTokens, { tokenA: :address, tokenB: :address }, :internal, :pure, returns: { token0: :address, token1: :address }) {</span></li>
    <li class="unchanged"><span>    require(tokenA != tokenB, &quot;FacetSwapV1Library: IDENTICAL_ADDRESSES&quot;)</span></li>
    <li class="unchanged"><span>    require(token0 != address(0), &quot;FacetSwapV1Library: ZERO_ADDRESS&quot;)</span></li>
    <li class="unchanged"><span>    return { token0: token0, token1: token1 }</span></li>
    <li class="unchanged"><span>  }</span></li>
    <li class="ins"><ins>  function(:chargeWethFee, { feeAmount: :uint256 }, :internal, returns: :bool) {</ins></li>
    <li class="ins"><ins>    ERC20(s.WETH).transferFrom(from: msg.sender, to: address(this), amount: feeAmount)</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:calculateFeeAmount, { amount: :uint256 }, :public, :view, returns: :uint256) {</ins></li>
    <li class="ins"><ins>    return (amount * s.protocolFeeBPS).div(10000)</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:updateProtocolFee, { protocolFeeBPS: :uint256 }, :public) {</ins></li>
    <li class="ins"><ins>    onlyOwner!</ins></li>
    <li class="ins"><ins>    require(protocolFeeBPS &lt;= 10000, &quot;Fee cannot be greater than 100%&quot;)</ins></li>
    <li class="ins"><ins>    s.protocolFeeBPS=protocolFeeBPS</ins></li>
    <li class="ins"><ins>    nil</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:withdrawFees, { to: :address }, :public, returns: :bool) {</ins></li>
    <li class="ins"><ins>    onlyOwner!</ins></li>
    <li class="ins"><ins>    ERC20(s.WETH).transfer(to: to, amount: ERC20(s.WETH).balanceOf(address(this)))</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:pause, :public) {</ins></li>
    <li class="ins"><ins>    onlyOwner!</ins></li>
    <li class="ins"><ins>    _pause</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="ins"><ins>  function(:unpause, :public) {</ins></li>
    <li class="ins"><ins>    onlyOwner!</ins></li>
    <li class="ins"><ins>    _unpause</ins></li>
    <li class="ins"><ins>  }</ins></li>
    <li class="unchanged"><span>  function(:userStats, { user: :address, tokenA: :address, tokenB: :address }, :public, :view, returns: { userTokenABalance: :uint256, userTokenBBalance: :uint256, tokenAName: :string, tokenBName: :string, tokenAReserves: :uint256, tokenBReserves: :uint256, userLPBalance: :uint256, pairAddress: :address }) {</span></li>
    <li class="unchanged"><span>    tokenAReserves = 0</span></li>
    <li class="unchanged"><span>    tokenBReserves = 0</span></li>
    <li class="unchanged"><span>    userLPBalance = 0</span></li>
    <li class="del"><del>    if FacetSwapV1Factory(s.factory).getPair(tokenA, tokenB) != address(0)</del></li>
    <li class="ins"><ins>    if FacetSwapV1Factory<strong>02</strong>(s.factory).getPair(tokenA, tokenB) != address(0)</ins></li>
    <li class="unchanged"><span>      (tokenAReserves, tokenBReserves) = getReserves(s.factory, tokenA, tokenB)</span></li>
    <li class="del"><del>      pair = FacetSwapV1Factory(s.factory).getPair(tokenA, tokenB)</del></li>
    <li class="ins"><ins>      pair = FacetSwapV1Factory<strong>02</strong>(s.factory).getPair(tokenA, tokenB)</ins></li>
    <li class="unchanged"><span>      userLPBalance = FacetSwapV1ERC20(pair).balanceOf(user)</span></li>
    <li class="unchanged"><span>    end</span></li>
    <li class="unchanged"><span>    return { userTokenABalance: ERC20(tokenA).balanceOf(user), userTokenBBalance: ERC20(tokenB).balanceOf(user), tokenAName: ERC20(tokenA).name, tokenBName: ERC20(tokenB).name, tokenAReserves: tokenAReserves, tokenBReserves: tokenBReserves, userLPBalance: userLPBalance, pairAddress: pair }</span></li>
  </ul>
</div>
</body></html>