[
  {
    "id": 1,
    "transaction_hash": "0x93ea51222f41418dad2159517b4f82dd02e52c766a3a528f587acf1035b8d94d",
    "internal_transaction_index": 0,
    "block_number": 18684900,
    "transaction_index": 16,
    "name": "PublicMintERC20",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:PublicMintERC20, is: :ERC20) {\n  uint256(:public, :maxSupply)\n  uint256(:public, :perMintLimit)\n  constructor(name: :string, symbol: :string, maxSupply: :uint256, perMintLimit: :uint256, decimals: :uint8) {\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: decimals)\n    s.maxSupply=maxSupply\n    s.perMintLimit=perMintLimit\n  }\n  function(:mint, { amount: :uint256 }, :public) {\n    require(amount > 0, \"Amount must be positive\")\n    require(amount <= s.perMintLimit, \"Exceeded mint limit\")\n    require(s.totalSupply + amount <= s.maxSupply, \"Exceeded max supply\")\n    _mint(to: msg.sender, amount: amount)\n  }\n  function(:airdrop, { to: :address, amount: :uint256 }, :public) {\n    require(amount > 0, \"Amount must be positive\")\n    require(amount <= s.perMintLimit, \"Exceeded mint limit\")\n    require(s.totalSupply + amount <= s.maxSupply, \"Exceeded max supply\")\n    _mint(to: to, amount: amount)\n  }\n}\n",
    "init_code_hash": "0xb1b0ed1e4a8c9c9b0210f267137e368f782453e41f622fa8cf68296d04c84c88",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-12T22:04:04.291Z",
    "updated_at": "2024-02-12T22:04:04.291Z"
  },
  {
    "id": 2,
    "transaction_hash": "0x58875411afb6c4b69b85e3890557739ec88c26a8c1daf14c9d58489215b53d64",
    "internal_transaction_index": 0,
    "block_number": 18684900,
    "transaction_index": 60,
    "name": "AirdropERC20",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:AirdropERC20, is: [:ERC20, :Ownable]) {\n  uint256(:public, :maxSupply)\n  uint256(:public, :perMintLimit)\n  uint256(:public, :singleTxAirdropLimit)\n  constructor(name: :string, symbol: :string, owner: :address, maxSupply: :uint256, perMintLimit: :uint256, decimals: :uint8) {\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: decimals)\n    self.Ownable.constructor(owner: owner)\n    s.maxSupply=maxSupply\n    s.perMintLimit=perMintLimit\n    s.singleTxAirdropLimit=10\n  }\n  function(:airdrop, { to: :address, amount: :uint256 }, :public) {\n    onlyOwner!\n    require(amount > 0, \"Amount must be positive\")\n    require(amount <= s.perMintLimit, \"Exceeded mint limit\")\n    require(s.totalSupply + amount <= s.maxSupply, \"Exceeded max supply\")\n    _mint(to: to, amount: amount)\n  }\n  function(:airdropMultiple, { addresses: [:address], amounts: [:uint256] }, :public) {\n    onlyOwner!\n    require(addresses.length == amounts.length, \"Address and amount arrays must be the same length\")\n    require(addresses.length <= s.singleTxAirdropLimit, \"Cannot import more than 10 addresses at a time\")\n    forLoop(condition: ->(i) {\n      i < addresses.length\n    }, max_iterations: s.singleTxAirdropLimit) { |i|\n      to = addresses[i]\n      amount = amounts[i]\n      airdrop(to: to, amount: amount)\n    }\n  }\n  function(:burn, { amount: :uint256 }, :public) {\n    _burn(from: msg.sender, amount: amount)\n  }\n}\n",
    "init_code_hash": "0x45b224f1320c602a827823099dc4e7f596baf4227f919102a7f80523834edb02",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-12T22:04:04.291Z",
    "updated_at": "2024-02-12T22:04:04.291Z"
  },
  {
    "id": 3,
    "transaction_hash": "0x0d589992fcaafc848de21613cd38235c6cbd0f671b8b1ccaa8b6bad946c83885",
    "internal_transaction_index": 0,
    "block_number": 18684901,
    "transaction_index": 34,
    "name": "EtherBridge",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:EtherBridge, is: [:ERC20, :Upgradeable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  address(:public, :trustedSmartContract)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(name: :string, symbol: :string, trustedSmartContract: :address) {\n    require(trustedSmartContract != address(0), \"Invalid smart contract\")\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: 18)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.trustedSmartContract=trustedSmartContract\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can bridge in tokens\")\n    _mint(to: to, amount: amount)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeOut, { amount: :uint256 }, :public) {\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[msg.sender] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(amount > 0, \"Invalid amount\")\n    s.userWithdrawalId[msg.sender] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    _burn(from: msg.sender, amount: amount)\n    emit(:InitiateWithdrawal, from: msg.sender, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can mark withdrawals as complete\")\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n}\n",
    "init_code_hash": "0xbae85b82353ff68e9cee3036897d289b77c8393783829489b9ab3255c0158064",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-12T22:04:04.436Z",
    "updated_at": "2024-02-12T22:04:04.436Z"
  },
  {
    "id": 4,
    "transaction_hash": "0xe770699a37c2651116affffd1baa7fd17148e2c7eb08d8e03103184043d74552",
    "internal_transaction_index": 0,
    "block_number": 18684902,
    "transaction_index": 97,
    "name": "EthscriptionERC20Bridge",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:EthscriptionERC20Bridge, is: [:ERC20, :Upgradeable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  uint256(:public, :mintAmount)\n  address(:public, :trustedSmartContract)\n  mapping(({ address: :uint256 }), :public, :bridgedInAmount)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(name: :string, symbol: :string, mintAmount: :uint256, trustedSmartContract: :address) {\n    require(mintAmount > 0, \"Invalid mint amount\")\n    require(trustedSmartContract != address(0), \"Invalid smart contract\")\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: 18)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.mintAmount=mintAmount\n    s.trustedSmartContract=trustedSmartContract\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can bridge in tokens\")\n    s.bridgedInAmount[to] += amount\n    _mint(to: to, amount: amount * s.mintAmount * 1.ether)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeOut, { amount: :uint256 }, :public) {\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[msg.sender] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(s.bridgedInAmount[msg.sender] >= amount, \"Not enough bridged in\")\n    require(amount > 0, \"Invalid amount\")\n    s.userWithdrawalId[msg.sender] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    s.bridgedInAmount[msg.sender] -= amount\n    _burn(from: msg.sender, amount: amount * s.mintAmount * 1.ether)\n    emit(:InitiateWithdrawal, from: msg.sender, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can mark withdrawals as complete\")\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n}\n",
    "init_code_hash": "0x59d8cb5c619ff39d775b4232c30f329f29806a5e4db65ee5aa7652826f65bd9d",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-12T22:04:04.574Z",
    "updated_at": "2024-02-12T22:04:04.574Z"
  },
  {
    "id": 5,
    "transaction_hash": "0xec5d415d7edfcfd78c9927ba2dc04eb1e8cd334af49a2deef674d43ed2264dab",
    "internal_transaction_index": 0,
    "block_number": 18684905,
    "transaction_index": 77,
    "name": "NameRegistry",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(_isApprovedOrOwner(spender: msg.sender, id: id), \"NOT_AUTHORIZED\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    return nil\n  }\n  function(:_isApprovedOrOwner, { spender: :address, id: :uint256 }, :internal, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:NameRegistryRenderer, abstract: true) {\n  string(:public, :cardTemplate)\n  event(:StickerCreated, { stickerId: :uint256, name: :string, description: :string, imageURI: :string, stickerExpiry: :uint256, grantingAddress: :address })\n  event(:StickerClaimed, { stickerId: :uint256, claimer: :address })\n  event(:StickerPlaced, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) })\n  event(:StickerRepositioned, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) })\n  event(:CardDetailsSet, { tokenId: :uint256, displayName: :string, bio: :string, imageURI: :string, links: [:string] })\n  mapping(({ uint256: :string }), :public, :cardDisplayNames)\n  mapping(({ uint256: :string }), :public, :cardBios)\n  mapping(({ uint256: :string }), :public, :cardImageURIs)\n  mapping(({ uint256: [:string] }), :public, :cardLinks)\n  uint256(:public, :nextStickerId)\n  mapping(({ uint256: :address }), :public, :stickerIdToSigner)\n  mapping(({ uint256: :string }), :public, :stickerIdToName)\n  mapping(({ uint256: :string }), :public, :stickerIdToDescription)\n  mapping(({ uint256: :string }), :public, :stickerIdToImageURI)\n  mapping(({ uint256: :uint256 }), :public, :stickerIdToExpiry)\n  mapping(({ address: [:uint256] }), :public, :userToStickerAry)\n  mapping(({ address: mapping(uint256: :bool) }), :public, :userToStickerIdsAwardedMap)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerIdsAry)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerXPositionsAry)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerYPositionsAry)\n  mapping(({ uint256: mapping(uint256: :bool) }), :public, :tokenIdToStickerIdsPlacedMap)\n  uint256(:public, :maxStickersPerUser)\n  uint256(:public, :maxStickersPerCard)\n  uint256(:public, :maxLinksPerCard)\n  uint256(:public, :bioMaxLength)\n  uint256(:public, :displayNameMaxLength)\n  uint256(:public, :uriMaxLength)\n  constructor(cardTemplate: :string) {\n    s.maxStickersPerUser=25\n    s.maxStickersPerCard=s.maxStickersPerUser\n    s.maxLinksPerCard=5\n    s.bioMaxLength=1000\n    s.displayNameMaxLength=100\n    s.uriMaxLength=96000\n    require(cardTemplate.length <= s.uriMaxLength, \"cardTemplate too long\")\n    s.cardTemplate=cardTemplate\n  }\n  function(:renderCard, { tokenId: :uint256 }, :public, :view, returns: :string) {\n    enforceNotExpired!(tokenId)\n    owner = ownerOf(tokenId)\n    name = s.tokenIdToName[tokenId]\n    (stickerIds, stickerXPositions, stickerYPositions, stickerImageURIs) = getCardStickers(tokenId)\n    (displayName, bio, imageURI, links) = getCardDetails(tokenId)\n    storage = json.stringify(tokenId: tokenId.toString, owner: owner, name: name, stickerIds: stickerIds, stickerXPositions: stickerXPositions, stickerYPositions: stickerYPositions, stickerImages: stickerImageURIs, displayName: displayName, bio: bio, imageURI: imageURI, links: links)\n    template = \"`#{s.cardTemplate}`\"\n    wrapped = <<-HEREDOC\n<script>\n  window.s = #{storage};\n  document.open();\n  document.write(#{template});\n  document.close();\n</script>\n    HEREDOC\n  }\n  function(:createSticker, { name: :string, description: :string, imageURI: :string, stickerExpiry: :uint256, grantingAddress: :address }, :public) {\n    whenNotPaused!\n    require(name.length > 0, \"Name must be non-empty\")\n    require(name.length <= s.displayNameMaxLength, \"Name too long\")\n    require(description.length <= s.bioMaxLength, \"description too long\")\n    require(imageURI.length <= s.uriMaxLength, \"imageURI too long\")\n    require(grantingAddress != address(0), \"Granting address must be non-zero\")\n    currentId = s.nextStickerId\n    s.nextStickerId += 1\n    s.stickerIdToName[currentId] = name\n    s.stickerIdToImageURI[currentId] = imageURI\n    s.stickerIdToDescription[currentId] = description\n    s.stickerIdToExpiry[currentId] = stickerExpiry\n    s.stickerIdToSigner[currentId] = grantingAddress\n    emit(:StickerCreated, stickerId: currentId, name: name, description: description, imageURI: imageURI, stickerExpiry: stickerExpiry, grantingAddress: grantingAddress)\n  }\n  function(:claimSticker, { stickerId: :uint256, deadline: :uint256, tokenId: :uint256, position: array(:uint256, 2), signature: :bytes }, :public) {\n    whenNotPaused!\n    require(!s.userToStickerIdsAwardedMap[msg.sender][stickerId], \"Sticker already awarded\")\n    require(s.userToStickerAry[msg.sender].length < s.maxStickersPerUser, \"Too many stickers\")\n    require(deadline > block.timestamp, \"Deadline passed\")\n    require(s.stickerIdToExpiry[stickerId] > block.timestamp, \"Sticker expired\")\n    signatureValid = signature.verifyTypedDataSignature({ StickerClaim: [{ name: \"stickerId\", type: \"uint256\" }, { name: \"claimer\", type: \"address\" }, { name: \"deadline\", type: \"uint256\" }] }, { stickerId: stickerId, claimer: msg.sender, deadline: deadline }, verifyingContract: address(this), domainName: s.name, domainVersion: \"1\", signer: s.stickerIdToSigner[stickerId])\n    require(signatureValid, \"Invalid signature\")\n    s.userToStickerIdsAwardedMap[msg.sender][stickerId] = true\n    s.userToStickerAry[msg.sender].push(stickerId)\n    if tokenId != 0\n      placeSticker(stickerId, tokenId, position)\n    end\n    emit(:StickerClaimed, stickerId: stickerId, claimer: msg.sender)\n  }\n  function(:placeSticker, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) }, :public) {\n    whenNotPaused!\n    enforceNotExpired!(tokenId)\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    require(s.userToStickerIdsAwardedMap[msg.sender][stickerId], \"Sticker not claimed\")\n    require(!s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId], \"Sticker already placed\")\n    require(s.tokenIdToStickerIdsAry[tokenId].length < s.maxStickersPerCard, \"Too many stickers\")\n    s.tokenIdToStickerIdsAry[tokenId].push(stickerId)\n    s.tokenIdToStickerXPositionsAry[tokenId].push(position[0])\n    s.tokenIdToStickerYPositionsAry[tokenId].push(position[1])\n    s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId] = true\n    emit(:StickerPlaced, stickerId: stickerId, tokenId: tokenId, position: position)\n  }\n  function(:repositionSticker, { stickerIndex: :uint256, tokenId: :uint256, position: array(:uint256, 2) }, :public) {\n    whenNotPaused!\n    enforceNotExpired!(tokenId)\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    stickerId = s.tokenIdToStickerIdsAry[tokenId][stickerIndex]\n    require(s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId], \"Sticker not placed\")\n    s.tokenIdToStickerXPositionsAry[tokenId][stickerIndex] = position[0]\n    s.tokenIdToStickerYPositionsAry[tokenId][stickerIndex] = position[1]\n    emit(:StickerRepositioned, stickerId: stickerId, tokenId: tokenId, position: position)\n  }\n  function(:setCardDetails, { tokenId: :uint256, displayName: :string, bio: :string, imageURI: :string, links: [:string] }, :public) {\n    whenNotPaused!\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    require(links.length <= s.maxLinksPerCard, \"Too many links\")\n    require(bio.length <= s.bioMaxLength, \"Bio too long\")\n    require(displayName.length <= s.displayNameMaxLength, \"Display name too long\")\n    require(imageURI.length <= s.uriMaxLength, \"imageURI too long\")\n    s.cardDisplayNames[tokenId] = displayName\n    s.cardBios[tokenId] = bio\n    s.cardImageURIs[tokenId] = imageURI\n    s.cardLinks[tokenId] = links\n    emit(:CardDetailsSet, tokenId: tokenId, displayName: displayName, bio: bio, imageURI: imageURI, links: links)\n  }\n  function(:getCardDetails, { tokenId: :uint256 }, :public, :view, returns: { displayName: :string, bio: :string, imageURI: :string, links: [:string] }) {\n    enforceNotExpired!(tokenId)\n    return { displayName: s.cardDisplayNames[tokenId], bio: s.cardBios[tokenId], imageURI: s.cardImageURIs[tokenId], links: s.cardLinks[tokenId] }\n  }\n  function(:getCardStickers, { tokenId: :uint256 }, :public, :view, returns: { stickerIds: [:uint256], stickerXPositions: [:uint256], stickerYPositions: [:uint256], stickerImageURIs: [:string] }) {\n    enforceNotExpired!(tokenId)\n    stickerIds = array(:uint256, 0)\n    stickerXPositions = array(:uint256, 0)\n    stickerYPositions = array(:uint256, 0)\n    stickerImageURIs = array(:string, 0)\n    forLoop(condition: ->(i) {\n      i < s.tokenIdToStickerIdsAry[tokenId].length\n    }) { |i|\n      stickerId = s.tokenIdToStickerIdsAry[tokenId][i]\n      if (s.stickerIdToExpiry[stickerId] > block.timestamp)\n        stickerIds.push(stickerId)\n        stickerXPositions.push(s.tokenIdToStickerXPositionsAry[tokenId][i])\n        stickerYPositions.push(s.tokenIdToStickerYPositionsAry[tokenId][i])\n        stickerImageURIs.push(s.stickerIdToImageURI[stickerId])\n      end\n    }\n    return { stickerIds: stickerIds, stickerXPositions: stickerXPositions, stickerYPositions: stickerYPositions, stickerImageURIs: stickerImageURIs }\n  }\n  function(:updateCardTemplate, { cardTemplate: :string }, :public) {\n    onlyOwner!\n    s.cardTemplate=cardTemplate\n  }\n  function(:_clearCardPersonalInfo, { tokenId: :uint256 }, :internal) {\n    _clearCardDetails(tokenId)\n    _clearStickers(tokenId)\n  }\n  function(:_clearCardDetails, { tokenId: :uint256 }, :internal) {\n    s.cardDisplayNames[tokenId] = \"\"\n    s.cardBios[tokenId] = \"\"\n    s.cardImageURIs[tokenId] = \"\"\n    s.cardLinks[tokenId] = array(:string, 0)\n    nil\n  }\n  function(:_clearStickers, { tokenId: :uint256 }, :internal) {\n    forLoop(condition: ->(i) {\n      i < s.tokenIdToStickerIdsAry[tokenId].length\n    }) { |i|\n      stickerId = s.tokenIdToStickerIdsAry[tokenId][i]\n      s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId] = false\n    }\n    s.tokenIdToStickerIdsAry[tokenId] = array(:uint256, 0)\n    s.tokenIdToStickerXPositionsAry[tokenId] = array(:uint256, 0)\n    s.tokenIdToStickerYPositionsAry[tokenId] = array(:uint256, 0)\n    nil\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:NameRegistry, is: [:ERC721, :Upgradeable, :Ownable, :Pausable, :NameRegistryRenderer], upgradeable: true) {\n  event(:NameRegistered, { tokenId: :uint256, owner: :address, name: :string, expires: :uint256 })\n  event(:NameRenewed, { tokenId: :uint256, newExpiry: :uint256 })\n  event(:PrimaryNameSet, { user: :address, tokenId: :uint256 })\n  event(:ConversionRateUpdate, { newRate: :uint256 })\n  address(:public, :WETH)\n  uint256(:public, :usdWeiCentsInOneEth)\n  uint256(:public, :minRegistrationDuration)\n  uint256(:public, :gracePeriod)\n  uint256(:public, :maxNameLength)\n  array(:uint256, :public, :charCountToUsdWeiCentsPrice, initial_length: 0)\n  bool(:public, :preregistrationComplete)\n  uint256(:public, :nextTokenId)\n  mapping(({ string: :uint256 }), :public, :nameToTokenId)\n  mapping(({ uint256: :string }), :public, :tokenIdToName)\n  mapping(({ address: :uint256 }), :internal, :userToPrimaryNameTokenId)\n  mapping(({ uint256: :uint256 }), :public, :tokenExpiryTimes)\n  mapping(({ uint256: :uint256 }), :public, :registrationTimestamps)\n  uint256(:public, :maxImportBatchSize)\n  constructor(name: :string, symbol: :string, owner: :address, usdWeiCentsInOneEth: :uint256, charCountToUsdWeiCentsPrice: [:uint256], cardTemplate: :string, _WETH: :address) {\n    require(charCountToUsdWeiCentsPrice.length >= 4, \"Must have at least 4 price points\")\n    require(charCountToUsdWeiCentsPrice.length <= 10, \"Must have at most 10 price points\")\n    self.ERC721.constructor(name: name, symbol: symbol)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: owner)\n    self.Pausable.constructor(initialPauseState: true)\n    self.NameRegistryRenderer.constructor(cardTemplate: cardTemplate)\n    s.WETH=_WETH\n    s.usdWeiCentsInOneEth=usdWeiCentsInOneEth\n    s.charCountToUsdWeiCentsPrice=charCountToUsdWeiCentsPrice\n    s.maxNameLength=32\n    s.gracePeriod=90.days\n    s.minRegistrationDuration=28.days\n    s.nextTokenId=1\n    s.nextStickerId=1\n    s.maxImportBatchSize=10\n  }\n  function(:registerNameWithPayment, { to: :address, name: :string, durationInSeconds: :uint256 }, :public, returns: :bool) {\n    whenNotPaused!\n    require(s.preregistrationComplete, \"Preregistration must be complete\")\n    require(durationInSeconds >= s.minRegistrationDuration, \"Duration too short\")\n    _registerName(to: to, name: name, durationInSeconds: durationInSeconds)\n    if to == msg.sender && s.userToPrimaryNameTokenId[msg.sender] == 0\n      tokenId = s.nameToTokenId[name]\n      s.userToPrimaryNameTokenId[msg.sender] = tokenId\n    end\n    ERC20(s.WETH).transferFrom(msg.sender, address(this), getPrice(name, durationInSeconds))\n  }\n  function(:renewNameWithPayment, { name: :string, durationInSeconds: :uint256 }, :public, returns: :bool) {\n    whenNotPaused!\n    _renewName(name: name, durationInSeconds: durationInSeconds)\n    ERC20(s.WETH).transferFrom(msg.sender, address(this), getPrice(name, durationInSeconds))\n  }\n  function(:_registerName, { to: :address, name: :string, durationInSeconds: :uint256 }, :internal) {\n    require(nameAvailable(name), \"Name not available\")\n    require(nameIsValid(name), \"Invalid name\")\n    tokenId = s.nameToTokenId[name]\n    if _exists(tokenId)\n      _burn(tokenId)\n    else\n      tokenId = s.nextTokenId\n      s.nextTokenId += 1\n    end\n    _mint(to: to, id: tokenId)\n    s.nameToTokenId[name] = tokenId\n    s.tokenIdToName[tokenId] = name\n    s.tokenExpiryTimes[tokenId] = block.timestamp + durationInSeconds\n    s.registrationTimestamps[tokenId] = block.timestamp\n    emit(:NameRegistered, tokenId: tokenId, owner: to, name: name, expires: s.tokenExpiryTimes[tokenId])\n  }\n  function(:_renewName, { name: :string, durationInSeconds: :uint256 }, :internal) {\n    tokenId = s.nameToTokenId[name]\n    currentExpiry = s.tokenExpiryTimes[tokenId]\n    require(currentExpiry + s.gracePeriod >= block.timestamp, \"Must be registered or in grace period\")\n    s.tokenExpiryTimes[tokenId] = currentExpiry + durationInSeconds\n    emit(:NameRenewed, tokenId: tokenId, newExpiry: s.tokenExpiryTimes[tokenId])\n  }\n  function(:markPreregistrationComplete, :public) {\n    onlyOwner!\n    s.preregistrationComplete=true\n    nil\n  }\n  function(:importFromPreregistration, { names: [:string], owners: [:address], durations: [:uint256] }, :public) {\n    onlyOwner!\n    require(!s.preregistrationComplete, \"Preregistration must not be complete\")\n    require(names.length == owners.length, \"Names and owners must be the same length\")\n    require(names.length == durations.length, \"Names and owners must be the same length\")\n    require(names.length <= s.maxImportBatchSize, \"Cannot import more than 10 names at a time\")\n    forLoop(condition: ->(i) {\n      i < names.length\n    }) { |i|\n      _registerName(to: owners[i], name: names[i], durationInSeconds: durations[i])\n      if s.userToPrimaryNameTokenId[owners[i]] == 0\n        tokenId = s.nameToTokenId[names[i]]\n        s.userToPrimaryNameTokenId[owners[i]] = tokenId\n      end\n    }\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :override, returns: :string) {\n    enforceNotExpired!(id)\n    require(_exists(id: id), \"ERC721Metadata: URI query for nonexistent token\")\n    name = s.tokenIdToName[id]\n    card = self.NameRegistryRenderer.renderCard(id)\n    b64Card = \"data:text/html;charset=utf-8;base64,\" + card.base64Encode\n    json_data = json.stringify(name: \"#{name} (##{id.toString})\", description: s.cardBios[id], animation_url: b64Card)\n    return \"data:application/json,#{json_data}\"\n  }\n  function(:_burn, { id: :uint256 }, :internal, :override) {\n    owner = s._ownerOf[id]\n    if s.userToPrimaryNameTokenId[owner] == id\n      s.userToPrimaryNameTokenId[owner] = 0\n    end\n    _clearCardPersonalInfo(id)\n    self.ERC721._burn(id)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :override) {\n    if s.userToPrimaryNameTokenId[from] == id\n      s.userToPrimaryNameTokenId[from] = 0\n    end\n    _clearCardPersonalInfo(id)\n    self.ERC721.transferFrom(from: from, to: to, id: id)\n  }\n  function(:enforceNotExpired!, { id: :uint256 }, :internal) {\n    require(s.tokenExpiryTimes[id] > block.timestamp, \"Name expired\")\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :override, returns: :address) {\n    owner = self.ERC721.ownerOf(id)\n    enforceNotExpired!(id)\n    owner\n  }\n  function(:lookupAddress, { user: :address }, :public, :view, returns: :string) {\n    candidateId = s.userToPrimaryNameTokenId[user]\n    require(ownerOf(candidateId) == user, \"Not the owner\")\n    s.tokenIdToName[candidateId]\n  }\n  function(:setPrimaryName, { name: :string }, :public) {\n    tokenId = s.nameToTokenId[name]\n    require(msg.sender == ownerOf(tokenId), \"Not the owner\")\n    s.userToPrimaryNameTokenId[msg.sender] = tokenId\n    emit(:PrimaryNameSet, user: msg.sender, tokenId: tokenId)\n  }\n  function(:resolveName, { name: :string }, :public, :view, returns: :address) {\n    tokenId = s.nameToTokenId[name]\n    ownerOf(tokenId)\n  }\n  function(:nameIsValid, { name: :string }, :public, :view, returns: :bool) {\n    name.length <= s.maxNameLength && name.isAlphaNumeric? && name.downcase == name\n  }\n  function(:nameAvailable, { name: :string }, :public, :view, returns: :bool) {\n    tokenId = s.nameToTokenId[name]\n    if !_exists(tokenId)\n      return true\n    end\n    s.tokenExpiryTimes[tokenId] + s.gracePeriod < block.timestamp\n  }\n  function(:getPrice, { name: :string, durationInSeconds: :uint256 }, :public, :view, returns: :uint256) {\n    len = name.length\n    priceWeiCentsPerSecond = if len >= s.charCountToUsdWeiCentsPrice.length\n      s.charCountToUsdWeiCentsPrice.last\n    else\n      s.charCountToUsdWeiCentsPrice[len - 1]\n    end\n    totalPriceWeiCents = priceWeiCentsPerSecond * durationInSeconds\n    (totalPriceWeiCents * 1.ether).div(s.usdWeiCentsInOneEth)\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:setUsdWeiCentsInOneEth, { rate: :uint256 }, :public) {\n    onlyOwner!\n    s.usdWeiCentsInOneEth=rate\n    emit(:ConversionRateUpdate, newRate: rate)\n  }\n  function(:withdrawWETH, :public, returns: :bool) {\n    onlyOwner!\n    amount = ERC20(s.WETH).balanceOf(address(this))\n    ERC20(s.WETH).transfer(s.owner, amount)\n  }\n  function(:totalSupply, :public, :view, returns: :uint256) {\n    nextTokenId - 1\n  }\n}\n",
    "init_code_hash": "0xc795e18b2e8e94b663636bb7dd0b7d9c9c4d8534b384db5339f4a26dffc6e139",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(_isApprovedOrOwner(spender: msg.sender, id: id), \"NOT_AUTHORIZED\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    return nil\n  }\n  function(:_isApprovedOrOwner, { spender: :address, id: :uint256 }, :internal, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x8eccc10ad13448c252eb668d51a54723185cbe6bb4a427c0c777250329efb4fc"
      },
      {
        "abi": null,
        "name": "NameRegistryRenderer",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:NameRegistryRenderer, abstract: true) {\n  string(:public, :cardTemplate)\n  event(:StickerCreated, { stickerId: :uint256, name: :string, description: :string, imageURI: :string, stickerExpiry: :uint256, grantingAddress: :address })\n  event(:StickerClaimed, { stickerId: :uint256, claimer: :address })\n  event(:StickerPlaced, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) })\n  event(:StickerRepositioned, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) })\n  event(:CardDetailsSet, { tokenId: :uint256, displayName: :string, bio: :string, imageURI: :string, links: [:string] })\n  mapping(({ uint256: :string }), :public, :cardDisplayNames)\n  mapping(({ uint256: :string }), :public, :cardBios)\n  mapping(({ uint256: :string }), :public, :cardImageURIs)\n  mapping(({ uint256: [:string] }), :public, :cardLinks)\n  uint256(:public, :nextStickerId)\n  mapping(({ uint256: :address }), :public, :stickerIdToSigner)\n  mapping(({ uint256: :string }), :public, :stickerIdToName)\n  mapping(({ uint256: :string }), :public, :stickerIdToDescription)\n  mapping(({ uint256: :string }), :public, :stickerIdToImageURI)\n  mapping(({ uint256: :uint256 }), :public, :stickerIdToExpiry)\n  mapping(({ address: [:uint256] }), :public, :userToStickerAry)\n  mapping(({ address: mapping(uint256: :bool) }), :public, :userToStickerIdsAwardedMap)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerIdsAry)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerXPositionsAry)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerYPositionsAry)\n  mapping(({ uint256: mapping(uint256: :bool) }), :public, :tokenIdToStickerIdsPlacedMap)\n  uint256(:public, :maxStickersPerUser)\n  uint256(:public, :maxStickersPerCard)\n  uint256(:public, :maxLinksPerCard)\n  uint256(:public, :bioMaxLength)\n  uint256(:public, :displayNameMaxLength)\n  uint256(:public, :uriMaxLength)\n  constructor(cardTemplate: :string) {\n    s.maxStickersPerUser=25\n    s.maxStickersPerCard=s.maxStickersPerUser\n    s.maxLinksPerCard=5\n    s.bioMaxLength=1000\n    s.displayNameMaxLength=100\n    s.uriMaxLength=96000\n    require(cardTemplate.length <= s.uriMaxLength, \"cardTemplate too long\")\n    s.cardTemplate=cardTemplate\n  }\n  function(:renderCard, { tokenId: :uint256 }, :public, :view, returns: :string) {\n    enforceNotExpired!(tokenId)\n    owner = ownerOf(tokenId)\n    name = s.tokenIdToName[tokenId]\n    (stickerIds, stickerXPositions, stickerYPositions, stickerImageURIs) = getCardStickers(tokenId)\n    (displayName, bio, imageURI, links) = getCardDetails(tokenId)\n    storage = json.stringify(tokenId: tokenId.toString, owner: owner, name: name, stickerIds: stickerIds, stickerXPositions: stickerXPositions, stickerYPositions: stickerYPositions, stickerImages: stickerImageURIs, displayName: displayName, bio: bio, imageURI: imageURI, links: links)\n    template = \"`#{s.cardTemplate}`\"\n    wrapped = <<-HEREDOC\n<script>\n  window.s = #{storage};\n  document.open();\n  document.write(#{template});\n  document.close();\n</script>\n    HEREDOC\n  }\n  function(:createSticker, { name: :string, description: :string, imageURI: :string, stickerExpiry: :uint256, grantingAddress: :address }, :public) {\n    whenNotPaused!\n    require(name.length > 0, \"Name must be non-empty\")\n    require(name.length <= s.displayNameMaxLength, \"Name too long\")\n    require(description.length <= s.bioMaxLength, \"description too long\")\n    require(imageURI.length <= s.uriMaxLength, \"imageURI too long\")\n    require(grantingAddress != address(0), \"Granting address must be non-zero\")\n    currentId = s.nextStickerId\n    s.nextStickerId += 1\n    s.stickerIdToName[currentId] = name\n    s.stickerIdToImageURI[currentId] = imageURI\n    s.stickerIdToDescription[currentId] = description\n    s.stickerIdToExpiry[currentId] = stickerExpiry\n    s.stickerIdToSigner[currentId] = grantingAddress\n    emit(:StickerCreated, stickerId: currentId, name: name, description: description, imageURI: imageURI, stickerExpiry: stickerExpiry, grantingAddress: grantingAddress)\n  }\n  function(:claimSticker, { stickerId: :uint256, deadline: :uint256, tokenId: :uint256, position: array(:uint256, 2), signature: :bytes }, :public) {\n    whenNotPaused!\n    require(!s.userToStickerIdsAwardedMap[msg.sender][stickerId], \"Sticker already awarded\")\n    require(s.userToStickerAry[msg.sender].length < s.maxStickersPerUser, \"Too many stickers\")\n    require(deadline > block.timestamp, \"Deadline passed\")\n    require(s.stickerIdToExpiry[stickerId] > block.timestamp, \"Sticker expired\")\n    signatureValid = signature.verifyTypedDataSignature({ StickerClaim: [{ name: \"stickerId\", type: \"uint256\" }, { name: \"claimer\", type: \"address\" }, { name: \"deadline\", type: \"uint256\" }] }, { stickerId: stickerId, claimer: msg.sender, deadline: deadline }, verifyingContract: address(this), domainName: s.name, domainVersion: \"1\", signer: s.stickerIdToSigner[stickerId])\n    require(signatureValid, \"Invalid signature\")\n    s.userToStickerIdsAwardedMap[msg.sender][stickerId] = true\n    s.userToStickerAry[msg.sender].push(stickerId)\n    if tokenId != 0\n      placeSticker(stickerId, tokenId, position)\n    end\n    emit(:StickerClaimed, stickerId: stickerId, claimer: msg.sender)\n  }\n  function(:placeSticker, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) }, :public) {\n    whenNotPaused!\n    enforceNotExpired!(tokenId)\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    require(s.userToStickerIdsAwardedMap[msg.sender][stickerId], \"Sticker not claimed\")\n    require(!s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId], \"Sticker already placed\")\n    require(s.tokenIdToStickerIdsAry[tokenId].length < s.maxStickersPerCard, \"Too many stickers\")\n    s.tokenIdToStickerIdsAry[tokenId].push(stickerId)\n    s.tokenIdToStickerXPositionsAry[tokenId].push(position[0])\n    s.tokenIdToStickerYPositionsAry[tokenId].push(position[1])\n    s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId] = true\n    emit(:StickerPlaced, stickerId: stickerId, tokenId: tokenId, position: position)\n  }\n  function(:repositionSticker, { stickerIndex: :uint256, tokenId: :uint256, position: array(:uint256, 2) }, :public) {\n    whenNotPaused!\n    enforceNotExpired!(tokenId)\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    stickerId = s.tokenIdToStickerIdsAry[tokenId][stickerIndex]\n    require(s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId], \"Sticker not placed\")\n    s.tokenIdToStickerXPositionsAry[tokenId][stickerIndex] = position[0]\n    s.tokenIdToStickerYPositionsAry[tokenId][stickerIndex] = position[1]\n    emit(:StickerRepositioned, stickerId: stickerId, tokenId: tokenId, position: position)\n  }\n  function(:setCardDetails, { tokenId: :uint256, displayName: :string, bio: :string, imageURI: :string, links: [:string] }, :public) {\n    whenNotPaused!\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    require(links.length <= s.maxLinksPerCard, \"Too many links\")\n    require(bio.length <= s.bioMaxLength, \"Bio too long\")\n    require(displayName.length <= s.displayNameMaxLength, \"Display name too long\")\n    require(imageURI.length <= s.uriMaxLength, \"imageURI too long\")\n    s.cardDisplayNames[tokenId] = displayName\n    s.cardBios[tokenId] = bio\n    s.cardImageURIs[tokenId] = imageURI\n    s.cardLinks[tokenId] = links\n    emit(:CardDetailsSet, tokenId: tokenId, displayName: displayName, bio: bio, imageURI: imageURI, links: links)\n  }\n  function(:getCardDetails, { tokenId: :uint256 }, :public, :view, returns: { displayName: :string, bio: :string, imageURI: :string, links: [:string] }) {\n    enforceNotExpired!(tokenId)\n    return { displayName: s.cardDisplayNames[tokenId], bio: s.cardBios[tokenId], imageURI: s.cardImageURIs[tokenId], links: s.cardLinks[tokenId] }\n  }\n  function(:getCardStickers, { tokenId: :uint256 }, :public, :view, returns: { stickerIds: [:uint256], stickerXPositions: [:uint256], stickerYPositions: [:uint256], stickerImageURIs: [:string] }) {\n    enforceNotExpired!(tokenId)\n    stickerIds = array(:uint256, 0)\n    stickerXPositions = array(:uint256, 0)\n    stickerYPositions = array(:uint256, 0)\n    stickerImageURIs = array(:string, 0)\n    forLoop(condition: ->(i) {\n      i < s.tokenIdToStickerIdsAry[tokenId].length\n    }) { |i|\n      stickerId = s.tokenIdToStickerIdsAry[tokenId][i]\n      if (s.stickerIdToExpiry[stickerId] > block.timestamp)\n        stickerIds.push(stickerId)\n        stickerXPositions.push(s.tokenIdToStickerXPositionsAry[tokenId][i])\n        stickerYPositions.push(s.tokenIdToStickerYPositionsAry[tokenId][i])\n        stickerImageURIs.push(s.stickerIdToImageURI[stickerId])\n      end\n    }\n    return { stickerIds: stickerIds, stickerXPositions: stickerXPositions, stickerYPositions: stickerYPositions, stickerImageURIs: stickerImageURIs }\n  }\n  function(:updateCardTemplate, { cardTemplate: :string }, :public) {\n    onlyOwner!\n    s.cardTemplate=cardTemplate\n  }\n  function(:_clearCardPersonalInfo, { tokenId: :uint256 }, :internal) {\n    _clearCardDetails(tokenId)\n    _clearStickers(tokenId)\n  }\n  function(:_clearCardDetails, { tokenId: :uint256 }, :internal) {\n    s.cardDisplayNames[tokenId] = \"\"\n    s.cardBios[tokenId] = \"\"\n    s.cardImageURIs[tokenId] = \"\"\n    s.cardLinks[tokenId] = array(:string, 0)\n    nil\n  }\n  function(:_clearStickers, { tokenId: :uint256 }, :internal) {\n    forLoop(condition: ->(i) {\n      i < s.tokenIdToStickerIdsAry[tokenId].length\n    }) { |i|\n      stickerId = s.tokenIdToStickerIdsAry[tokenId][i]\n      s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId] = false\n    }\n    s.tokenIdToStickerIdsAry[tokenId] = array(:uint256, 0)\n    s.tokenIdToStickerXPositionsAry[tokenId] = array(:uint256, 0)\n    s.tokenIdToStickerYPositionsAry[tokenId] = array(:uint256, 0)\n    nil\n  }\n}\n",
        "init_code_hash": "0xd3efd8eb18bae1a79cf6a6619f8214626ac5533f43cbb41cb70ef290feae8b35"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-12T22:04:05.341Z",
    "updated_at": "2024-02-12T22:04:05.341Z"
  },
  {
    "id": 6,
    "transaction_hash": "0xcbff88cc1073c72fd05f3ab524c4560460977121e926178325ee6d38233b767f",
    "internal_transaction_index": 0,
    "block_number": 18684984,
    "transaction_index": 14,
    "name": "FacetSwapV1Factory",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    balance0Adjusted = balance0 * 1000 - amount0In.*(3)\n    balance1Adjusted = balance1 * 1000 - amount1In.*(3)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\ncontract(:FacetSwapV1Factory, is: :Upgradeable, upgradeable: true) {\n  address(:public, :feeTo)\n  address(:public, :feeToSetter)\n  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)\n  array(:address, :public, :allPairs)\n  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })\n  constructor(_feeToSetter: :address) {\n    s.feeToSetter=_feeToSetter\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:allPairsLength, :public, :view, returns: :uint256) {\n    return s.allPairs.length\n  }\n  function(:getAllPairs, :public, :view, returns: [:address]) {\n    return s.allPairs\n  }\n  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {\n    require(tokenA != tokenB, \"FacetSwapV1: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1: ZERO_ADDRESS\")\n    require(s.getPair[token0][token1] == address(0), \"FacetSwapV1: PAIR_EXISTS\")\n    salt = keccak256(abi.encodePacked(token0, token1))\n    pair = new(FacetSwapV1Pair({ salt: salt }))\n    pair.init(token0, token1)\n    s.getPair[token0][token1] = pair\n    s.getPair[token1][token0] = pair\n    s.allPairs.push(pair)\n    emit(:PairCreated, { token0: token0, token1: token1, pair: pair, pairLength: s.allPairs.length })\n    return pair\n  }\n  function(:setFeeTo, { _feeTo: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeTo=_feeTo\n    return nil\n  }\n  function(:setFeeToSetter, { _feeToSetter: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeToSetter=_feeToSetter\n    return nil\n  }\n}\n",
    "init_code_hash": "0xe612bffc64f08ac3416358610ad9c442bd4eb506447f125b7e71b64e33583e7f",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Callee",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\n",
        "init_code_hash": "0xdfc5450f8af1e8b6650f7780eb3442d9ab9c26b049b838234d0372ebccc99403"
      },
      {
        "abi": null,
        "name": "FacetSwapV1ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\n",
        "init_code_hash": "0xc9eab797e3d8ce82dafb41448daaa1ca53b2364ff91223d6514fd6355884b5c4"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Factory",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\n",
        "init_code_hash": "0x4359c69df41322e55a56dac42cbbd1c9e63009916b6997a1234d5ac003baa983"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Pair",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    balance0Adjusted = balance0 * 1000 - amount0In.*(3)\n    balance1Adjusted = balance1 * 1000 - amount1In.*(3)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\n",
        "init_code_hash": "0xd1e3aeacc4eff0b09cefe93f283fc37c0fb170a75b8f22ce65d0f0a4b46022b2"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-12T22:05:37.249Z",
    "updated_at": "2024-02-12T22:05:37.249Z"
  },
  {
    "id": 7,
    "transaction_hash": "0xc7d16efa100591a84bba7fb5925d4c57d80629de47a47ce2e298a588afbbf110",
    "internal_transaction_index": 0,
    "block_number": 18684991,
    "transaction_index": 324,
    "name": "FacetSwapV1Router",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    balance0Adjusted = balance0 * 1000 - amount0In.*(3)\n    balance1Adjusted = balance1 * 1000 - amount1In.*(3)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\ncontract(:FacetSwapV1Factory, is: :Upgradeable, upgradeable: true) {\n  address(:public, :feeTo)\n  address(:public, :feeToSetter)\n  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)\n  array(:address, :public, :allPairs)\n  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })\n  constructor(_feeToSetter: :address) {\n    s.feeToSetter=_feeToSetter\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:allPairsLength, :public, :view, returns: :uint256) {\n    return s.allPairs.length\n  }\n  function(:getAllPairs, :public, :view, returns: [:address]) {\n    return s.allPairs\n  }\n  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {\n    require(tokenA != tokenB, \"FacetSwapV1: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1: ZERO_ADDRESS\")\n    require(s.getPair[token0][token1] == address(0), \"FacetSwapV1: PAIR_EXISTS\")\n    salt = keccak256(abi.encodePacked(token0, token1))\n    pair = new(FacetSwapV1Pair({ salt: salt }))\n    pair.init(token0, token1)\n    s.getPair[token0][token1] = pair\n    s.getPair[token1][token0] = pair\n    s.allPairs.push(pair)\n    emit(:PairCreated, { token0: token0, token1: token1, pair: pair, pairLength: s.allPairs.length })\n    return pair\n  }\n  function(:setFeeTo, { _feeTo: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeTo=_feeTo\n    return nil\n  }\n  function(:setFeeToSetter, { _feeToSetter: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeToSetter=_feeToSetter\n    return nil\n  }\n}\ncontract(:FacetSwapV1Router, is: :Upgradeable, upgradeable: true) {\n  address(:public, :factory)\n  address(:public, :WETH)\n  uint8(:public, :maxPathLength)\n  constructor(_factory: :address, _WETH: :address) {\n    s.factory=_factory\n    s.WETH=_WETH\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.maxPathLength=3\n  }\n  function(:_addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256 }, :internal, :virtual, returns: { amountA: :uint256, amountB: :uint256 }) {\n    if FacetSwapV1Factory(factory).getPair(tokenA, tokenB) == address(0)\n      FacetSwapV1Factory(factory).createPair(tokenA, tokenB)\n    end\n    (reserveA, reserveB) = getReserves(s.factory, tokenA, tokenB)\n    if reserveA == 0 && reserveB == 0\n      return { amountA: amountADesired, amountB: amountBDesired }\n    else\n      amountBOptimal = quote(amountADesired, reserveA, reserveB)\n      if amountBOptimal <= amountBDesired\n        require(amountBOptimal >= amountBMin, \"FacetSwapV1Router: INSUFFICIENT_B_AMOUNT\")\n        return { amountA: amountADesired, amountB: amountBOptimal }\n      else\n        amountAOptimal = quote(amountBDesired, reserveB, reserveA)\n        require(amountAOptimal <= amountADesired, \"ASSERT\")\n        require(amountAOptimal >= amountAMin, \"FacetSwapV1Router: INSUFFICIENT_A_AMOUNT\")\n        return { amountA: amountAOptimal, amountB: amountBDesired }\n      end\n    end\n  }\n  function(:addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, :virtual, returns: { amountA: :uint256, amountB: :uint256, liquidity: :uint256 }) {\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin)\n    pair = pairFor(s.factory, tokenA, tokenB)\n    _safeTransferFrom(token: tokenA, from: msg.sender, to: pair, value: amountA)\n    _safeTransferFrom(token: tokenB, from: msg.sender, to: pair, value: amountB)\n    liquidity = FacetSwapV1Pair(pair).mint(to: to)\n    return { amountA: amountA, amountB: amountB, liquidity: liquidity }\n  }\n  function(:removeLiquidity, { tokenA: :address, tokenB: :address, liquidity: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, :virtual, returns: { amountA: :uint256, amountB: :uint256 }) {\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    pair = pairFor(s.factory, tokenA, tokenB)\n    FacetSwapV1Pair(pair).transferFrom(msg.sender, pair, liquidity)\n    (amount0, amount1) = FacetSwapV1Pair(pair).burn(to)\n    (token0, _) = sortTokens(tokenA, tokenB)\n    (amountA, amountB) = if tokenA == token0\n      [amount0, amount1]\n    else\n      [amount1, amount0]\n    end\n    require(amountA >= amountAMin, \"FacetSwapV1Router: INSUFFICIENT_A_AMOUNT\")\n    require(amountB >= amountBMin, \"FacetSwapV1Router: INSUFFICIENT_B_AMOUNT\")\n    return { amountA: amountA, amountB: amountB }\n  }\n  function(:swapExactTokensForTokens, { amountIn: :uint256, amountOutMin: :uint256, path: [:address], to: :address, deadline: :uint256 }, :public, :virtual, returns: [:uint256]) {\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    amounts = getAmountsOut(factory, amountIn, path)\n    require(amounts[amounts.length - 1] >= amountOutMin, \"FacetSwapV1Router: INSUFFICIENT_OUTPUT_AMOUNT\")\n    _safeTransferFrom(path[0], msg.sender, pairFor(factory, path[0], path[1]), amounts[0])\n    _swap(amounts, path, to)\n    return amounts\n  }\n  function(:swapTokensForExactTokens, { amountOut: :uint256, amountInMax: :uint256, path: [:address], to: :address, deadline: :uint256 }, :public, :virtual, returns: [:uint256]) {\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    amounts = getAmountsIn(factory, amountOut, path)\n    require(amounts[0] <= amountInMax, \"FacetSwapV1Router: EXCESSIVE_INPUT_AMOUNT\")\n    _safeTransferFrom(path[0], msg.sender, pairFor(factory, path[0], path[1]), amounts[0])\n    _swap(amounts, path, to)\n    return amounts\n  }\n  function(:_swap, { amounts: [:uint256], path: [:address], _to: :address }, :internal, :virtual) {\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    forLoop(condition: ->(i) {\n      i < path.length.-(1)\n    }) { |i|\n      (input, output) = [path[i], path[i + 1]]\n      (token0, _) = sortTokens(input, output)\n      amountOut = amounts[i + 1]\n      (amount0Out, amount1Out) = if input == token0\n        [0, amountOut]\n      else\n        [amountOut, 0]\n      end\n      to = if i < path.length.-(2)\n        pairFor(factory, output, path[i + 2])\n      else\n        _to\n      end\n      FacetSwapV1Pair(pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, \"\")\n    }\n  }\n  function(:_safeTransferFrom, { token: :address, from: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transferFrom(from: from, to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  function(:getAmountsOut, { factory: :address, amountIn: :uint256, path: [:address] }, :public, :view, returns: [:uint256]) {\n    require(path.length >= 2, \"FacetSwapV1Library: INVALID_PATH\")\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    amounts = array(:uint256, path.length)\n    amounts[0] = amountIn\n    forLoop(condition: ->(i) {\n      i < path.length.-(1)\n    }) { |i|\n      (reserveIn, reserveOut) = getReserves(factory, path[i], path[i + 1])\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut)\n    }\n    return amounts\n  }\n  function(:getAmountOut, { amountIn: :uint256, reserveIn: :uint256, reserveOut: :uint256 }, :public, :view, returns: :uint256) {\n    require(amountIn > 0, \"FacetSwapV1Library: INSUFFICIENT_INPUT_AMOUNT\")\n    require(reserveIn > 0 && reserveOut > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    amountInWithFee = amountIn * 997\n    numerator = amountInWithFee * reserveOut\n    denominator = reserveIn * 1000 + amountInWithFee\n    amountOut = numerator.div(denominator)\n    return amountOut\n  }\n  function(:getAmountsIn, { factory: :address, amountOut: :uint256, path: [:address] }, :public, :view, returns: [:uint256]) {\n    require(path.length >= 2, \"FacetSwapV1Library: INVALID_PATH\")\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    amounts = array(:uint256, path.length)\n    amounts[amounts.length - 1] = amountOut\n    forLoop(start: path.length - 1, condition: ->(i) {\n      i > 0\n    }, step: -1) { |i|\n      (reserveIn, reserveOut) = getReserves(factory, path[i - 1], path[i])\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut)\n    }\n    return amounts\n  }\n  function(:getAmountIn, { amountOut: :uint256, reserveIn: :uint256, reserveOut: :uint256 }, :public, :view, returns: :uint256) {\n    require(amountOut > 0, \"FacetSwapV1Library: INSUFFICIENT_OUTPUT_AMOUNT\")\n    require(reserveIn > 0 && reserveOut > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    numerator = reserveIn * amountOut * 1000\n    denominator = (reserveOut - amountOut) * 997\n    amountIn = (numerator.div(denominator)) + 1\n    return amountIn\n  }\n  function(:quote, { amountA: :uint256, reserveA: :uint256, reserveB: :uint256 }, :public, :pure, returns: :uint256) {\n    require(amountA > 0, \"FacetSwapV1Library: INSUFFICIENT_AMOUNT\")\n    require(reserveA > 0 && reserveB > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    return (amountA * reserveB).div(reserveA)\n  }\n  function(:getReserves, { factory: :address, tokenA: :address, tokenB: :address }, :public, :view, returns: { reserveA: :uint256, reserveB: :uint256 }) {\n    (token0, _) = sortTokens(tokenA, tokenB)\n    (reserve0, reserve1, _) = FacetSwapV1Pair(pairFor(factory, tokenA, tokenB)).getReserves\n    (reserveA, reserveB) = if tokenA == token0\n      [reserve0, reserve1]\n    else\n      [reserve1, reserve0]\n    end\n    return { reserveA: reserveA, reserveB: reserveB }\n  }\n  function(:pairFor, { factory: :address, tokenA: :address, tokenB: :address }, :internal, :pure, returns: :address) {\n    (token0, token1) = sortTokens(tokenA, tokenB)\n    return create2_address(salt: keccak256(abi.encodePacked(token0, token1)), deployer: factory, contract_type: \"FacetSwapV1Pair\")\n  }\n  function(:sortTokens, { tokenA: :address, tokenB: :address }, :internal, :pure, returns: { token0: :address, token1: :address }) {\n    require(tokenA != tokenB, \"FacetSwapV1Library: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1Library: ZERO_ADDRESS\")\n    return { token0: token0, token1: token1 }\n  }\n  function(:userStats, { user: :address, tokenA: :address, tokenB: :address }, :public, :view, returns: { userTokenABalance: :uint256, userTokenBBalance: :uint256, tokenAName: :string, tokenBName: :string, tokenAReserves: :uint256, tokenBReserves: :uint256, userLPBalance: :uint256, pairAddress: :address }) {\n    tokenAReserves = 0\n    tokenBReserves = 0\n    userLPBalance = 0\n    if FacetSwapV1Factory(s.factory).getPair(tokenA, tokenB) != address(0)\n      (tokenAReserves, tokenBReserves) = getReserves(s.factory, tokenA, tokenB)\n      pair = FacetSwapV1Factory(s.factory).getPair(tokenA, tokenB)\n      userLPBalance = FacetSwapV1ERC20(pair).balanceOf(user)\n    end\n    return { userTokenABalance: ERC20(tokenA).balanceOf(user), userTokenBBalance: ERC20(tokenB).balanceOf(user), tokenAName: ERC20(tokenA).name, tokenBName: ERC20(tokenB).name, tokenAReserves: tokenAReserves, tokenBReserves: tokenBReserves, userLPBalance: userLPBalance, pairAddress: pair }\n  }\n}\n",
    "init_code_hash": "0x2bd16342b7b7516e2ac7b5d31f157ea244a08dd78c14ba8faa7280559232b099",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Callee",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\n",
        "init_code_hash": "0xdfc5450f8af1e8b6650f7780eb3442d9ab9c26b049b838234d0372ebccc99403"
      },
      {
        "abi": null,
        "name": "FacetSwapV1ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\n",
        "init_code_hash": "0xc9eab797e3d8ce82dafb41448daaa1ca53b2364ff91223d6514fd6355884b5c4"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Factory",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\n",
        "init_code_hash": "0x4359c69df41322e55a56dac42cbbd1c9e63009916b6997a1234d5ac003baa983"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Pair",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    balance0Adjusted = balance0 * 1000 - amount0In.*(3)\n    balance1Adjusted = balance1 * 1000 - amount1In.*(3)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\n",
        "init_code_hash": "0xd1e3aeacc4eff0b09cefe93f283fc37c0fb170a75b8f22ce65d0f0a4b46022b2"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Factory",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    balance0Adjusted = balance0 * 1000 - amount0In.*(3)\n    balance1Adjusted = balance1 * 1000 - amount1In.*(3)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\ncontract(:FacetSwapV1Factory, is: :Upgradeable, upgradeable: true) {\n  address(:public, :feeTo)\n  address(:public, :feeToSetter)\n  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)\n  array(:address, :public, :allPairs)\n  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })\n  constructor(_feeToSetter: :address) {\n    s.feeToSetter=_feeToSetter\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:allPairsLength, :public, :view, returns: :uint256) {\n    return s.allPairs.length\n  }\n  function(:getAllPairs, :public, :view, returns: [:address]) {\n    return s.allPairs\n  }\n  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {\n    require(tokenA != tokenB, \"FacetSwapV1: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1: ZERO_ADDRESS\")\n    require(s.getPair[token0][token1] == address(0), \"FacetSwapV1: PAIR_EXISTS\")\n    salt = keccak256(abi.encodePacked(token0, token1))\n    pair = new(FacetSwapV1Pair({ salt: salt }))\n    pair.init(token0, token1)\n    s.getPair[token0][token1] = pair\n    s.getPair[token1][token0] = pair\n    s.allPairs.push(pair)\n    emit(:PairCreated, { token0: token0, token1: token1, pair: pair, pairLength: s.allPairs.length })\n    return pair\n  }\n  function(:setFeeTo, { _feeTo: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeTo=_feeTo\n    return nil\n  }\n  function(:setFeeToSetter, { _feeToSetter: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeToSetter=_feeToSetter\n    return nil\n  }\n}\n",
        "init_code_hash": "0xe612bffc64f08ac3416358610ad9c442bd4eb506447f125b7e71b64e33583e7f"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-12T22:05:43.595Z",
    "updated_at": "2024-02-12T22:05:43.595Z"
  },
  {
    "id": 8,
    "transaction_hash": "0x078429d640b5870eec7f4b81ca4e2c5b507114b3cbd0f9a099f012f62bfb45db",
    "internal_transaction_index": 3,
    "block_number": 18687313,
    "transaction_index": 113,
    "name": "FacetSwapV1Pair",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    balance0Adjusted = balance0 * 1000 - amount0In.*(3)\n    balance1Adjusted = balance1 * 1000 - amount1In.*(3)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\n",
    "init_code_hash": "0xd1e3aeacc4eff0b09cefe93f283fc37c0fb170a75b8f22ce65d0f0a4b46022b2",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Callee",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\n",
        "init_code_hash": "0xdfc5450f8af1e8b6650f7780eb3442d9ab9c26b049b838234d0372ebccc99403"
      },
      {
        "abi": null,
        "name": "FacetSwapV1ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\n",
        "init_code_hash": "0xc9eab797e3d8ce82dafb41448daaa1ca53b2364ff91223d6514fd6355884b5c4"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Factory",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n}\n",
        "init_code_hash": "0x4359c69df41322e55a56dac42cbbd1c9e63009916b6997a1234d5ac003baa983"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-12T22:09:28.311Z",
    "updated_at": "2024-02-12T22:09:28.311Z"
  },
  {
    "id": 9,
    "transaction_hash": "0x4c052212d73b71a313beea49958cc77e7cd2be6123f590f7b2b42107dd29b812",
    "internal_transaction_index": 0,
    "block_number": 18778559,
    "transaction_index": 97,
    "name": "FacetSwapV1Router02",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\ncontract(:FacetSwapV1Factory02, is: :Upgradeable, upgradeable: true) {\n  address(:public, :feeTo)\n  address(:public, :feeToSetter)\n  uint256(:public, :lpFeeBPS)\n  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)\n  array(:address, :public, :allPairs)\n  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })\n  constructor(_feeToSetter: :address) {\n    s.feeToSetter=_feeToSetter\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:setLpFeeBPS, { lpFeeBPS: :uint256 }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    require(lpFeeBPS <= 10000, \"Fees cannot exceed 100%\")\n    s.lpFeeBPS=lpFeeBPS\n    return nil\n  }\n  function(:allPairsLength, :public, :view, returns: :uint256) {\n    return s.allPairs.length\n  }\n  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {\n    require(tokenA != tokenB, \"FacetSwapV1: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1: ZERO_ADDRESS\")\n    require(s.getPair[token0][token1] == address(0), \"FacetSwapV1: PAIR_EXISTS\")\n    salt = keccak256(abi.encodePacked(token0, token1))\n    pair = new(FacetSwapV1Pair02({ salt: salt }))\n    pair.init(token0, token1)\n    s.getPair[token0][token1] = pair\n    s.getPair[token1][token0] = pair\n    s.allPairs.push(pair)\n    emit(:PairCreated, { token0: token0, token1: token1, pair: pair, pairLength: s.allPairs.length })\n    return pair\n  }\n  function(:setFeeTo, { _feeTo: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeTo=_feeTo\n    return nil\n  }\n  function(:setFeeToSetter, { _feeToSetter: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeToSetter=_feeToSetter\n    return nil\n  }\n  function(:upgradePairs, { pairs: [:address], newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    require(pairs.length <= 10, \"Too many pairs to upgrade at once\")\n    forLoop(condition: ->(i) {\n      i < pairs.length\n    }) { |i|\n      pair = pairs[i]\n      sourceToUse = if i == 0\n        newSource\n      else\n        \"\"\n      end\n      upgradePair(pair: pair, newHash: newHash, newSource: sourceToUse)\n    }\n  }\n  function(:upgradePair, { pair: :address, newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    Upgradeable(pair).upgrade(newHash: newHash, newSource: newSource)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:FacetSwapV1Router02, is: [:Ownable, :Upgradeable, :Pausable], upgradeable: true) {\n  address(:public, :factory)\n  address(:public, :WETH)\n  uint8(:public, :maxPathLength)\n  uint256(:public, :protocolFeeBPS)\n  event(:FeeAdjustedSwap, { inputToken: :address, outputToken: :address, inputAmount: :uint256, outputAmount: :uint256, feeAmount: :uint256, to: :address })\n  constructor(_factory: :address, _WETH: :address, protocolFeeBPS: :uint256, initialPauseState: :bool) {\n    s.factory=_factory\n    s.WETH=_WETH\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: msg.sender)\n    updateProtocolFee(protocolFeeBPS: protocolFeeBPS)\n    self.Pausable.constructor(initialPauseState: initialPauseState)\n    s.maxPathLength=3\n  }\n  function(:onUpgrade, { owner: :address, initialPauseState: :bool }, :public) {\n    require(msg.sender == address(this), \"Only the contract itself can upgrade\")\n    s.owner=owner\n    if initialPauseState\n      _pause\n    else\n      _unpause\n    end\n  }\n  function(:_addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256 }, :internal, :virtual, returns: { amountA: :uint256, amountB: :uint256 }) {\n    if FacetSwapV1Factory02(factory).getPair(tokenA, tokenB) == address(0)\n      FacetSwapV1Factory02(factory).createPair(tokenA, tokenB)\n    end\n    (reserveA, reserveB) = getReserves(s.factory, tokenA, tokenB)\n    if reserveA == 0 && reserveB == 0\n      return { amountA: amountADesired, amountB: amountBDesired }\n    else\n      amountBOptimal = quote(amountADesired, reserveA, reserveB)\n      if amountBOptimal <= amountBDesired\n        require(amountBOptimal >= amountBMin, \"FacetSwapV1Router: INSUFFICIENT_B_AMOUNT\")\n        return { amountA: amountADesired, amountB: amountBOptimal }\n      else\n        amountAOptimal = quote(amountBDesired, reserveB, reserveA)\n        require(amountAOptimal <= amountADesired, \"ASSERT\")\n        require(amountAOptimal >= amountAMin, \"FacetSwapV1Router: INSUFFICIENT_A_AMOUNT\")\n        return { amountA: amountAOptimal, amountB: amountBDesired }\n      end\n    end\n  }\n  function(:addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, :virtual, returns: { amountA: :uint256, amountB: :uint256, liquidity: :uint256 }) {\n    whenNotPaused!\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin)\n    pair = pairFor(s.factory, tokenA, tokenB)\n    _safeTransferFrom(token: tokenA, from: msg.sender, to: pair, value: amountA)\n    _safeTransferFrom(token: tokenB, from: msg.sender, to: pair, value: amountB)\n    liquidity = FacetSwapV1Pair02(pair).mint(to: to)\n    return { amountA: amountA, amountB: amountB, liquidity: liquidity }\n  }\n  function(:removeLiquidity, { tokenA: :address, tokenB: :address, liquidity: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, :virtual, returns: { amountA: :uint256, amountB: :uint256 }) {\n    whenNotPaused!\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    pair = pairFor(s.factory, tokenA, tokenB)\n    FacetSwapV1Pair02(pair).transferFrom(msg.sender, pair, liquidity)\n    (amount0, amount1) = FacetSwapV1Pair02(pair).burn(to)\n    (token0, _) = sortTokens(tokenA, tokenB)\n    (amountA, amountB) = if tokenA == token0\n      [amount0, amount1]\n    else\n      [amount1, amount0]\n    end\n    require(amountA >= amountAMin, \"FacetSwapV1Router: INSUFFICIENT_A_AMOUNT\")\n    require(amountB >= amountBMin, \"FacetSwapV1Router: INSUFFICIENT_B_AMOUNT\")\n    return { amountA: amountA, amountB: amountB }\n  }\n  function(:swapExactTokensForTokens, { amountIn: :uint256, amountOutMin: :uint256, path: [:address], to: :address, deadline: :uint256 }, :public, :virtual, returns: [:uint256]) {\n    whenNotPaused!\n    require(path[0] == s.WETH || path[path.length - 1] == s.WETH, \"Must have WETH as either the first or last token in the path\")\n    amountInWithFee = if path[0] == s.WETH\n      amountIn - calculateFeeAmount(amountIn)\n    else\n      amountIn\n    end\n    amounts = _swapExactTokensForTokens(amountIn: amountInWithFee, amountOutMin: amountOutMin, path: path, to: to, deadline: deadline)\n    amountToChargeFeeOn = if path[0] == s.WETH\n      amountIn\n    else\n      amounts[amounts.length - 1]\n    end\n    feeAmount = calculateFeeAmount(amountToChargeFeeOn)\n    chargeWethFee(feeAmount)\n    if path[0] == s.WETH\n      amounts[0] = amountIn\n    else\n      amounts[amounts.length - 1] -= feeAmount\n    end\n    emit(:FeeAdjustedSwap, inputToken: path[0], outputToken: path[path.length - 1], inputAmount: amounts[0], outputAmount: amounts[amounts.length - 1], feeAmount: feeAmount, to: to)\n    amounts\n  }\n  function(:_swapExactTokensForTokens, { amountIn: :uint256, amountOutMin: :uint256, path: [:address], to: :address, deadline: :uint256 }, :internal, :virtual, returns: [:uint256]) {\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    amounts = getAmountsOut(factory, amountIn, path)\n    require(amounts[amounts.length - 1] >= amountOutMin, \"FacetSwapV1Router: INSUFFICIENT_OUTPUT_AMOUNT\")\n    _safeTransferFrom(path[0], msg.sender, pairFor(factory, path[0], path[1]), amounts[0])\n    _swap(amounts, path, to)\n    return amounts\n  }\n  function(:swapTokensForExactTokens, { amountOut: :uint256, amountInMax: :uint256, path: [:address], to: :address, deadline: :uint256 }, :public, :virtual, returns: [:uint256]) {\n    whenNotPaused!\n    require(path[0] == s.WETH || path[path.length - 1] == s.WETH, \"Must have WETH as either the first or last token in the path\")\n    amountOutWithFee = if path[path.length - 1] == s.WETH\n      amountOut + calculateFeeAmount(amountOut)\n    else\n      amountOut\n    end\n    amounts = _swapTokensForExactTokens(amountOut: amountOutWithFee, amountInMax: amountInMax, path: path, to: to, deadline: deadline)\n    amountToChargeFeeOn = if path[0] == s.WETH\n      amounts[0]\n    else\n      amountOut\n    end\n    feeAmount = calculateFeeAmount(amountToChargeFeeOn)\n    chargeWethFee(feeAmount)\n    if path[0] == s.WETH\n      amounts[0] += feeAmount\n    else\n      amounts[amounts.length - 1] = amountOut\n    end\n    emit(:FeeAdjustedSwap, inputToken: path[0], outputToken: path[path.length - 1], inputAmount: amounts[0], outputAmount: amounts[amounts.length - 1], feeAmount: feeAmount, to: to)\n    amounts\n  }\n  function(:_swapTokensForExactTokens, { amountOut: :uint256, amountInMax: :uint256, path: [:address], to: :address, deadline: :uint256 }, :internal, :virtual, returns: [:uint256]) {\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    amounts = getAmountsIn(factory, amountOut, path)\n    require(amounts[0] <= amountInMax, \"FacetSwapV1Router: EXCESSIVE_INPUT_AMOUNT\")\n    _safeTransferFrom(path[0], msg.sender, pairFor(factory, path[0], path[1]), amounts[0])\n    _swap(amounts, path, to)\n    return amounts\n  }\n  function(:_swap, { amounts: [:uint256], path: [:address], _to: :address }, :internal, :virtual) {\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    forLoop(condition: ->(i) {\n      i < path.length.-(1)\n    }) { |i|\n      (input, output) = [path[i], path[i + 1]]\n      (token0, _) = sortTokens(input, output)\n      amountOut = amounts[i + 1]\n      (amount0Out, amount1Out) = if input == token0\n        [0, amountOut]\n      else\n        [amountOut, 0]\n      end\n      to = if i < path.length.-(2)\n        pairFor(factory, output, path[i + 2])\n      else\n        _to\n      end\n      FacetSwapV1Pair02(pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, \"\")\n    }\n  }\n  function(:_safeTransferFrom, { token: :address, from: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transferFrom(from: from, to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  function(:getAmountsOut, { factory: :address, amountIn: :uint256, path: [:address] }, :public, :view, returns: [:uint256]) {\n    require(path.length >= 2, \"FacetSwapV1Library: INVALID_PATH\")\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    amounts = array(:uint256, path.length)\n    amounts[0] = amountIn\n    forLoop(condition: ->(i) {\n      i < path.length.-(1)\n    }) { |i|\n      (reserveIn, reserveOut) = getReserves(factory, path[i], path[i + 1])\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut)\n    }\n    return amounts\n  }\n  function(:getAmountOut, { amountIn: :uint256, reserveIn: :uint256, reserveOut: :uint256 }, :public, :view, returns: :uint256) {\n    require(amountIn > 0, \"FacetSwapV1Library: INSUFFICIENT_INPUT_AMOUNT\")\n    require(reserveIn > 0 && reserveOut > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    lpFeeBPS = FacetSwapV1Factory02(s.factory).lpFeeBPS\n    totalFeeFactor = 1000 - lpFeeBPS.div(10)\n    amountInWithFee = amountIn * totalFeeFactor\n    numerator = amountInWithFee * reserveOut\n    denominator = reserveIn * 1000 + amountInWithFee\n    amountOut = numerator.div(denominator)\n    return amountOut\n  }\n  function(:getAmountsIn, { factory: :address, amountOut: :uint256, path: [:address] }, :public, :view, returns: [:uint256]) {\n    require(path.length >= 2, \"FacetSwapV1Library: INVALID_PATH\")\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    amounts = array(:uint256, path.length)\n    amounts[amounts.length - 1] = amountOut\n    forLoop(start: path.length - 1, condition: ->(i) {\n      i > 0\n    }, step: -1) { |i|\n      (reserveIn, reserveOut) = getReserves(factory, path[i - 1], path[i])\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut)\n    }\n    return amounts\n  }\n  function(:getAmountIn, { amountOut: :uint256, reserveIn: :uint256, reserveOut: :uint256 }, :public, :view, returns: :uint256) {\n    require(amountOut > 0, \"FacetSwapV1Library: INSUFFICIENT_OUTPUT_AMOUNT\")\n    require(reserveIn > 0 && reserveOut > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    lpFeeBPS = FacetSwapV1Factory02(s.factory).lpFeeBPS\n    totalFeeFactor = 1000 - lpFeeBPS.div(10)\n    numerator = reserveIn * amountOut * 1000\n    denominator = (reserveOut - amountOut) * totalFeeFactor\n    amountIn = (numerator.div(denominator)) + 1\n    return amountIn\n  }\n  function(:quote, { amountA: :uint256, reserveA: :uint256, reserveB: :uint256 }, :public, :pure, returns: :uint256) {\n    require(amountA > 0, \"FacetSwapV1Library: INSUFFICIENT_AMOUNT\")\n    require(reserveA > 0 && reserveB > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    return (amountA * reserveB).div(reserveA)\n  }\n  function(:getReserves, { factory: :address, tokenA: :address, tokenB: :address }, :public, :view, returns: { reserveA: :uint256, reserveB: :uint256 }) {\n    (token0, _) = sortTokens(tokenA, tokenB)\n    (reserve0, reserve1, _) = FacetSwapV1Pair02(pairFor(factory, tokenA, tokenB)).getReserves\n    (reserveA, reserveB) = if tokenA == token0\n      [reserve0, reserve1]\n    else\n      [reserve1, reserve0]\n    end\n    return { reserveA: reserveA, reserveB: reserveB }\n  }\n  function(:pairFor, { factory: :address, tokenA: :address, tokenB: :address }, :internal, :view, returns: :address) {\n    return FacetSwapV1Factory02(s.factory).getPair(tokenA, tokenB)\n  }\n  function(:sortTokens, { tokenA: :address, tokenB: :address }, :internal, :pure, returns: { token0: :address, token1: :address }) {\n    require(tokenA != tokenB, \"FacetSwapV1Library: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1Library: ZERO_ADDRESS\")\n    return { token0: token0, token1: token1 }\n  }\n  function(:chargeWethFee, { feeAmount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.WETH).transferFrom(from: msg.sender, to: address(this), amount: feeAmount)\n  }\n  function(:calculateFeeAmount, { amount: :uint256 }, :public, :view, returns: :uint256) {\n    return (amount * s.protocolFeeBPS).div(10000)\n  }\n  function(:updateProtocolFee, { protocolFeeBPS: :uint256 }, :public) {\n    onlyOwner!\n    require(protocolFeeBPS <= 10000, \"Fee cannot be greater than 100%\")\n    s.protocolFeeBPS=protocolFeeBPS\n    nil\n  }\n  function(:withdrawFees, { to: :address }, :public, returns: :bool) {\n    onlyOwner!\n    ERC20(s.WETH).transfer(to: to, amount: ERC20(s.WETH).balanceOf(address(this)))\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:userStats, { user: :address, tokenA: :address, tokenB: :address }, :public, :view, returns: { userTokenABalance: :uint256, userTokenBBalance: :uint256, tokenAName: :string, tokenBName: :string, tokenAReserves: :uint256, tokenBReserves: :uint256, userLPBalance: :uint256, pairAddress: :address }) {\n    tokenAReserves = 0\n    tokenBReserves = 0\n    userLPBalance = 0\n    if FacetSwapV1Factory02(s.factory).getPair(tokenA, tokenB) != address(0)\n      (tokenAReserves, tokenBReserves) = getReserves(s.factory, tokenA, tokenB)\n      pair = FacetSwapV1Factory02(s.factory).getPair(tokenA, tokenB)\n      userLPBalance = FacetSwapV1ERC20(pair).balanceOf(user)\n    end\n    return { userTokenABalance: ERC20(tokenA).balanceOf(user), userTokenBBalance: ERC20(tokenB).balanceOf(user), tokenAName: ERC20(tokenA).name, tokenBName: ERC20(tokenB).name, tokenAReserves: tokenAReserves, tokenBReserves: tokenBReserves, userLPBalance: userLPBalance, pairAddress: pair }\n  }\n}\n",
    "init_code_hash": "0xd50cc748c252c19f61cda32cac8855e1888892d5b16ee635df1ecd19d13edaf8",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Callee",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\n",
        "init_code_hash": "0xdfc5450f8af1e8b6650f7780eb3442d9ab9c26b049b838234d0372ebccc99403"
      },
      {
        "abi": null,
        "name": "FacetSwapV1ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\n",
        "init_code_hash": "0xc9eab797e3d8ce82dafb41448daaa1ca53b2364ff91223d6514fd6355884b5c4"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Factory02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\n",
        "init_code_hash": "0x36f033539c292372626be7ee16c1561d2166935c230d1df3a8424625969e2253"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Pair02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\n",
        "init_code_hash": "0x2dce6b589dd5a5bedc5d9a91806a6cc5f16ae52c0f8dae730a886d7212db2dfd"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Factory02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\ncontract(:FacetSwapV1Factory02, is: :Upgradeable, upgradeable: true) {\n  address(:public, :feeTo)\n  address(:public, :feeToSetter)\n  uint256(:public, :lpFeeBPS)\n  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)\n  array(:address, :public, :allPairs)\n  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })\n  constructor(_feeToSetter: :address) {\n    s.feeToSetter=_feeToSetter\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:setLpFeeBPS, { lpFeeBPS: :uint256 }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    require(lpFeeBPS <= 10000, \"Fees cannot exceed 100%\")\n    s.lpFeeBPS=lpFeeBPS\n    return nil\n  }\n  function(:allPairsLength, :public, :view, returns: :uint256) {\n    return s.allPairs.length\n  }\n  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {\n    require(tokenA != tokenB, \"FacetSwapV1: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1: ZERO_ADDRESS\")\n    require(s.getPair[token0][token1] == address(0), \"FacetSwapV1: PAIR_EXISTS\")\n    salt = keccak256(abi.encodePacked(token0, token1))\n    pair = new(FacetSwapV1Pair02({ salt: salt }))\n    pair.init(token0, token1)\n    s.getPair[token0][token1] = pair\n    s.getPair[token1][token0] = pair\n    s.allPairs.push(pair)\n    emit(:PairCreated, { token0: token0, token1: token1, pair: pair, pairLength: s.allPairs.length })\n    return pair\n  }\n  function(:setFeeTo, { _feeTo: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeTo=_feeTo\n    return nil\n  }\n  function(:setFeeToSetter, { _feeToSetter: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeToSetter=_feeToSetter\n    return nil\n  }\n  function(:upgradePairs, { pairs: [:address], newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    require(pairs.length <= 10, \"Too many pairs to upgrade at once\")\n    forLoop(condition: ->(i) {\n      i < pairs.length\n    }) { |i|\n      pair = pairs[i]\n      sourceToUse = if i == 0\n        newSource\n      else\n        \"\"\n      end\n      upgradePair(pair: pair, newHash: newHash, newSource: sourceToUse)\n    }\n  }\n  function(:upgradePair, { pair: :address, newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    Upgradeable(pair).upgrade(newHash: newHash, newSource: newSource)\n  }\n}\n",
        "init_code_hash": "0x958b66f80d8d14e5c2129434bb8c78aabb60b5cfb7113224102e1a9a07c77ac5"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T02:00:03.583Z",
    "updated_at": "2024-02-13T02:00:03.583Z"
  },
  {
    "id": 10,
    "transaction_hash": "0x96ad3c33d399b743b3df261baca4c1f889f0518c1196a4fb86c20f04f2bcdf98",
    "internal_transaction_index": 0,
    "block_number": 18778571,
    "transaction_index": 98,
    "name": "FacetSwapV1Factory02",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\ncontract(:FacetSwapV1Factory02, is: :Upgradeable, upgradeable: true) {\n  address(:public, :feeTo)\n  address(:public, :feeToSetter)\n  uint256(:public, :lpFeeBPS)\n  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)\n  array(:address, :public, :allPairs)\n  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })\n  constructor(_feeToSetter: :address) {\n    s.feeToSetter=_feeToSetter\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:setLpFeeBPS, { lpFeeBPS: :uint256 }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    require(lpFeeBPS <= 10000, \"Fees cannot exceed 100%\")\n    s.lpFeeBPS=lpFeeBPS\n    return nil\n  }\n  function(:allPairsLength, :public, :view, returns: :uint256) {\n    return s.allPairs.length\n  }\n  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {\n    require(tokenA != tokenB, \"FacetSwapV1: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1: ZERO_ADDRESS\")\n    require(s.getPair[token0][token1] == address(0), \"FacetSwapV1: PAIR_EXISTS\")\n    salt = keccak256(abi.encodePacked(token0, token1))\n    pair = new(FacetSwapV1Pair02({ salt: salt }))\n    pair.init(token0, token1)\n    s.getPair[token0][token1] = pair\n    s.getPair[token1][token0] = pair\n    s.allPairs.push(pair)\n    emit(:PairCreated, { token0: token0, token1: token1, pair: pair, pairLength: s.allPairs.length })\n    return pair\n  }\n  function(:setFeeTo, { _feeTo: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeTo=_feeTo\n    return nil\n  }\n  function(:setFeeToSetter, { _feeToSetter: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeToSetter=_feeToSetter\n    return nil\n  }\n  function(:upgradePairs, { pairs: [:address], newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    require(pairs.length <= 10, \"Too many pairs to upgrade at once\")\n    forLoop(condition: ->(i) {\n      i < pairs.length\n    }) { |i|\n      pair = pairs[i]\n      sourceToUse = if i == 0\n        newSource\n      else\n        \"\"\n      end\n      upgradePair(pair: pair, newHash: newHash, newSource: sourceToUse)\n    }\n  }\n  function(:upgradePair, { pair: :address, newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    Upgradeable(pair).upgrade(newHash: newHash, newSource: newSource)\n  }\n}\n",
    "init_code_hash": "0x958b66f80d8d14e5c2129434bb8c78aabb60b5cfb7113224102e1a9a07c77ac5",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Callee",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\n",
        "init_code_hash": "0xdfc5450f8af1e8b6650f7780eb3442d9ab9c26b049b838234d0372ebccc99403"
      },
      {
        "abi": null,
        "name": "FacetSwapV1ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\n",
        "init_code_hash": "0xc9eab797e3d8ce82dafb41448daaa1ca53b2364ff91223d6514fd6355884b5c4"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Factory02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\n",
        "init_code_hash": "0x36f033539c292372626be7ee16c1561d2166935c230d1df3a8424625969e2253"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Pair02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\n",
        "init_code_hash": "0x2dce6b589dd5a5bedc5d9a91806a6cc5f16ae52c0f8dae730a886d7212db2dfd"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T02:00:04.815Z",
    "updated_at": "2024-02-13T02:00:04.815Z"
  },
  {
    "id": 11,
    "transaction_hash": "0xc7d56adbe22b0da38f19d96771ead18715ffc0b98f1a0bc7deece1b0d153a73f",
    "internal_transaction_index": 1,
    "block_number": 18778577,
    "transaction_index": 10,
    "name": "FacetSwapV1Pair02",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\n",
    "init_code_hash": "0x2dce6b589dd5a5bedc5d9a91806a6cc5f16ae52c0f8dae730a886d7212db2dfd",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Callee",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\n",
        "init_code_hash": "0xdfc5450f8af1e8b6650f7780eb3442d9ab9c26b049b838234d0372ebccc99403"
      },
      {
        "abi": null,
        "name": "FacetSwapV1ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\n",
        "init_code_hash": "0xc9eab797e3d8ce82dafb41448daaa1ca53b2364ff91223d6514fd6355884b5c4"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Factory02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\n",
        "init_code_hash": "0x36f033539c292372626be7ee16c1561d2166935c230d1df3a8424625969e2253"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T02:00:04.967Z",
    "updated_at": "2024-02-13T02:00:04.967Z"
  },
  {
    "id": 12,
    "transaction_hash": "0x81f4f5254587614cb5a906b5161fa9f2f0a2e790869cb11d1f4e5bbbedce1f67",
    "internal_transaction_index": 0,
    "block_number": 18785811,
    "transaction_index": 60,
    "name": "FacetSwapV1Router03",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\ncontract(:FacetSwapV1Factory02, is: :Upgradeable, upgradeable: true) {\n  address(:public, :feeTo)\n  address(:public, :feeToSetter)\n  uint256(:public, :lpFeeBPS)\n  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)\n  array(:address, :public, :allPairs)\n  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })\n  constructor(_feeToSetter: :address) {\n    s.feeToSetter=_feeToSetter\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:setLpFeeBPS, { lpFeeBPS: :uint256 }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    require(lpFeeBPS <= 10000, \"Fees cannot exceed 100%\")\n    s.lpFeeBPS=lpFeeBPS\n    return nil\n  }\n  function(:allPairsLength, :public, :view, returns: :uint256) {\n    return s.allPairs.length\n  }\n  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {\n    require(tokenA != tokenB, \"FacetSwapV1: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1: ZERO_ADDRESS\")\n    require(s.getPair[token0][token1] == address(0), \"FacetSwapV1: PAIR_EXISTS\")\n    salt = keccak256(abi.encodePacked(token0, token1))\n    pair = new(FacetSwapV1Pair02({ salt: salt }))\n    pair.init(token0, token1)\n    s.getPair[token0][token1] = pair\n    s.getPair[token1][token0] = pair\n    s.allPairs.push(pair)\n    emit(:PairCreated, { token0: token0, token1: token1, pair: pair, pairLength: s.allPairs.length })\n    return pair\n  }\n  function(:setFeeTo, { _feeTo: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeTo=_feeTo\n    return nil\n  }\n  function(:setFeeToSetter, { _feeToSetter: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeToSetter=_feeToSetter\n    return nil\n  }\n  function(:upgradePairs, { pairs: [:address], newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    require(pairs.length <= 10, \"Too many pairs to upgrade at once\")\n    forLoop(condition: ->(i) {\n      i < pairs.length\n    }) { |i|\n      pair = pairs[i]\n      sourceToUse = if i == 0\n        newSource\n      else\n        \"\"\n      end\n      upgradePair(pair: pair, newHash: newHash, newSource: sourceToUse)\n    }\n  }\n  function(:upgradePair, { pair: :address, newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    Upgradeable(pair).upgrade(newHash: newHash, newSource: newSource)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:FacetSwapV1Router03, is: [:Ownable, :Upgradeable, :Pausable], upgradeable: true) {\n  address(:public, :factory)\n  address(:public, :WETH)\n  uint8(:public, :maxPathLength)\n  uint256(:public, :protocolFeeBPS)\n  event(:FeeAdjustedSwap, { inputToken: :address, outputToken: :address, inputAmount: :uint256, outputAmount: :uint256, feeAmount: :uint256, to: :address })\n  constructor(_factory: :address, _WETH: :address, protocolFeeBPS: :uint256, initialPauseState: :bool) {\n    s.factory=_factory\n    s.WETH=_WETH\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: msg.sender)\n    updateProtocolFee(protocolFeeBPS: protocolFeeBPS)\n    self.Pausable.constructor(initialPauseState: initialPauseState)\n    s.maxPathLength=3\n  }\n  function(:onUpgrade, { owner: :address, initialPauseState: :bool }, :public) {\n    require(msg.sender == address(this), \"Only the contract itself can upgrade\")\n    s.owner=owner\n    if initialPauseState\n      _pause\n    else\n      _unpause\n    end\n  }\n  function(:_addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256 }, :internal, :virtual, returns: { amountA: :uint256, amountB: :uint256 }) {\n    if FacetSwapV1Factory02(factory).getPair(tokenA, tokenB) == address(0)\n      FacetSwapV1Factory02(factory).createPair(tokenA, tokenB)\n    end\n    (reserveA, reserveB) = getReserves(s.factory, tokenA, tokenB)\n    if reserveA == 0 && reserveB == 0\n      return { amountA: amountADesired, amountB: amountBDesired }\n    else\n      amountBOptimal = quote(amountADesired, reserveA, reserveB)\n      if amountBOptimal <= amountBDesired\n        require(amountBOptimal >= amountBMin, \"FacetSwapV1Router: INSUFFICIENT_B_AMOUNT\")\n        return { amountA: amountADesired, amountB: amountBOptimal }\n      else\n        amountAOptimal = quote(amountBDesired, reserveB, reserveA)\n        require(amountAOptimal <= amountADesired, \"ASSERT\")\n        require(amountAOptimal >= amountAMin, \"FacetSwapV1Router: INSUFFICIENT_A_AMOUNT\")\n        return { amountA: amountAOptimal, amountB: amountBDesired }\n      end\n    end\n  }\n  function(:addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, :virtual, returns: { amountA: :uint256, amountB: :uint256, liquidity: :uint256 }) {\n    whenNotPaused!\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin)\n    pair = pairFor(s.factory, tokenA, tokenB)\n    _safeTransferFrom(token: tokenA, from: msg.sender, to: pair, value: amountA)\n    _safeTransferFrom(token: tokenB, from: msg.sender, to: pair, value: amountB)\n    liquidity = FacetSwapV1Pair02(pair).mint(to: to)\n    return { amountA: amountA, amountB: amountB, liquidity: liquidity }\n  }\n  function(:removeLiquidity, { tokenA: :address, tokenB: :address, liquidity: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, :virtual, returns: { amountA: :uint256, amountB: :uint256 }) {\n    whenNotPaused!\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    pair = pairFor(s.factory, tokenA, tokenB)\n    FacetSwapV1Pair02(pair).transferFrom(msg.sender, pair, liquidity)\n    (amount0, amount1) = FacetSwapV1Pair02(pair).burn(to)\n    (token0, _) = sortTokens(tokenA, tokenB)\n    (amountA, amountB) = if tokenA == token0\n      [amount0, amount1]\n    else\n      [amount1, amount0]\n    end\n    require(amountA >= amountAMin, \"FacetSwapV1Router: INSUFFICIENT_A_AMOUNT\")\n    require(amountB >= amountBMin, \"FacetSwapV1Router: INSUFFICIENT_B_AMOUNT\")\n    return { amountA: amountA, amountB: amountB }\n  }\n  function(:swapExactTokensForTokens, { amountIn: :uint256, amountOutMin: :uint256, path: [:address], to: :address, deadline: :uint256 }, :public, :virtual, returns: [:uint256]) {\n    whenNotPaused!\n    require(path[0] == s.WETH || path[path.length - 1] == s.WETH, \"Must have WETH as either the first or last token in the path\")\n    amountInWithFee = if path[0] == s.WETH\n      amountIn - calculateFeeAmount(amountIn)\n    else\n      amountIn\n    end\n    amounts = _swapExactTokensForTokens(amountIn: amountInWithFee, amountOutMin: amountOutMin, path: path, to: address(this), deadline: deadline)\n    amountToChargeFeeOn = if path[0] == s.WETH\n      amountIn\n    else\n      amounts[amounts.length - 1]\n    end\n    feeAmount = calculateFeeAmount(amountToChargeFeeOn)\n    if path[0] == s.WETH\n      amounts[0] = amountIn\n      ERC20(s.WETH).transferFrom(from: msg.sender, to: address(this), amount: feeAmount)\n    else\n      amounts[amounts.length - 1] -= feeAmount\n    end\n    outputToken = ERC20(path[path.length - 1])\n    outputToken.transfer(to, amounts[amounts.length - 1])\n    emit(:FeeAdjustedSwap, inputToken: path[0], outputToken: path[path.length - 1], inputAmount: amounts[0], outputAmount: amounts[amounts.length - 1], feeAmount: feeAmount, to: to)\n    amounts\n  }\n  function(:_swapExactTokensForTokens, { amountIn: :uint256, amountOutMin: :uint256, path: [:address], to: :address, deadline: :uint256 }, :internal, :virtual, returns: [:uint256]) {\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    amounts = getAmountsOut(factory, amountIn, path)\n    require(amounts[amounts.length - 1] >= amountOutMin, \"FacetSwapV1Router: INSUFFICIENT_OUTPUT_AMOUNT\")\n    _safeTransferFrom(path[0], msg.sender, pairFor(factory, path[0], path[1]), amounts[0])\n    _swap(amounts, path, to)\n    return amounts\n  }\n  function(:swapTokensForExactTokens, { amountOut: :uint256, amountInMax: :uint256, path: [:address], to: :address, deadline: :uint256 }, :public, :virtual, returns: [:uint256]) {\n    whenNotPaused!\n    require(path[0] == s.WETH || path[path.length - 1] == s.WETH, \"Must have WETH as either the first or last token in the path\")\n    amountOutWithFee = if path[path.length - 1] == s.WETH\n      amountOut + calculateFeeAmount(amountOut)\n    else\n      amountOut\n    end\n    amounts = _swapTokensForExactTokens(amountOut: amountOutWithFee, amountInMax: amountInMax, path: path, to: address(this), deadline: deadline)\n    amountToChargeFeeOn = if path[0] == s.WETH\n      amounts[0]\n    else\n      amountOut\n    end\n    feeAmount = calculateFeeAmount(amountToChargeFeeOn)\n    if path[0] == s.WETH\n      amounts[0] += feeAmount\n      ERC20(s.WETH).transferFrom(from: msg.sender, to: address(this), amount: feeAmount)\n    else\n      amounts[amounts.length - 1] = amountOut\n    end\n    outputToken = ERC20(path[path.length - 1])\n    outputToken.transfer(to, amounts[amounts.length - 1])\n    emit(:FeeAdjustedSwap, inputToken: path[0], outputToken: path[path.length - 1], inputAmount: amounts[0], outputAmount: amounts[amounts.length - 1], feeAmount: feeAmount, to: to)\n    amounts\n  }\n  function(:_swapTokensForExactTokens, { amountOut: :uint256, amountInMax: :uint256, path: [:address], to: :address, deadline: :uint256 }, :internal, :virtual, returns: [:uint256]) {\n    require(deadline >= block.timestamp, \"FacetSwapV1Router: EXPIRED\")\n    amounts = getAmountsIn(factory, amountOut, path)\n    require(amounts[0] <= amountInMax, \"FacetSwapV1Router: EXCESSIVE_INPUT_AMOUNT\")\n    _safeTransferFrom(path[0], msg.sender, pairFor(factory, path[0], path[1]), amounts[0])\n    _swap(amounts, path, to)\n    return amounts\n  }\n  function(:_swap, { amounts: [:uint256], path: [:address], _to: :address }, :internal, :virtual) {\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    forLoop(condition: ->(i) {\n      i < path.length.-(1)\n    }) { |i|\n      (input, output) = [path[i], path[i + 1]]\n      (token0, _) = sortTokens(input, output)\n      amountOut = amounts[i + 1]\n      (amount0Out, amount1Out) = if input == token0\n        [0, amountOut]\n      else\n        [amountOut, 0]\n      end\n      to = if i < path.length.-(2)\n        pairFor(factory, output, path[i + 2])\n      else\n        _to\n      end\n      FacetSwapV1Pair02(pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, \"\")\n    }\n  }\n  function(:_safeTransferFrom, { token: :address, from: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transferFrom(from: from, to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  function(:getAmountsOut, { factory: :address, amountIn: :uint256, path: [:address] }, :public, :view, returns: [:uint256]) {\n    require(path.length >= 2, \"FacetSwapV1Library: INVALID_PATH\")\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    amounts = array(:uint256, path.length)\n    amounts[0] = amountIn\n    forLoop(condition: ->(i) {\n      i < path.length.-(1)\n    }) { |i|\n      (reserveIn, reserveOut) = getReserves(factory, path[i], path[i + 1])\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut)\n    }\n    return amounts\n  }\n  function(:getAmountOut, { amountIn: :uint256, reserveIn: :uint256, reserveOut: :uint256 }, :public, :view, returns: :uint256) {\n    require(amountIn > 0, \"FacetSwapV1Library: INSUFFICIENT_INPUT_AMOUNT\")\n    require(reserveIn > 0 && reserveOut > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    lpFeeBPS = FacetSwapV1Factory02(s.factory).lpFeeBPS\n    totalFeeFactor = 1000 - lpFeeBPS.div(10)\n    amountInWithFee = amountIn * totalFeeFactor\n    numerator = amountInWithFee * reserveOut\n    denominator = reserveIn * 1000 + amountInWithFee\n    amountOut = numerator.div(denominator)\n    return amountOut\n  }\n  function(:getAmountsIn, { factory: :address, amountOut: :uint256, path: [:address] }, :public, :view, returns: [:uint256]) {\n    require(path.length >= 2, \"FacetSwapV1Library: INVALID_PATH\")\n    require(path.length <= s.maxPathLength, \"Max path length exceeded\")\n    amounts = array(:uint256, path.length)\n    amounts[amounts.length - 1] = amountOut\n    forLoop(start: path.length - 1, condition: ->(i) {\n      i > 0\n    }, step: -1) { |i|\n      (reserveIn, reserveOut) = getReserves(factory, path[i - 1], path[i])\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut)\n    }\n    return amounts\n  }\n  function(:getAmountIn, { amountOut: :uint256, reserveIn: :uint256, reserveOut: :uint256 }, :public, :view, returns: :uint256) {\n    require(amountOut > 0, \"FacetSwapV1Library: INSUFFICIENT_OUTPUT_AMOUNT\")\n    require(reserveIn > 0 && reserveOut > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    lpFeeBPS = FacetSwapV1Factory02(s.factory).lpFeeBPS\n    totalFeeFactor = 1000 - lpFeeBPS.div(10)\n    numerator = reserveIn * amountOut * 1000\n    denominator = (reserveOut - amountOut) * totalFeeFactor\n    amountIn = (numerator.div(denominator)) + 1\n    return amountIn\n  }\n  function(:quote, { amountA: :uint256, reserveA: :uint256, reserveB: :uint256 }, :public, :pure, returns: :uint256) {\n    require(amountA > 0, \"FacetSwapV1Library: INSUFFICIENT_AMOUNT\")\n    require(reserveA > 0 && reserveB > 0, \"FacetSwapV1Library: INSUFFICIENT_LIQUIDITY\")\n    return (amountA * reserveB).div(reserveA)\n  }\n  function(:getReserves, { factory: :address, tokenA: :address, tokenB: :address }, :public, :view, returns: { reserveA: :uint256, reserveB: :uint256 }) {\n    (token0, _) = sortTokens(tokenA, tokenB)\n    (reserve0, reserve1, _) = FacetSwapV1Pair02(pairFor(factory, tokenA, tokenB)).getReserves\n    (reserveA, reserveB) = if tokenA == token0\n      [reserve0, reserve1]\n    else\n      [reserve1, reserve0]\n    end\n    return { reserveA: reserveA, reserveB: reserveB }\n  }\n  function(:pairFor, { factory: :address, tokenA: :address, tokenB: :address }, :internal, :view, returns: :address) {\n    return FacetSwapV1Factory02(s.factory).getPair(tokenA, tokenB)\n  }\n  function(:sortTokens, { tokenA: :address, tokenB: :address }, :internal, :pure, returns: { token0: :address, token1: :address }) {\n    require(tokenA != tokenB, \"FacetSwapV1Library: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1Library: ZERO_ADDRESS\")\n    return { token0: token0, token1: token1 }\n  }\n  function(:calculateFeeAmount, { amount: :uint256 }, :public, :view, returns: :uint256) {\n    return (amount * s.protocolFeeBPS).div(10000)\n  }\n  function(:updateProtocolFee, { protocolFeeBPS: :uint256 }, :public) {\n    onlyOwner!\n    require(protocolFeeBPS <= 10000, \"Fee cannot be greater than 100%\")\n    s.protocolFeeBPS=protocolFeeBPS\n    nil\n  }\n  function(:withdrawFees, { to: :address }, :public, returns: :bool) {\n    onlyOwner!\n    ERC20(s.WETH).transfer(to: to, amount: ERC20(s.WETH).balanceOf(address(this)))\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:userStats, { user: :address, tokenA: :address, tokenB: :address }, :public, :view, returns: { userTokenABalance: :uint256, userTokenBBalance: :uint256, tokenAName: :string, tokenBName: :string, tokenAReserves: :uint256, tokenBReserves: :uint256, userLPBalance: :uint256, pairAddress: :address }) {\n    tokenAReserves = 0\n    tokenBReserves = 0\n    userLPBalance = 0\n    if FacetSwapV1Factory02(s.factory).getPair(tokenA, tokenB) != address(0)\n      (tokenAReserves, tokenBReserves) = getReserves(s.factory, tokenA, tokenB)\n      pair = FacetSwapV1Factory02(s.factory).getPair(tokenA, tokenB)\n      userLPBalance = FacetSwapV1ERC20(pair).balanceOf(user)\n    end\n    return { userTokenABalance: ERC20(tokenA).balanceOf(user), userTokenBBalance: ERC20(tokenB).balanceOf(user), tokenAName: ERC20(tokenA).name, tokenBName: ERC20(tokenB).name, tokenAReserves: tokenAReserves, tokenBReserves: tokenBReserves, userLPBalance: userLPBalance, pairAddress: pair }\n  }\n}\n",
    "init_code_hash": "0xd6c73897c5441fa221f1f0ebaee84241099b58f9cf51f6f4bcaf6bac4c29756d",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Callee",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\n",
        "init_code_hash": "0xdfc5450f8af1e8b6650f7780eb3442d9ab9c26b049b838234d0372ebccc99403"
      },
      {
        "abi": null,
        "name": "FacetSwapV1ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\n",
        "init_code_hash": "0xc9eab797e3d8ce82dafb41448daaa1ca53b2364ff91223d6514fd6355884b5c4"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Factory02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\n",
        "init_code_hash": "0x36f033539c292372626be7ee16c1561d2166935c230d1df3a8424625969e2253"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Pair02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\n",
        "init_code_hash": "0x2dce6b589dd5a5bedc5d9a91806a6cc5f16ae52c0f8dae730a886d7212db2dfd"
      },
      {
        "abi": null,
        "name": "FacetSwapV1Factory02",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetSwapV1Callee, abstract: true) {\n  function(:facetSwapV1Call, { sender: :address, amount0: :uint256, amount1: :uint256, data: :bytes }, :virtual, :external)\n}\ncontract(:FacetSwapV1ERC20, is: :ERC20, abstract: true) {\n  constructor {\n    self.ERC20.constructor(name: \"FacetSwap V1 ERC20\", symbol: \"FACET-V1\", decimals: 18)\n  }\n}\ncontract(:IFacetSwapV1Factory02, abstract: true) {\n  function(:feeTo, :external, :view, returns: :address)\n  function(:lpFeeBPS, :external, :view, returns: :uint256)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetSwapV1Pair02, is: [:FacetSwapV1ERC20, :Upgradeable], upgradeable: true) {\n  uint256(:public, :MINIMUM_LIQUIDITY)\n  address(:public, :factory)\n  address(:public, :token0)\n  address(:public, :token1)\n  uint112(:private, :reserve0)\n  uint112(:private, :reserve1)\n  uint32(:private, :blockTimestampLast)\n  uint256(:public, :price0CumulativeLast)\n  uint256(:public, :price1CumulativeLast)\n  uint256(:public, :kLast)\n  uint256(:private, :unlocked)\n  function(:getReserves, {}, :public, :view, returns: { _reserve0: :uint112, _reserve1: :uint112, _blockTimestampLast: :uint32 }) {\n    return { _reserve0: s.reserve0, _reserve1: s.reserve1, _blockTimestampLast: s.blockTimestampLast }\n  }\n  function(:_safeTransfer, { token: :address, to: :address, value: :uint256 }, :private) {\n    result = ERC20(token).transfer(to: to, amount: value)\n    require(result, \"FacetSwapV1: TRANSFER_FAILED\")\n  }\n  event(:Mint, { sender: :address, amount0: :uint256, amount1: :uint256 })\n  event(:Burn, { sender: :address, amount0: :uint256, amount1: :uint256, to: :address })\n  event(:Swap, { sender: :address, amount0In: :uint256, amount1In: :uint256, amount0Out: :uint256, amount1Out: :uint256, to: :address })\n  event(:Sync, { reserve0: :uint112, reserve1: :uint112 })\n  event(:PreSwapReserves, { reserve0: :uint112, reserve1: :uint112 })\n  constructor {\n    self.FacetSwapV1ERC20.constructor\n    s.factory=msg.sender\n    s.MINIMUM_LIQUIDITY=10 ** 3\n    s.unlocked=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:init, { _token0: :address, _token1: :address }, :external) {\n    require(msg.sender == s.factory, \"FacetSwapV1: FORBIDDEN\")\n    s.token0=_token0\n    s.token1=_token1\n    return nil\n  }\n  function(:_update, { balance0: :uint256, balance1: :uint256, _reserve0: :uint112, _reserve1: :uint112 }, :private) {\n    require(balance0 <= (2 ** 112 - 1) && balance1 <= (2 ** 112 - 1), \"FacetSwapV1: OVERFLOW\")\n    blockTimestamp = uint32(block.timestamp % 2.**(32))\n    timeElapsed = blockTimestamp - s.blockTimestampLast\n    if timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0\n      s.price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed\n      s.price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed\n    end\n    emit(:PreSwapReserves, reserve0: s.reserve0, reserve1: s.reserve1)\n    s.reserve0=uint112(balance0)\n    s.reserve1=uint112(balance1)\n    s.blockTimestampLast=blockTimestamp\n    emit(:Sync, reserve0: s.reserve0, reserve1: s.reserve1)\n  }\n  function(:encode, { y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return uint224(y) * (2 ** 112)\n  }\n  function(:uqdiv, { x: :uint224, y: :uint112 }, :internal, :pure, returns: :uint224) {\n    return x / uint224(y)\n  }\n  function(:_mintFee, { _reserve0: :uint112, _reserve1: :uint112 }, :private, returns: :bool) {\n    feeTo = IFacetSwapV1Factory02(s.factory).feeTo\n    feeOn = feeTo != address(0)\n    _kLast = s.kLast\n    if feeOn\n      if _kLast != 0\n        rootK = sqrt(_reserve0 * _reserve1)\n        rootKLast = sqrt(_kLast)\n        if rootK > rootKLast\n          numerator = totalSupply * (rootK - rootKLast)\n          denominator = rootK * 5 + rootKLast\n          liquidity = numerator.div(denominator)\n          if liquidity > 0\n            _mint(feeTo, liquidity)\n          end\n        end\n      end\n    else\n      if _kLast != 0\n        s.kLast=0\n      end\n    end\n    feeOn\n  }\n  function(:mint, { to: :address }, :public, returns: :uint256) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    balance0 = ERC20(s.token0).balanceOf(address(this))\n    balance1 = ERC20(s.token1).balanceOf(address(this))\n    amount0 = balance0 - _reserve0\n    amount1 = balance1 - _reserve1\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    if _totalSupply == 0\n      liquidity = sqrt(amount0 * amount1) - s.MINIMUM_LIQUIDITY\n      _mint(address(0), s.MINIMUM_LIQUIDITY)\n    else\n      liquidity = [(amount0 * _totalSupply).div(_reserve0), (amount1 * _totalSupply).div(_reserve1)].min\n    end\n    require(liquidity > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_MINTED\")\n    _mint(to, liquidity)\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Mint, sender: msg.sender, amount0: amount0, amount1: amount1)\n    s.unlocked=1\n    return liquidity\n  }\n  function(:burn, { to: :address }, :external, :lock, returns: { amount0: :uint256, amount1: :uint256 }) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    (_reserve0, _reserve1, _) = getReserves\n    _token0 = s.token0\n    _token1 = s.token1\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    liquidity = s.balanceOf[address(this)]\n    feeOn = _mintFee(_reserve0, _reserve1)\n    _totalSupply = s.totalSupply\n    amount0 = (liquidity * balance0).div(_totalSupply)\n    amount1 = (liquidity * balance1).div(_totalSupply)\n    require(amount0 > 0 && amount1 > 0, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY_BURNED\")\n    _burn(address(this), liquidity)\n    _safeTransfer(_token0, to, amount0)\n    _safeTransfer(_token1, to, amount1)\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    _update(balance0, balance1, _reserve0, _reserve1)\n    if feeOn\n      s.kLast=s.reserve0 * s.reserve1\n    end\n    emit(:Burn, sender: msg.sender, amount0: amount0, amount1: amount1, to: to)\n    s.unlocked=1\n    return { amount0: amount0, amount1: amount1 }\n  }\n  function(:swap, { amount0Out: :uint256, amount1Out: :uint256, to: :address, data: :bytes }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    require(amount0Out > 0 || amount1Out > 0, \"FacetSwapV1: INSUFFICIENT_OUTPUT_AMOUNT\")\n    (_reserve0, _reserve1, _) = getReserves\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"FacetSwapV1: INSUFFICIENT_LIQUIDITY\")\n    balance0 = 0\n    balance1 = 0\n    _token0 = s.token0\n    _token1 = s.token1\n    require(to != _token0 && to != _token1, \"FacetSwapV1: INVALID_TO\")\n    if amount0Out > 0\n      _safeTransfer(_token0, to, amount0Out)\n    end\n    if amount1Out > 0\n      _safeTransfer(_token1, to, amount1Out)\n    end\n    if data.length > 0\n      FacetSwapV1Callee(to).facetSwapV1Call(msg.sender, amount0Out, amount1Out, data)\n    end\n    balance0 = ERC20(_token0).balanceOf(address(this))\n    balance1 = ERC20(_token1).balanceOf(address(this))\n    amount0In = if balance0 > _reserve0.-(amount0Out)\n      balance0 - (_reserve0 - amount0Out)\n    else\n      0\n    end\n    amount1In = if balance1 > _reserve1.-(amount1Out)\n      balance1 - (_reserve1 - amount1Out)\n    else\n      0\n    end\n    require(amount0In > 0 || amount1In > 0, \"FacetSwapV1: INSUFFICIENT_INPUT_AMOUNT\")\n    lpFeeBPS = IFacetSwapV1Factory02(s.factory).lpFeeBPS\n    balance0Adjusted = balance0 * 1000 - (amount0In * lpFeeBPS).div(10)\n    balance1Adjusted = balance1 * 1000 - (amount1In * lpFeeBPS).div(10)\n    require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0).*(_reserve1).*((1000 ** 2)), \"FacetSwapV1: K\")\n    _update(balance0, balance1, _reserve0, _reserve1)\n    s.unlocked=1\n    emit(:Swap, sender: msg.sender, amount0In: amount0In, amount1In: amount1In, amount0Out: amount0Out, amount1Out: amount1Out, to: to)\n  }\n  function(:skim, { to: :address }, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _token0 = s.token0\n    _token1 = s.token1\n    _safeTransfer(_token0, to, ERC20(_token0).balanceOf(address(this)) - s.reserve0)\n    _safeTransfer(_token1, to, ERC20(_token1).balanceOf(address(this)) - s.reserve1)\n    s.unlocked=1\n    nil\n  }\n  function(:sync, {}, :external) {\n    require(s.unlocked == 1, \"FacetSwapV1: LOCKED\")\n    s.unlocked=0\n    _update(ERC20(s.token0).balanceOf(address(this)), ERC20(s.token1).balanceOf(address(this)), s.reserve0, s.reserve1)\n    s.unlocked=1\n    nil\n  }\n}\ncontract(:FacetSwapV1Factory02, is: :Upgradeable, upgradeable: true) {\n  address(:public, :feeTo)\n  address(:public, :feeToSetter)\n  uint256(:public, :lpFeeBPS)\n  mapping(({ address: mapping({ address: :address }) }), :public, :getPair)\n  array(:address, :public, :allPairs)\n  event(:PairCreated, { token0: :address, token1: :address, pair: :address, pairLength: :uint256 })\n  constructor(_feeToSetter: :address) {\n    s.feeToSetter=_feeToSetter\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:setLpFeeBPS, { lpFeeBPS: :uint256 }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    require(lpFeeBPS <= 10000, \"Fees cannot exceed 100%\")\n    s.lpFeeBPS=lpFeeBPS\n    return nil\n  }\n  function(:allPairsLength, :public, :view, returns: :uint256) {\n    return s.allPairs.length\n  }\n  function(:createPair, { tokenA: :address, tokenB: :address }, :public, returns: :address) {\n    require(tokenA != tokenB, \"FacetSwapV1: IDENTICAL_ADDRESSES\")\n    (token0, token1) = if tokenA.cast(:uint256) < tokenB.cast(:uint256)\n      [tokenA, tokenB]\n    else\n      [tokenB, tokenA]\n    end\n    require(token0 != address(0), \"FacetSwapV1: ZERO_ADDRESS\")\n    require(s.getPair[token0][token1] == address(0), \"FacetSwapV1: PAIR_EXISTS\")\n    salt = keccak256(abi.encodePacked(token0, token1))\n    pair = new(FacetSwapV1Pair02({ salt: salt }))\n    pair.init(token0, token1)\n    s.getPair[token0][token1] = pair\n    s.getPair[token1][token0] = pair\n    s.allPairs.push(pair)\n    emit(:PairCreated, { token0: token0, token1: token1, pair: pair, pairLength: s.allPairs.length })\n    return pair\n  }\n  function(:setFeeTo, { _feeTo: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeTo=_feeTo\n    return nil\n  }\n  function(:setFeeToSetter, { _feeToSetter: :address }, :public) {\n    require(msg.sender == feeToSetter, \"FacetSwapV1: FORBIDDEN\")\n    s.feeToSetter=_feeToSetter\n    return nil\n  }\n  function(:upgradePairs, { pairs: [:address], newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    require(pairs.length <= 10, \"Too many pairs to upgrade at once\")\n    forLoop(condition: ->(i) {\n      i < pairs.length\n    }) { |i|\n      pair = pairs[i]\n      sourceToUse = if i == 0\n        newSource\n      else\n        \"\"\n      end\n      upgradePair(pair: pair, newHash: newHash, newSource: sourceToUse)\n    }\n  }\n  function(:upgradePair, { pair: :address, newHash: :bytes32, newSource: :string }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    Upgradeable(pair).upgrade(newHash: newHash, newSource: newSource)\n  }\n}\n",
        "init_code_hash": "0x958b66f80d8d14e5c2129434bb8c78aabb60b5cfb7113224102e1a9a07c77ac5"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T02:15:54.084Z",
    "updated_at": "2024-02-13T02:15:54.084Z"
  },
  {
    "id": 13,
    "transaction_hash": "0x5706f28c8b95529d074d43f01e912f132ef32c1ba0cb81749a8e24c7fb4b8a9e",
    "internal_transaction_index": 0,
    "block_number": 18837180,
    "transaction_index": 53,
    "name": "EthscriptionERC20BridgeV2",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:EthscriptionERC20BridgeV2, is: [:ERC20, :Upgradeable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  uint256(:public, :mintAmount)\n  address(:public, :trustedSmartContract)\n  mapping(({ address: :uint256 }), :public, :bridgedInAmount)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(name: :string, symbol: :string, mintAmount: :uint256, trustedSmartContract: :address) {\n    require(mintAmount > 0, \"Invalid mint amount\")\n    require(trustedSmartContract != address(0), \"Invalid smart contract\")\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: 18)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.mintAmount=mintAmount\n    s.trustedSmartContract=trustedSmartContract\n  }\n  function(:onUpgrade, { newTrustedSmartContract: :address }, :public) {\n    require(msg.sender == address(this), \"Only the contract itself can migrate\")\n    s.trustedSmartContract=newTrustedSmartContract\n    return nil\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can bridge in tokens\")\n    s.bridgedInAmount[to] += amount\n    _mint(to: to, amount: amount * s.mintAmount * 1.ether)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeOut, { amount: :uint256 }, :public) {\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[msg.sender] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(s.bridgedInAmount[msg.sender] >= amount, \"Not enough bridged in\")\n    require(amount > 0, \"Invalid amount\")\n    s.userWithdrawalId[msg.sender] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    s.bridgedInAmount[msg.sender] -= amount\n    _burn(from: msg.sender, amount: amount * s.mintAmount * 1.ether)\n    emit(:InitiateWithdrawal, from: msg.sender, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can mark withdrawals as complete\")\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n}\n",
    "init_code_hash": "0xf95c578c5c54f4669d21387e89cfcf16d1fffb3937b47f1d1a22850c0ad80f6e",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T04:00:53.088Z",
    "updated_at": "2024-02-13T04:00:53.088Z"
  },
  {
    "id": 14,
    "transaction_hash": "0xc1f1654ea88a63f7125d8efc1df749f910cc4c0ab6b42ad5d22a2b6f35c700b8",
    "internal_transaction_index": 0,
    "block_number": 19000377,
    "transaction_index": 133,
    "name": "NameRegistry01",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:NameRegistryRenderer01, abstract: true) {\n  string(:public, :cardTemplate)\n  event(:StickerCreated, { stickerId: :uint256, name: :string, description: :string, imageURI: :string, stickerExpiry: :uint256, grantingAddress: :address })\n  event(:StickerClaimed, { stickerId: :uint256, claimer: :address })\n  event(:StickerPlaced, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) })\n  event(:StickerRepositioned, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) })\n  event(:CardDetailsSet, { tokenId: :uint256, displayName: :string, bio: :string, imageURI: :string, links: [:string] })\n  mapping(({ uint256: :string }), :public, :cardDisplayNames)\n  mapping(({ uint256: :string }), :public, :cardBios)\n  mapping(({ uint256: :string }), :public, :cardImageURIs)\n  mapping(({ uint256: [:string] }), :public, :cardLinks)\n  uint256(:public, :nextStickerId)\n  mapping(({ uint256: :address }), :public, :stickerIdToSigner)\n  mapping(({ uint256: :string }), :public, :stickerIdToName)\n  mapping(({ uint256: :string }), :public, :stickerIdToDescription)\n  mapping(({ uint256: :string }), :public, :stickerIdToImageURI)\n  mapping(({ uint256: :uint256 }), :public, :stickerIdToExpiry)\n  mapping(({ address: [:uint256] }), :public, :userToStickerAry)\n  mapping(({ address: mapping(uint256: :bool) }), :public, :userToStickerIdsAwardedMap)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerIdsAry)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerXPositionsAry)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerYPositionsAry)\n  mapping(({ uint256: mapping(uint256: :bool) }), :public, :tokenIdToStickerIdsPlacedMap)\n  uint256(:public, :maxStickersPerUser)\n  uint256(:public, :maxStickersPerCard)\n  uint256(:public, :maxLinksPerCard)\n  uint256(:public, :bioMaxLength)\n  uint256(:public, :displayNameMaxLength)\n  uint256(:public, :uriMaxLength)\n  constructor(cardTemplate: :string) {\n    s.maxStickersPerUser=25\n    s.maxStickersPerCard=s.maxStickersPerUser\n    s.maxLinksPerCard=5\n    s.bioMaxLength=1000\n    s.displayNameMaxLength=100\n    s.uriMaxLength=96000\n    require(cardTemplate.length <= s.uriMaxLength, \"cardTemplate too long\")\n    s.cardTemplate=cardTemplate\n  }\n  function(:renderCard, { tokenId: :uint256 }, :public, :view, returns: :string) {\n    enforceNotExpired!(tokenId)\n    owner = ownerOf(tokenId)\n    name = s.tokenIdToName[tokenId]\n    (stickerIds, stickerXPositions, stickerYPositions, stickerImageURIs) = getCardStickers(tokenId)\n    (displayName, bio, imageURI, links) = getCardDetails(tokenId)\n    storage = json.stringify(tokenId: tokenId.toString, owner: owner, name: name, stickerIds: stickerIds, stickerXPositions: stickerXPositions, stickerYPositions: stickerYPositions, stickerImages: stickerImageURIs, displayName: displayName, bio: bio, imageURI: imageURI, links: links)\n    template = \"`#{s.cardTemplate}`\"\n    wrapped = <<-HEREDOC\n<script>\n  window.s = #{storage};\n  document.open();\n  document.write(#{template});\n  document.close();\n</script>\n    HEREDOC\n  }\n  function(:createSticker, { name: :string, description: :string, imageURI: :string, stickerExpiry: :uint256, grantingAddress: :address }, :public) {\n    whenNotPaused!\n    require(name.length > 0, \"Name must be non-empty\")\n    require(name.length <= s.displayNameMaxLength, \"Name too long\")\n    require(description.length <= s.bioMaxLength, \"description too long\")\n    require(imageURI.length <= s.uriMaxLength, \"imageURI too long\")\n    require(grantingAddress != address(0), \"Granting address must be non-zero\")\n    currentId = s.nextStickerId\n    s.nextStickerId += 1\n    s.stickerIdToName[currentId] = name\n    s.stickerIdToImageURI[currentId] = imageURI\n    s.stickerIdToDescription[currentId] = description\n    s.stickerIdToExpiry[currentId] = stickerExpiry\n    s.stickerIdToSigner[currentId] = grantingAddress\n    emit(:StickerCreated, stickerId: currentId, name: name, description: description, imageURI: imageURI, stickerExpiry: stickerExpiry, grantingAddress: grantingAddress)\n  }\n  function(:claimSticker, { stickerId: :uint256, deadline: :uint256, tokenId: :uint256, position: array(:uint256, 2), signature: :bytes }, :public) {\n    whenNotPaused!\n    require(!s.userToStickerIdsAwardedMap[msg.sender][stickerId], \"Sticker already awarded\")\n    require(s.userToStickerAry[msg.sender].length < s.maxStickersPerUser, \"Too many stickers\")\n    require(deadline > block.timestamp, \"Deadline passed\")\n    require(s.stickerIdToExpiry[stickerId] > block.timestamp, \"Sticker expired\")\n    signatureValid = signature.verifyTypedDataSignature({ StickerClaim: [{ name: \"stickerId\", type: \"uint256\" }, { name: \"claimer\", type: \"address\" }, { name: \"deadline\", type: \"uint256\" }] }, { stickerId: stickerId, claimer: msg.sender, deadline: deadline }, verifyingContract: address(this), domainName: s.name, domainVersion: \"1\", signer: s.stickerIdToSigner[stickerId])\n    require(signatureValid, \"Invalid signature\")\n    s.userToStickerIdsAwardedMap[msg.sender][stickerId] = true\n    s.userToStickerAry[msg.sender].push(stickerId)\n    if tokenId != 0\n      placeSticker(stickerId, tokenId, position)\n    end\n    emit(:StickerClaimed, stickerId: stickerId, claimer: msg.sender)\n  }\n  function(:placeSticker, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) }, :public) {\n    whenNotPaused!\n    enforceNotExpired!(tokenId)\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    require(s.userToStickerIdsAwardedMap[msg.sender][stickerId], \"Sticker not claimed\")\n    require(!s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId], \"Sticker already placed\")\n    require(s.tokenIdToStickerIdsAry[tokenId].length < s.maxStickersPerCard, \"Too many stickers\")\n    s.tokenIdToStickerIdsAry[tokenId].push(stickerId)\n    s.tokenIdToStickerXPositionsAry[tokenId].push(position[0])\n    s.tokenIdToStickerYPositionsAry[tokenId].push(position[1])\n    s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId] = true\n    emit(:StickerPlaced, stickerId: stickerId, tokenId: tokenId, position: position)\n  }\n  function(:repositionSticker, { stickerIndex: :uint256, tokenId: :uint256, position: array(:uint256, 2) }, :public) {\n    whenNotPaused!\n    enforceNotExpired!(tokenId)\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    stickerId = s.tokenIdToStickerIdsAry[tokenId][stickerIndex]\n    require(s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId], \"Sticker not placed\")\n    s.tokenIdToStickerXPositionsAry[tokenId][stickerIndex] = position[0]\n    s.tokenIdToStickerYPositionsAry[tokenId][stickerIndex] = position[1]\n    emit(:StickerRepositioned, stickerId: stickerId, tokenId: tokenId, position: position)\n  }\n  function(:setCardDetails, { tokenId: :uint256, displayName: :string, bio: :string, imageURI: :string, links: [:string] }, :public) {\n    whenNotPaused!\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    require(links.length <= s.maxLinksPerCard, \"Too many links\")\n    require(bio.length <= s.bioMaxLength, \"Bio too long\")\n    require(displayName.length <= s.displayNameMaxLength, \"Display name too long\")\n    require(imageURI.length <= s.uriMaxLength, \"imageURI too long\")\n    s.cardDisplayNames[tokenId] = displayName\n    s.cardBios[tokenId] = bio\n    s.cardImageURIs[tokenId] = imageURI\n    s.cardLinks[tokenId] = links\n    emit(:CardDetailsSet, tokenId: tokenId, displayName: displayName, bio: bio, imageURI: imageURI, links: links)\n  }\n  function(:getCardDetails, { tokenId: :uint256 }, :public, :view, returns: { displayName: :string, bio: :string, imageURI: :string, links: [:string] }) {\n    enforceNotExpired!(tokenId)\n    return { displayName: s.cardDisplayNames[tokenId], bio: s.cardBios[tokenId], imageURI: s.cardImageURIs[tokenId], links: s.cardLinks[tokenId] }\n  }\n  function(:getCardStickers, { tokenId: :uint256 }, :public, :view, returns: { stickerIds: [:uint256], stickerXPositions: [:uint256], stickerYPositions: [:uint256], stickerImageURIs: [:string] }) {\n    enforceNotExpired!(tokenId)\n    stickerIds = array(:uint256, 0)\n    stickerXPositions = array(:uint256, 0)\n    stickerYPositions = array(:uint256, 0)\n    stickerImageURIs = array(:string, 0)\n    forLoop(condition: ->(i) {\n      i < s.tokenIdToStickerIdsAry[tokenId].length\n    }) { |i|\n      stickerId = s.tokenIdToStickerIdsAry[tokenId][i]\n      if (s.stickerIdToExpiry[stickerId] > block.timestamp)\n        stickerIds.push(stickerId)\n        stickerXPositions.push(s.tokenIdToStickerXPositionsAry[tokenId][i])\n        stickerYPositions.push(s.tokenIdToStickerYPositionsAry[tokenId][i])\n        stickerImageURIs.push(s.stickerIdToImageURI[stickerId])\n      end\n    }\n    return { stickerIds: stickerIds, stickerXPositions: stickerXPositions, stickerYPositions: stickerYPositions, stickerImageURIs: stickerImageURIs }\n  }\n  function(:updateCardTemplate, { cardTemplate: :string }, :public) {\n    onlyOwner!\n    s.cardTemplate=cardTemplate\n    return nil\n  }\n  function(:_clearCardPersonalInfo, { tokenId: :uint256 }, :internal) {\n    _clearCardDetails(tokenId)\n    _clearStickers(tokenId)\n  }\n  function(:_clearCardDetails, { tokenId: :uint256 }, :internal) {\n    s.cardDisplayNames[tokenId] = \"\"\n    s.cardBios[tokenId] = \"\"\n    s.cardImageURIs[tokenId] = \"\"\n    s.cardLinks[tokenId] = array(:string, 0)\n    nil\n  }\n  function(:_clearStickers, { tokenId: :uint256 }, :internal) {\n    forLoop(condition: ->(i) {\n      i < s.tokenIdToStickerIdsAry[tokenId].length\n    }) { |i|\n      stickerId = s.tokenIdToStickerIdsAry[tokenId][i]\n      s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId] = false\n    }\n    s.tokenIdToStickerIdsAry[tokenId] = array(:uint256, 0)\n    s.tokenIdToStickerXPositionsAry[tokenId] = array(:uint256, 0)\n    s.tokenIdToStickerYPositionsAry[tokenId] = array(:uint256, 0)\n    nil\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:NameRegistry01, is: [:ERC721, :ERC2981, :Upgradeable, :Ownable, :Pausable, :NameRegistryRenderer01], upgradeable: true) {\n  event(:NameRegistered, { tokenId: :uint256, owner: :address, name: :string, expires: :uint256 })\n  event(:NameRenewed, { tokenId: :uint256, newExpiry: :uint256 })\n  event(:PrimaryNameSet, { user: :address, tokenId: :uint256 })\n  event(:ConversionRateUpdate, { newRate: :uint256 })\n  address(:public, :WETH)\n  uint256(:public, :usdWeiCentsInOneEth)\n  uint256(:public, :minRegistrationDuration)\n  uint256(:public, :gracePeriod)\n  uint256(:public, :maxNameLength)\n  array(:uint256, :public, :charCountToUsdWeiCentsPrice, initial_length: 0)\n  bool(:public, :preregistrationComplete)\n  uint256(:public, :nextTokenId)\n  mapping(({ string: :uint256 }), :public, :nameToTokenId)\n  mapping(({ uint256: :string }), :public, :tokenIdToName)\n  mapping(({ address: :uint256 }), :internal, :userToPrimaryNameTokenId)\n  mapping(({ uint256: :uint256 }), :public, :tokenExpiryTimes)\n  mapping(({ uint256: :uint256 }), :public, :registrationTimestamps)\n  uint256(:public, :maxImportBatchSize)\n  constructor(name: :string, symbol: :string, owner: :address, usdWeiCentsInOneEth: :uint256, charCountToUsdWeiCentsPrice: [:uint256], cardTemplate: :string, _WETH: :address) {\n    require(charCountToUsdWeiCentsPrice.length >= 4, \"Must have at least 4 price points\")\n    require(charCountToUsdWeiCentsPrice.length <= 10, \"Must have at most 10 price points\")\n    self.ERC721.constructor(name: name, symbol: symbol)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: owner)\n    self.Pausable.constructor(initialPauseState: true)\n    self.NameRegistryRenderer01.constructor(cardTemplate: cardTemplate)\n    s.WETH=_WETH\n    s.usdWeiCentsInOneEth=usdWeiCentsInOneEth\n    s.charCountToUsdWeiCentsPrice=charCountToUsdWeiCentsPrice\n    s.maxNameLength=32\n    s.gracePeriod=90.days\n    s.minRegistrationDuration=28.days\n    s.nextTokenId=1\n    s.nextStickerId=1\n    s.maxImportBatchSize=10\n  }\n  function(:registerNameWithPayment, { to: :address, name: :string, durationInSeconds: :uint256 }, :public, returns: :bool) {\n    whenNotPaused!\n    require(s.preregistrationComplete, \"Preregistration must be complete\")\n    require(durationInSeconds >= s.minRegistrationDuration, \"Duration too short\")\n    _registerName(to: to, name: name, durationInSeconds: durationInSeconds)\n    if to == msg.sender && s.userToPrimaryNameTokenId[msg.sender] == 0\n      tokenId = s.nameToTokenId[name]\n      s.userToPrimaryNameTokenId[msg.sender] = tokenId\n    end\n    ERC20(s.WETH).transferFrom(msg.sender, address(this), getPrice(name, durationInSeconds))\n  }\n  function(:renewNameWithPayment, { name: :string, durationInSeconds: :uint256 }, :public, returns: :bool) {\n    whenNotPaused!\n    _renewName(name: name, durationInSeconds: durationInSeconds)\n    ERC20(s.WETH).transferFrom(msg.sender, address(this), getPrice(name, durationInSeconds))\n  }\n  function(:_registerName, { to: :address, name: :string, durationInSeconds: :uint256 }, :internal) {\n    require(nameAvailable(name), \"Name not available\")\n    require(nameIsValid(name), \"Invalid name\")\n    tokenId = s.nameToTokenId[name]\n    if _exists(tokenId)\n      _burn(tokenId)\n    else\n      tokenId = s.nextTokenId\n      s.nextTokenId += 1\n    end\n    _mint(to: to, id: tokenId)\n    s.nameToTokenId[name] = tokenId\n    s.tokenIdToName[tokenId] = name\n    s.tokenExpiryTimes[tokenId] = block.timestamp + durationInSeconds\n    s.registrationTimestamps[tokenId] = block.timestamp\n    emit(:NameRegistered, tokenId: tokenId, owner: to, name: name, expires: s.tokenExpiryTimes[tokenId])\n  }\n  function(:_renewName, { name: :string, durationInSeconds: :uint256 }, :internal) {\n    tokenId = s.nameToTokenId[name]\n    currentExpiry = s.tokenExpiryTimes[tokenId]\n    require(currentExpiry + s.gracePeriod >= block.timestamp, \"Must be registered or in grace period\")\n    s.tokenExpiryTimes[tokenId] = currentExpiry + durationInSeconds\n    emit(:NameRenewed, tokenId: tokenId, newExpiry: s.tokenExpiryTimes[tokenId])\n  }\n  function(:markPreregistrationComplete, :public) {\n    onlyOwner!\n    s.preregistrationComplete=true\n    nil\n  }\n  function(:importFromPreregistration, { names: [:string], owners: [:address], durations: [:uint256] }, :public) {\n    onlyOwner!\n    require(!s.preregistrationComplete, \"Preregistration must not be complete\")\n    require(names.length == owners.length, \"Names and owners must be the same length\")\n    require(names.length == durations.length, \"Names and owners must be the same length\")\n    require(names.length <= s.maxImportBatchSize, \"Cannot import more than 10 names at a time\")\n    forLoop(condition: ->(i) {\n      i < names.length\n    }) { |i|\n      _registerName(to: owners[i], name: names[i], durationInSeconds: durations[i])\n      if s.userToPrimaryNameTokenId[owners[i]] == 0\n        tokenId = s.nameToTokenId[names[i]]\n        s.userToPrimaryNameTokenId[owners[i]] = tokenId\n      end\n    }\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :override, returns: :string) {\n    require(_exists(id: id), \"ERC721Metadata: URI query for nonexistent token\")\n    enforceNotExpired!(id)\n    name = s.tokenIdToName[id]\n    card = self.NameRegistryRenderer01.renderCard(id)\n    b64Card = \"data:text/html;charset=utf-8;base64,\" + card.base64Encode\n    attributes = [{ display_type: \"number\", trait_type: \"Length\", value: name.length }, { display_type: \"date\", trait_type: \"Expiration Date\", value: s.tokenExpiryTimes[id] }, { display_type: \"date\", trait_type: \"Registration Date\", value: s.registrationTimestamps[id] }]\n    json_data = json.stringify(name: name, description: \"#{name}, a Facet Card name.\", animation_url: b64Card, attributes: attributes)\n    return \"data:application/json,#{json_data}\"\n  }\n  function(:_burn, { id: :uint256 }, :internal, :override) {\n    owner = s._ownerOf[id]\n    if s.userToPrimaryNameTokenId[owner] == id\n      s.userToPrimaryNameTokenId[owner] = 0\n    end\n    _clearCardPersonalInfo(id)\n    self.ERC721._burn(id)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :override) {\n    if s.userToPrimaryNameTokenId[from] == id\n      s.userToPrimaryNameTokenId[from] = 0\n    end\n    _clearCardPersonalInfo(id)\n    self.ERC721.transferFrom(from: from, to: to, id: id)\n  }\n  function(:enforceNotExpired!, { id: :uint256 }, :internal) {\n    require(s.tokenExpiryTimes[id] > block.timestamp, \"Name expired\")\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :override, returns: :address) {\n    owner = self.ERC721.ownerOf(id)\n    enforceNotExpired!(id)\n    owner\n  }\n  function(:lookupAddress, { user: :address }, :public, :view, returns: :string) {\n    candidateId = s.userToPrimaryNameTokenId[user]\n    require(ownerOf(candidateId) == user, \"Not the owner\")\n    s.tokenIdToName[candidateId]\n  }\n  function(:setPrimaryName, { name: :string }, :public) {\n    tokenId = s.nameToTokenId[name]\n    require(msg.sender == ownerOf(tokenId), \"Not the owner\")\n    s.userToPrimaryNameTokenId[msg.sender] = tokenId\n    emit(:PrimaryNameSet, user: msg.sender, tokenId: tokenId)\n  }\n  function(:resolveName, { name: :string }, :public, :view, returns: :address) {\n    tokenId = s.nameToTokenId[name]\n    ownerOf(tokenId)\n  }\n  function(:nameIsValid, { name: :string }, :public, :view, returns: :bool) {\n    name.length <= s.maxNameLength && name.isAlphaNumeric? && name.downcase == name\n  }\n  function(:nameAvailable, { name: :string }, :public, :view, returns: :bool) {\n    tokenId = s.nameToTokenId[name]\n    if !_exists(tokenId)\n      return true\n    end\n    s.tokenExpiryTimes[tokenId] + s.gracePeriod < block.timestamp\n  }\n  function(:getPrice, { name: :string, durationInSeconds: :uint256 }, :public, :view, returns: :uint256) {\n    len = name.length\n    priceWeiCentsPerSecond = if len >= s.charCountToUsdWeiCentsPrice.length\n      s.charCountToUsdWeiCentsPrice.last\n    else\n      s.charCountToUsdWeiCentsPrice[len - 1]\n    end\n    totalPriceWeiCents = priceWeiCentsPerSecond * durationInSeconds\n    (totalPriceWeiCents * 1.ether).div(s.usdWeiCentsInOneEth)\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:setUsdWeiCentsInOneEth, { rate: :uint256 }, :public) {\n    onlyOwner!\n    s.usdWeiCentsInOneEth=rate\n    emit(:ConversionRateUpdate, newRate: rate)\n  }\n  function(:withdrawWETH, :public, returns: :bool) {\n    onlyOwner!\n    amount = ERC20(s.WETH).balanceOf(address(this))\n    ERC20(s.WETH).transfer(s.owner, amount)\n  }\n  function(:setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :public) {\n    onlyOwner!\n    _setDefaultRoyalty(receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:deleteDefaultRoyalty, :public) {\n    onlyOwner!\n    _deleteDefaultRoyalty\n  }\n  function(:setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :public) {\n    onlyOwner!\n    _setTokenRoyalty(tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:deleteTokenRoyalty, { tokenId: :uint256 }, :public) {\n    onlyOwner!\n    _deleteTokenRoyalty(tokenId)\n  }\n  function(:totalSupply, :public, :view, returns: :uint256) {\n    nextTokenId - 1\n  }\n}\n",
    "init_code_hash": "0xe46dfedf0c0e9a0985d5151f5844bea96e5ac147cd9ddc7daa22a0899659d2f5",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC2981",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\n",
        "init_code_hash": "0xc25feb0d950d0fa605e6acd6a7b91c21ec886e57ee132177cf9856bb5f00a9fb"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "NameRegistryRenderer01",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:NameRegistryRenderer01, abstract: true) {\n  string(:public, :cardTemplate)\n  event(:StickerCreated, { stickerId: :uint256, name: :string, description: :string, imageURI: :string, stickerExpiry: :uint256, grantingAddress: :address })\n  event(:StickerClaimed, { stickerId: :uint256, claimer: :address })\n  event(:StickerPlaced, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) })\n  event(:StickerRepositioned, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) })\n  event(:CardDetailsSet, { tokenId: :uint256, displayName: :string, bio: :string, imageURI: :string, links: [:string] })\n  mapping(({ uint256: :string }), :public, :cardDisplayNames)\n  mapping(({ uint256: :string }), :public, :cardBios)\n  mapping(({ uint256: :string }), :public, :cardImageURIs)\n  mapping(({ uint256: [:string] }), :public, :cardLinks)\n  uint256(:public, :nextStickerId)\n  mapping(({ uint256: :address }), :public, :stickerIdToSigner)\n  mapping(({ uint256: :string }), :public, :stickerIdToName)\n  mapping(({ uint256: :string }), :public, :stickerIdToDescription)\n  mapping(({ uint256: :string }), :public, :stickerIdToImageURI)\n  mapping(({ uint256: :uint256 }), :public, :stickerIdToExpiry)\n  mapping(({ address: [:uint256] }), :public, :userToStickerAry)\n  mapping(({ address: mapping(uint256: :bool) }), :public, :userToStickerIdsAwardedMap)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerIdsAry)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerXPositionsAry)\n  mapping(({ uint256: [:uint256] }), :public, :tokenIdToStickerYPositionsAry)\n  mapping(({ uint256: mapping(uint256: :bool) }), :public, :tokenIdToStickerIdsPlacedMap)\n  uint256(:public, :maxStickersPerUser)\n  uint256(:public, :maxStickersPerCard)\n  uint256(:public, :maxLinksPerCard)\n  uint256(:public, :bioMaxLength)\n  uint256(:public, :displayNameMaxLength)\n  uint256(:public, :uriMaxLength)\n  constructor(cardTemplate: :string) {\n    s.maxStickersPerUser=25\n    s.maxStickersPerCard=s.maxStickersPerUser\n    s.maxLinksPerCard=5\n    s.bioMaxLength=1000\n    s.displayNameMaxLength=100\n    s.uriMaxLength=96000\n    require(cardTemplate.length <= s.uriMaxLength, \"cardTemplate too long\")\n    s.cardTemplate=cardTemplate\n  }\n  function(:renderCard, { tokenId: :uint256 }, :public, :view, returns: :string) {\n    enforceNotExpired!(tokenId)\n    owner = ownerOf(tokenId)\n    name = s.tokenIdToName[tokenId]\n    (stickerIds, stickerXPositions, stickerYPositions, stickerImageURIs) = getCardStickers(tokenId)\n    (displayName, bio, imageURI, links) = getCardDetails(tokenId)\n    storage = json.stringify(tokenId: tokenId.toString, owner: owner, name: name, stickerIds: stickerIds, stickerXPositions: stickerXPositions, stickerYPositions: stickerYPositions, stickerImages: stickerImageURIs, displayName: displayName, bio: bio, imageURI: imageURI, links: links)\n    template = \"`#{s.cardTemplate}`\"\n    wrapped = <<-HEREDOC\n<script>\n  window.s = #{storage};\n  document.open();\n  document.write(#{template});\n  document.close();\n</script>\n    HEREDOC\n  }\n  function(:createSticker, { name: :string, description: :string, imageURI: :string, stickerExpiry: :uint256, grantingAddress: :address }, :public) {\n    whenNotPaused!\n    require(name.length > 0, \"Name must be non-empty\")\n    require(name.length <= s.displayNameMaxLength, \"Name too long\")\n    require(description.length <= s.bioMaxLength, \"description too long\")\n    require(imageURI.length <= s.uriMaxLength, \"imageURI too long\")\n    require(grantingAddress != address(0), \"Granting address must be non-zero\")\n    currentId = s.nextStickerId\n    s.nextStickerId += 1\n    s.stickerIdToName[currentId] = name\n    s.stickerIdToImageURI[currentId] = imageURI\n    s.stickerIdToDescription[currentId] = description\n    s.stickerIdToExpiry[currentId] = stickerExpiry\n    s.stickerIdToSigner[currentId] = grantingAddress\n    emit(:StickerCreated, stickerId: currentId, name: name, description: description, imageURI: imageURI, stickerExpiry: stickerExpiry, grantingAddress: grantingAddress)\n  }\n  function(:claimSticker, { stickerId: :uint256, deadline: :uint256, tokenId: :uint256, position: array(:uint256, 2), signature: :bytes }, :public) {\n    whenNotPaused!\n    require(!s.userToStickerIdsAwardedMap[msg.sender][stickerId], \"Sticker already awarded\")\n    require(s.userToStickerAry[msg.sender].length < s.maxStickersPerUser, \"Too many stickers\")\n    require(deadline > block.timestamp, \"Deadline passed\")\n    require(s.stickerIdToExpiry[stickerId] > block.timestamp, \"Sticker expired\")\n    signatureValid = signature.verifyTypedDataSignature({ StickerClaim: [{ name: \"stickerId\", type: \"uint256\" }, { name: \"claimer\", type: \"address\" }, { name: \"deadline\", type: \"uint256\" }] }, { stickerId: stickerId, claimer: msg.sender, deadline: deadline }, verifyingContract: address(this), domainName: s.name, domainVersion: \"1\", signer: s.stickerIdToSigner[stickerId])\n    require(signatureValid, \"Invalid signature\")\n    s.userToStickerIdsAwardedMap[msg.sender][stickerId] = true\n    s.userToStickerAry[msg.sender].push(stickerId)\n    if tokenId != 0\n      placeSticker(stickerId, tokenId, position)\n    end\n    emit(:StickerClaimed, stickerId: stickerId, claimer: msg.sender)\n  }\n  function(:placeSticker, { stickerId: :uint256, tokenId: :uint256, position: array(:uint256, 2) }, :public) {\n    whenNotPaused!\n    enforceNotExpired!(tokenId)\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    require(s.userToStickerIdsAwardedMap[msg.sender][stickerId], \"Sticker not claimed\")\n    require(!s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId], \"Sticker already placed\")\n    require(s.tokenIdToStickerIdsAry[tokenId].length < s.maxStickersPerCard, \"Too many stickers\")\n    s.tokenIdToStickerIdsAry[tokenId].push(stickerId)\n    s.tokenIdToStickerXPositionsAry[tokenId].push(position[0])\n    s.tokenIdToStickerYPositionsAry[tokenId].push(position[1])\n    s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId] = true\n    emit(:StickerPlaced, stickerId: stickerId, tokenId: tokenId, position: position)\n  }\n  function(:repositionSticker, { stickerIndex: :uint256, tokenId: :uint256, position: array(:uint256, 2) }, :public) {\n    whenNotPaused!\n    enforceNotExpired!(tokenId)\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    stickerId = s.tokenIdToStickerIdsAry[tokenId][stickerIndex]\n    require(s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId], \"Sticker not placed\")\n    s.tokenIdToStickerXPositionsAry[tokenId][stickerIndex] = position[0]\n    s.tokenIdToStickerYPositionsAry[tokenId][stickerIndex] = position[1]\n    emit(:StickerRepositioned, stickerId: stickerId, tokenId: tokenId, position: position)\n  }\n  function(:setCardDetails, { tokenId: :uint256, displayName: :string, bio: :string, imageURI: :string, links: [:string] }, :public) {\n    whenNotPaused!\n    require(ownerOf(tokenId) == msg.sender, \"Not the owner\")\n    require(links.length <= s.maxLinksPerCard, \"Too many links\")\n    require(bio.length <= s.bioMaxLength, \"Bio too long\")\n    require(displayName.length <= s.displayNameMaxLength, \"Display name too long\")\n    require(imageURI.length <= s.uriMaxLength, \"imageURI too long\")\n    s.cardDisplayNames[tokenId] = displayName\n    s.cardBios[tokenId] = bio\n    s.cardImageURIs[tokenId] = imageURI\n    s.cardLinks[tokenId] = links\n    emit(:CardDetailsSet, tokenId: tokenId, displayName: displayName, bio: bio, imageURI: imageURI, links: links)\n  }\n  function(:getCardDetails, { tokenId: :uint256 }, :public, :view, returns: { displayName: :string, bio: :string, imageURI: :string, links: [:string] }) {\n    enforceNotExpired!(tokenId)\n    return { displayName: s.cardDisplayNames[tokenId], bio: s.cardBios[tokenId], imageURI: s.cardImageURIs[tokenId], links: s.cardLinks[tokenId] }\n  }\n  function(:getCardStickers, { tokenId: :uint256 }, :public, :view, returns: { stickerIds: [:uint256], stickerXPositions: [:uint256], stickerYPositions: [:uint256], stickerImageURIs: [:string] }) {\n    enforceNotExpired!(tokenId)\n    stickerIds = array(:uint256, 0)\n    stickerXPositions = array(:uint256, 0)\n    stickerYPositions = array(:uint256, 0)\n    stickerImageURIs = array(:string, 0)\n    forLoop(condition: ->(i) {\n      i < s.tokenIdToStickerIdsAry[tokenId].length\n    }) { |i|\n      stickerId = s.tokenIdToStickerIdsAry[tokenId][i]\n      if (s.stickerIdToExpiry[stickerId] > block.timestamp)\n        stickerIds.push(stickerId)\n        stickerXPositions.push(s.tokenIdToStickerXPositionsAry[tokenId][i])\n        stickerYPositions.push(s.tokenIdToStickerYPositionsAry[tokenId][i])\n        stickerImageURIs.push(s.stickerIdToImageURI[stickerId])\n      end\n    }\n    return { stickerIds: stickerIds, stickerXPositions: stickerXPositions, stickerYPositions: stickerYPositions, stickerImageURIs: stickerImageURIs }\n  }\n  function(:updateCardTemplate, { cardTemplate: :string }, :public) {\n    onlyOwner!\n    s.cardTemplate=cardTemplate\n    return nil\n  }\n  function(:_clearCardPersonalInfo, { tokenId: :uint256 }, :internal) {\n    _clearCardDetails(tokenId)\n    _clearStickers(tokenId)\n  }\n  function(:_clearCardDetails, { tokenId: :uint256 }, :internal) {\n    s.cardDisplayNames[tokenId] = \"\"\n    s.cardBios[tokenId] = \"\"\n    s.cardImageURIs[tokenId] = \"\"\n    s.cardLinks[tokenId] = array(:string, 0)\n    nil\n  }\n  function(:_clearStickers, { tokenId: :uint256 }, :internal) {\n    forLoop(condition: ->(i) {\n      i < s.tokenIdToStickerIdsAry[tokenId].length\n    }) { |i|\n      stickerId = s.tokenIdToStickerIdsAry[tokenId][i]\n      s.tokenIdToStickerIdsPlacedMap[tokenId][stickerId] = false\n    }\n    s.tokenIdToStickerIdsAry[tokenId] = array(:uint256, 0)\n    s.tokenIdToStickerXPositionsAry[tokenId] = array(:uint256, 0)\n    s.tokenIdToStickerYPositionsAry[tokenId] = array(:uint256, 0)\n    nil\n  }\n}\n",
        "init_code_hash": "0x55490443919fb78d575c314ec6bac0625fa14f540deec581d9baf063016af9c1"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T08:43:07.375Z",
    "updated_at": "2024-02-13T08:43:07.375Z"
  },
  {
    "id": 15,
    "transaction_hash": "0xfae79f1399e1b76151d0a96a0107acabb76d23de0b86885d831c371757ae01ac",
    "internal_transaction_index": 0,
    "block_number": 19000384,
    "transaction_index": 107,
    "name": "FacetPortV1",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetPortV1, is: [:Upgradeable, :Ownable, :Pausable], upgradeable: true) {\n  event(:OfferAccepted, { success: :bool, offerType: :string, offerer: :address, buyer: :address, seller: :address, assetContract: :address, assetId: :uint256, considerationAmount: :uint256, considerationToken: :address, offerId: :bytes16 })\n  event(:OfferCancelled, { offerer: :address, offerId: :bytes16 })\n  event(:AllOffersOnAssetCancelledForUser, { offerType: :string, offerer: :address, assetContract: :address, assetId: :uint256 })\n  event(:AllOffersCancelledForUser, { offerType: :string, offerer: :address })\n  mapping(({ address: mapping(bytes16: :bool) }), :public, :userOfferCancellations)\n  mapping(({ string: mapping(address: mapping(address: mapping(uint256: :uint256))) }), :public, :userOffersOnAssetValidAfterTime)\n  mapping(({ string: mapping(address: :uint256) }), :public, :userOffersValidAfterTime)\n  uint96(:feeBps)\n  constructor(_feeBps: :uint96, _upgradeAdmin: :address, _owner: :address) {\n    s.feeBps=_feeBps\n    self.Upgradeable.constructor(upgradeAdmin: _upgradeAdmin)\n    self.Ownable.constructor(owner: _owner)\n    _pause\n  }\n  function(:setFeeBps, { _feeBps: :uint96 }, :external) {\n    onlyOwner!\n    s.feeBps=_feeBps\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:acceptOfferWithSignature, { offerType: :string, offerId: :bytes16, offerer: :address, assetContract: :address, assetId: :uint256, assetType: :string, assetAmount: :uint256, considerationToken: :address, considerationAmount: :uint256, startTime: :uint256, endTime: :uint256, signature: :bytes }, :external) {\n    success = _acceptOfferWithSignature(offerType: offerType, offerId: offerId, offerer: offerer, assetContract: assetContract, assetId: assetId, assetType: assetType, assetAmount: assetAmount, considerationToken: considerationToken, considerationAmount: considerationAmount, startTime: startTime, endTime: endTime, signature: signature)\n    require(success, \"Offer was not successfully accepted\")\n  }\n  function(:acceptMultipleOffersWithSignatures, { offerTypes: [:string], offerIds: [:bytes16], offerers: [:address], assetContracts: [:address], assetIds: [:uint256], assetTypes: [:string], assetAmounts: [:uint256], considerationTokens: [:address], considerationAmounts: [:uint256], startTimes: [:uint256], endTimes: [:uint256], signatures: [:bytes] }, :external) {\n    require(offerIds.length == offerers.length, \"Offer ID and offerer arrays must be the same length\")\n    require(offerIds.length == offerTypes.length, \"Offer ID and offer types arrays must be the same length\")\n    require(offerIds.length == assetContracts.length, \"Offer ID and asset contracts arrays must be the same length\")\n    require(offerIds.length == assetIds.length, \"Offer ID and asset IDs arrays must be the same length\")\n    require(offerIds.length == assetTypes.length, \"Offer ID and assetTypes arrays must be the same length\")\n    require(offerIds.length == assetAmounts.length, \"Offer ID and assetAmounts arrays must be the same length\")\n    require(offerIds.length == considerationTokens.length, \"Offer ID and consideration tokens arrays must be the same length\")\n    require(offerIds.length == considerationAmounts.length, \"Offer ID and consideration amounts arrays must be the same length\")\n    require(offerIds.length == startTimes.length, \"Offer ID and start times arrays must be the same length\")\n    require(offerIds.length == endTimes.length, \"Offer ID and end times arrays must be the same length\")\n    require(offerIds.length == signatures.length, \"Offer ID and signatures arrays must be the same length\")\n    require(offerIds.length <= 20, \"Cannot accept more than 20 offers at a time\")\n    atLeastOneSuccess = false\n    forLoop(condition: ->(i) {\n      i < offerIds.length\n    }) { |i|\n      success = _acceptOfferWithSignature(offerType: offerTypes[i], offerId: offerIds[i], offerer: offerers[i], assetContract: assetContracts[i], assetId: assetIds[i], assetType: assetTypes[i], assetAmount: assetAmounts[i], considerationToken: considerationTokens[i], considerationAmount: considerationAmounts[i], startTime: startTimes[i], endTime: endTimes[i], signature: signatures[i])\n      if success\n        atLeastOneSuccess = true\n      end\n    }\n    require(atLeastOneSuccess, \"No offers were successfully accepted\")\n  }\n  function(:_acceptOfferWithSignature, { offerType: :string, offerId: :bytes16, offerer: :address, assetContract: :address, assetId: :uint256, assetType: :string, assetAmount: :uint256, considerationToken: :address, considerationAmount: :uint256, startTime: :uint256, endTime: :uint256, signature: :bytes }, :internal, returns: :bool) {\n    whenNotPaused!\n    signatureValid = signature.verifyTypedDataSignature({ Offer: [{ name: \"offerType\", type: \"string\" }, { name: \"offerId\", type: \"bytes16\" }, { name: \"offerer\", type: \"address\" }, { name: \"assetContract\", type: \"address\" }, { name: \"assetId\", type: \"uint256\" }, { name: \"assetType\", type: \"string\" }, { name: \"assetAmount\", type: \"uint256\" }, { name: \"considerationToken\", type: \"address\" }, { name: \"considerationAmount\", type: \"uint256\" }, { name: \"startTime\", type: \"uint256\" }, { name: \"endTime\", type: \"uint256\" }] }, { offerType: offerType, offerId: offerId, offerer: offerer, assetContract: assetContract, assetId: assetId, assetType: assetType, assetAmount: assetAmount, considerationToken: considerationToken, considerationAmount: considerationAmount, startTime: startTime, endTime: endTime }, verifyingContract: address(this), domainName: \"FacetPort\", domainVersion: \"1\", signer: offerer)\n    require(signatureValid, \"Invalid signature\")\n    require(!s.userOfferCancellations[offerer][offerId], \"Offer cancelled\")\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    require(assetType == \"ERC721\" && assetAmount == 1, \"Only ERC721 assets are supported\")\n    require(block.timestamp >= startTime, \"Current time is before the start time\")\n    require(block.timestamp < endTime, \"Current time is after the end time\")\n    require(startTime > s.userOffersOnAssetValidAfterTime[offerType][offerer][assetContract][assetId], \"Start time is before the offerer's valid after time\")\n    require(startTime > s.userOffersValidAfterTime[offerType][offerer], \"Start time is before the valid after time for the offerer\")\n    (buyer, seller) = if offerType == \"Bid\"\n      [offerer, msg.sender]\n    else\n      [msg.sender, offerer]\n    end\n    transferSucceeded = _payRoyaltiesAndTransfer(assetContract: assetContract, assetId: assetId, seller: seller, buyer: buyer, considerationAmount: considerationAmount, considerationToken: considerationToken)\n    emit(:OfferAccepted, { success: transferSucceeded, offerType: offerType, offerer: offerer, buyer: buyer, seller: seller, assetContract: assetContract, assetId: assetId, considerationAmount: considerationAmount, considerationToken: considerationToken, offerId: offerId })\n    transferSucceeded\n  }\n  function(:_payRoyaltiesAndTransfer, { assetContract: :address, assetId: :uint256, seller: :address, buyer: :address, considerationAmount: :uint256, considerationToken: :address }, :internal, returns: :bool) {\n    currentOwner = ERC721(assetContract).ownerOf(assetId)\n    unless currentOwner == seller\n      return false\n    end\n    (success, data) = assetContract.call(function: \"supportsERC2981\")\n    royaltyAmount = 0\n    if success && data == \"true\"\n      (receiver, royaltyAmount) = ERC2981(assetContract).royaltyInfo(tokenId: assetId, salePrice: considerationAmount)\n      ERC20(considerationToken).transferFrom(from: buyer, to: receiver, amount: royaltyAmount)\n    end\n    sellerAmount = considerationAmount - royaltyAmount - computeFee(considerationAmount)\n    ERC20(considerationToken).transferFrom(from: buyer, to: seller, amount: sellerAmount)\n    ERC20(considerationToken).transferFrom(from: buyer, to: owner, amount: computeFee(considerationAmount))\n    _transferNFT(assetContract: assetContract, assetId: assetId, recipient: buyer, from: seller)\n    return true\n  }\n  function(:transferNFTs, { assetContracts: [:address], assetIds: [:uint256], recipients: [:address] }, :external) {\n    require(assetContracts.length == assetIds.length, \"Asset contracts and asset IDs must be the same length\")\n    require(assetContracts.length == recipients.length, \"Asset contracts and recipients must be the same length\")\n    require(assetIds.length <= 20, \"Cannot transfer more than 20 NFTs at a time\")\n    forLoop(condition: ->(i) {\n      i < recipients.length\n    }) { |i|\n      _transferNFT(assetContract: assetContracts[i], assetId: assetIds[i], recipient: recipients[i], from: msg.sender)\n    }\n  }\n  function(:_transferNFT, { assetContract: :address, assetId: :uint256, recipient: :address, from: :address }, :internal) {\n    whenNotPaused!\n    ERC721(assetContract).transferFrom(from: from, to: recipient, id: assetId)\n    s.userOffersOnAssetValidAfterTime[\"Listing\"][from][assetContract][assetId] = block.timestamp\n    s.userOffersOnAssetValidAfterTime[\"Bid\"][recipient][assetContract][assetId] = block.timestamp\n    nil\n  }\n  function(:cancelOffer, { offerId: :bytes16 }, :external) {\n    s.userOfferCancellations[msg.sender][offerId] = true\n    emit(:OfferCancelled, offerer: msg.sender, offerId: offerId)\n  }\n  function(:cancelAllOffersForAsset, { offerType: :string, assetContract: :address, assetId: :uint256 }, :external) {\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    s.userOffersOnAssetValidAfterTime[offerType][msg.sender][assetContract][assetId] = block.timestamp\n    emit(:AllOffersOnAssetCancelledForUser, offerType: offerType, offerer: msg.sender, assetContract: assetContract, assetId: assetId)\n  }\n  function(:cancelAllOffersOfUser, { offerType: :string }, :external) {\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    s.userOffersValidAfterTime[offerType][msg.sender] = block.timestamp\n    emit(:AllOffersCancelledForUser, offerType: offerType, offerer: msg.sender)\n  }\n  function(:computeFee, { amount: :uint256 }, :public, :view, returns: :uint256) {\n    return (amount * s.feeBps).div(10000)\n  }\n}\n",
    "init_code_hash": "0x1501ed4ad6aca064f58d45bac7b4f3e0c0bf1a2cc4769a3ec54f4948dca13ee3",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC2981",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\n",
        "init_code_hash": "0xc25feb0d950d0fa605e6acd6a7b91c21ec886e57ee132177cf9856bb5f00a9fb"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T08:43:08.046Z",
    "updated_at": "2024-02-13T08:43:08.046Z"
  },
  {
    "id": 16,
    "transaction_hash": "0x7a825dded5040b95bf2a79484ba66dc60efde9de65f1f899d8726d87350d0a4c",
    "internal_transaction_index": 0,
    "block_number": 19000776,
    "transaction_index": 51,
    "name": "FacetPortV101",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetPortV101, is: [:Upgradeable, :Ownable, :Pausable], upgradeable: true) {\n  event(:OfferAccepted, { success: :bool, offerType: :string, offerer: :address, buyer: :address, seller: :address, assetContract: :address, assetId: :uint256, considerationAmount: :uint256, considerationToken: :address, offerId: :bytes16 })\n  event(:OfferCancelled, { offerer: :address, offerId: :bytes16 })\n  event(:AllOffersOnAssetCancelledForUser, { offerType: :string, offerer: :address, assetContract: :address, assetId: :uint256 })\n  event(:AllOffersCancelledForUser, { offerType: :string, offerer: :address })\n  mapping(({ address: mapping(bytes16: :bool) }), :public, :userOfferCancellations)\n  mapping(({ string: mapping(address: mapping(address: mapping(uint256: :uint256))) }), :public, :userOffersOnAssetValidAfterTime)\n  mapping(({ string: mapping(address: :uint256) }), :public, :userOffersValidAfterTime)\n  uint96(:feeBps)\n  constructor(_feeBps: :uint96, _upgradeAdmin: :address, _owner: :address) {\n    s.feeBps=_feeBps\n    self.Upgradeable.constructor(upgradeAdmin: _upgradeAdmin)\n    self.Ownable.constructor(owner: _owner)\n    _pause\n  }\n  function(:setFeeBps, { _feeBps: :uint96 }, :external) {\n    onlyOwner!\n    s.feeBps=_feeBps\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:acceptOfferWithSignature, { offerType: :string, offerId: :bytes16, offerer: :address, assetContract: :address, assetId: :uint256, assetType: :string, assetAmount: :uint256, considerationToken: :address, considerationAmount: :uint256, startTime: :uint256, endTime: :uint256, signature: :bytes }, :external) {\n    success = _acceptOfferWithSignature(offerType: offerType, offerId: offerId, offerer: offerer, assetContract: assetContract, assetId: assetId, assetType: assetType, assetAmount: assetAmount, considerationToken: considerationToken, considerationAmount: considerationAmount, startTime: startTime, endTime: endTime, signature: signature)\n    require(success, \"Offer was not successfully accepted\")\n  }\n  function(:acceptMultipleOffersWithSignatures, { offerTypes: [:string], offerIds: [:bytes16], offerers: [:address], assetContracts: [:address], assetIds: [:uint256], assetTypes: [:string], assetAmounts: [:uint256], considerationTokens: [:address], considerationAmounts: [:uint256], startTimes: [:uint256], endTimes: [:uint256], signatures: [:bytes] }, :external) {\n    require(offerIds.length == offerers.length, \"Offer ID and offerer arrays must be the same length\")\n    require(offerIds.length == offerTypes.length, \"Offer ID and offer types arrays must be the same length\")\n    require(offerIds.length == assetContracts.length, \"Offer ID and asset contracts arrays must be the same length\")\n    require(offerIds.length == assetIds.length, \"Offer ID and asset IDs arrays must be the same length\")\n    require(offerIds.length == assetTypes.length, \"Offer ID and assetTypes arrays must be the same length\")\n    require(offerIds.length == assetAmounts.length, \"Offer ID and assetAmounts arrays must be the same length\")\n    require(offerIds.length == considerationTokens.length, \"Offer ID and consideration tokens arrays must be the same length\")\n    require(offerIds.length == considerationAmounts.length, \"Offer ID and consideration amounts arrays must be the same length\")\n    require(offerIds.length == startTimes.length, \"Offer ID and start times arrays must be the same length\")\n    require(offerIds.length == endTimes.length, \"Offer ID and end times arrays must be the same length\")\n    require(offerIds.length == signatures.length, \"Offer ID and signatures arrays must be the same length\")\n    require(offerIds.length <= 20, \"Cannot accept more than 20 offers at a time\")\n    atLeastOneSuccess = false\n    forLoop(condition: ->(i) {\n      i < offerIds.length\n    }) { |i|\n      success = _acceptOfferWithSignature(offerType: offerTypes[i], offerId: offerIds[i], offerer: offerers[i], assetContract: assetContracts[i], assetId: assetIds[i], assetType: assetTypes[i], assetAmount: assetAmounts[i], considerationToken: considerationTokens[i], considerationAmount: considerationAmounts[i], startTime: startTimes[i], endTime: endTimes[i], signature: signatures[i])\n      if success\n        atLeastOneSuccess = true\n      end\n    }\n    require(atLeastOneSuccess, \"No offers were successfully accepted\")\n  }\n  function(:_acceptOfferWithSignature, { offerType: :string, offerId: :bytes16, offerer: :address, assetContract: :address, assetId: :uint256, assetType: :string, assetAmount: :uint256, considerationToken: :address, considerationAmount: :uint256, startTime: :uint256, endTime: :uint256, signature: :bytes }, :internal, returns: :bool) {\n    whenNotPaused!\n    signatureValid = signature.verifyTypedDataSignature({ Offer: [{ name: \"offerType\", type: \"string\" }, { name: \"offerId\", type: \"bytes16\" }, { name: \"offerer\", type: \"address\" }, { name: \"assetContract\", type: \"address\" }, { name: \"assetId\", type: \"uint256\" }, { name: \"assetType\", type: \"string\" }, { name: \"assetAmount\", type: \"uint256\" }, { name: \"considerationToken\", type: \"address\" }, { name: \"considerationAmount\", type: \"uint256\" }, { name: \"startTime\", type: \"uint256\" }, { name: \"endTime\", type: \"uint256\" }] }, { offerType: offerType, offerId: offerId, offerer: offerer, assetContract: assetContract, assetId: assetId, assetType: assetType, assetAmount: assetAmount, considerationToken: considerationToken, considerationAmount: considerationAmount, startTime: startTime, endTime: endTime }, verifyingContract: address(this), domainName: \"FacetPort\", domainVersion: \"1\", signer: offerer)\n    require(signatureValid, \"Invalid signature\")\n    require(!s.userOfferCancellations[offerer][offerId], \"Offer cancelled\")\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    require(assetType == \"ERC721\" && assetAmount == 1, \"Only ERC721 assets are supported\")\n    require(block.timestamp >= startTime, \"Current time is before the start time\")\n    require(block.timestamp < endTime, \"Current time is after the end time\")\n    require(startTime > s.userOffersOnAssetValidAfterTime[offerType][offerer][assetContract][assetId], \"Start time is before the offerer's valid after time\")\n    require(startTime > s.userOffersValidAfterTime[offerType][offerer], \"Start time is before the valid after time for the offerer\")\n    (buyer, seller) = if offerType == \"Bid\"\n      [offerer, msg.sender]\n    else\n      [msg.sender, offerer]\n    end\n    transferSucceeded = _payRoyaltiesAndTransfer(assetContract: assetContract, assetId: assetId, seller: seller, buyer: buyer, considerationAmount: considerationAmount, considerationToken: considerationToken)\n    emit(:OfferAccepted, { success: transferSucceeded, offerType: offerType, offerer: offerer, buyer: buyer, seller: seller, assetContract: assetContract, assetId: assetId, considerationAmount: considerationAmount, considerationToken: considerationToken, offerId: offerId })\n    transferSucceeded\n  }\n  function(:_payRoyaltiesAndTransfer, { assetContract: :address, assetId: :uint256, seller: :address, buyer: :address, considerationAmount: :uint256, considerationToken: :address }, :internal, returns: :bool) {\n    currentOwner = ERC721(assetContract).ownerOf(assetId)\n    unless currentOwner == seller\n      return false\n    end\n    (success, data) = assetContract.call(function: \"supportsERC2981\")\n    royaltyAmount = 0\n    if success && data == \"true\"\n      (receiver, royaltyAmount) = ERC2981(assetContract).royaltyInfo(tokenId: assetId, salePrice: considerationAmount)\n      if receiver == address(0)\n        royaltyAmount = 0\n      end\n      if royaltyAmount > 0\n        ERC20(considerationToken).transferFrom(from: buyer, to: receiver, amount: royaltyAmount)\n      end\n    end\n    marketplaceFee = computeFee(considerationAmount)\n    sellerAmount = considerationAmount - royaltyAmount - marketplaceFee\n    if sellerAmount > 0\n      ERC20(considerationToken).transferFrom(from: buyer, to: seller, amount: sellerAmount)\n    end\n    if marketplaceFee > 0\n      ERC20(considerationToken).transferFrom(from: buyer, to: owner, amount: marketplaceFee)\n    end\n    _transferNFT(assetContract: assetContract, assetId: assetId, recipient: buyer, from: seller)\n    return true\n  }\n  function(:transferNFTs, { assetContracts: [:address], assetIds: [:uint256], recipients: [:address] }, :external) {\n    require(assetContracts.length == assetIds.length, \"Asset contracts and asset IDs must be the same length\")\n    require(assetContracts.length == recipients.length, \"Asset contracts and recipients must be the same length\")\n    require(assetIds.length <= 20, \"Cannot transfer more than 20 NFTs at a time\")\n    forLoop(condition: ->(i) {\n      i < recipients.length\n    }) { |i|\n      _transferNFT(assetContract: assetContracts[i], assetId: assetIds[i], recipient: recipients[i], from: msg.sender)\n    }\n  }\n  function(:_transferNFT, { assetContract: :address, assetId: :uint256, recipient: :address, from: :address }, :internal) {\n    whenNotPaused!\n    ERC721(assetContract).transferFrom(from: from, to: recipient, id: assetId)\n    s.userOffersOnAssetValidAfterTime[\"Listing\"][from][assetContract][assetId] = block.timestamp\n    s.userOffersOnAssetValidAfterTime[\"Bid\"][recipient][assetContract][assetId] = block.timestamp\n    nil\n  }\n  function(:cancelOffer, { offerId: :bytes16 }, :external) {\n    s.userOfferCancellations[msg.sender][offerId] = true\n    emit(:OfferCancelled, offerer: msg.sender, offerId: offerId)\n  }\n  function(:cancelAllOffersForAsset, { offerType: :string, assetContract: :address, assetId: :uint256 }, :external) {\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    s.userOffersOnAssetValidAfterTime[offerType][msg.sender][assetContract][assetId] = block.timestamp\n    emit(:AllOffersOnAssetCancelledForUser, offerType: offerType, offerer: msg.sender, assetContract: assetContract, assetId: assetId)\n  }\n  function(:cancelAllOffersOfUser, { offerType: :string }, :external) {\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    s.userOffersValidAfterTime[offerType][msg.sender] = block.timestamp\n    emit(:AllOffersCancelledForUser, offerType: offerType, offerer: msg.sender)\n  }\n  function(:computeFee, { amount: :uint256 }, :public, :view, returns: :uint256) {\n    return (amount * s.feeBps).div(10000)\n  }\n}\n",
    "init_code_hash": "0xe8634b38f8d80d7815631734a17f86ce3c867a3d38fa65e46f9eeebe9eec127b",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC2981",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\n",
        "init_code_hash": "0xc25feb0d950d0fa605e6acd6a7b91c21ec886e57ee132177cf9856bb5f00a9fb"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T08:43:31.083Z",
    "updated_at": "2024-02-13T08:43:31.083Z"
  },
  {
    "id": 17,
    "transaction_hash": "0xb1bbd7f86b2e1bb76e66115c84120c2474332b685babdbe11f0cadd7f60ee010",
    "internal_transaction_index": 0,
    "block_number": 19072405,
    "transaction_index": 89,
    "name": "EthscriptionERC20Bridge03",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:EthscriptionERC20Bridge03, is: [:ERC20, :Ownable, :Upgradeable, :Pausable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  uint256(:public, :bridgeLimit)\n  uint256(:public, :mintAmount)\n  address(:public, :trustedSmartContract)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(name: :string, symbol: :string, mintAmount: :uint256, trustedSmartContract: :address, bridgeLimit: :uint256, initialPauseState: :bool) {\n    require(mintAmount > 0, \"Invalid mint amount\")\n    require(trustedSmartContract != address(0), \"Invalid smart contract\")\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: 18)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: msg.sender)\n    self.Pausable.constructor(initialPauseState: initialPauseState)\n    s.mintAmount=mintAmount\n    s.trustedSmartContract=trustedSmartContract\n    s.bridgeLimit=bridgeLimit\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can bridge in tokens\")\n    _mint(to: to, amount: amount * s.mintAmount * 1.ether)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeOut, { amount: :uint256 }, :public) {\n    whenNotPaused!\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[msg.sender] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(amount > 0, \"Invalid amount\")\n    require(s.bridgeLimit > 0 && amount <= s.bridgeLimit, \"Amount is too large\")\n    s.userWithdrawalId[msg.sender] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    _burn(from: msg.sender, amount: amount * s.mintAmount * 1.ether)\n    emit(:InitiateWithdrawal, from: msg.sender, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can mark withdrawals as complete\")\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:onUpgrade, { owner: :address, bridgeLimit: :uint256 }, :public) {\n    require(msg.sender == address(this), \"Only the contract itself can upgrade\")\n    s.owner=owner\n    s.bridgeLimit=bridgeLimit\n    return nil\n  }\n  function(:setBridgeLimit, { bridgeLimit: :uint256 }, :public) {\n    onlyOwner!\n    s.bridgeLimit=bridgeLimit\n    return nil\n  }\n  function(:updateTrustedSmartContract, { newTrustedSmartContract: :address }, :public) {\n    onlyOwner!\n    s.trustedSmartContract=newTrustedSmartContract\n    return nil\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n}\n",
    "init_code_hash": "0x6c5eee22f9574d847b4d90833da27228c6567cee2e004d4ccbb6a34011ab66e4",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-13T10:26:42.524Z",
    "updated_at": "2024-02-13T10:26:42.524Z"
  },
  {
    "id": 18,
    "transaction_hash": "0x731b261ba79557dca12b9e9bee4cf02eab351eec4d6a9bcee9f3222074f90fb2",
    "internal_transaction_index": 0,
    "block_number": 19227178,
    "transaction_index": 206,
    "name": "BridgeAndCallHelper",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:BridgeAndCallHelper, is: [:Upgradeable, :Ownable], upgradeable: true) {\n  event(:CallFromBridge, { bridgingUser: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, feeAmount: :uint256, resultStatus: :bool, resultData: :string })\n  event(:BridgeUpdated, { newBridge: :address })\n  event(:FeeUpdated, { newFee: :uint256 })\n  address(:public, :bridge)\n  uint256(:public, :fee)\n  bool(:locked)\n  constructor(bridge: :address, fee: :uint256, owner: :address) {\n    self.Ownable.constructor(owner: owner)\n    self.Upgradeable.constructor(upgradeAdmin: owner)\n    s.bridge=bridge\n    s.fee=fee\n  }\n  function(:setBridge, { newBridge: :address }, :public) {\n    onlyOwner!\n    s.bridge=newBridge\n    emit(:BridgeUpdated, newBridge: newBridge)\n  }\n  function(:setFee, { newFee: :uint256 }, :public) {\n    onlyOwner!\n    s.fee=newFee\n    emit(:FeeUpdated, newFee: newFee)\n  }\n  function(:callFromBridge, { bridgingUser: :address, addressToCall: :address, base64Calldata: :string }, :public) {\n    require(msg.sender == s.bridge, \"Only the bridge can callFromBridge\")\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    calldata = base64Calldata.base64Decode\n    initialBalance = _balance\n    calculatedFee = if initialBalance < s.fee\n      initialBalance\n    else\n      s.fee\n    end\n    if calculatedFee > 0\n      _transfer(s.owner, calculatedFee)\n    end\n    _approve(addressToCall, initialBalance - calculatedFee)\n    (success, data) = addressToCall.call(calldata)\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(bridgingUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallFromBridge, bridgingUser: bridgingUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, feeAmount: calculatedFee, resultStatus: success, resultData: data)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.bridge).transfer(to, amount)\n  }\n}\n",
    "init_code_hash": "0xfd29ff1ad62a78d7c552167b1417f900e3095bfc603b84849e36488ae3017c14",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-14T15:46:00.181Z",
    "updated_at": "2024-02-14T15:46:00.181Z"
  },
  {
    "id": 19,
    "transaction_hash": "0x887d7675b36e0f73b3efaa4a04d81d168c0098e5b62b52058e9626174eb0a311",
    "internal_transaction_index": 0,
    "block_number": 19227329,
    "transaction_index": 48,
    "name": "EtherBridge02",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:BridgeAndCallHelper, is: [:Upgradeable, :Ownable], upgradeable: true) {\n  event(:CallFromBridge, { bridgingUser: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, feeAmount: :uint256, resultStatus: :bool, resultData: :string })\n  event(:BridgeUpdated, { newBridge: :address })\n  event(:FeeUpdated, { newFee: :uint256 })\n  address(:public, :bridge)\n  uint256(:public, :fee)\n  bool(:locked)\n  constructor(bridge: :address, fee: :uint256, owner: :address) {\n    self.Ownable.constructor(owner: owner)\n    self.Upgradeable.constructor(upgradeAdmin: owner)\n    s.bridge=bridge\n    s.fee=fee\n  }\n  function(:setBridge, { newBridge: :address }, :public) {\n    onlyOwner!\n    s.bridge=newBridge\n    emit(:BridgeUpdated, newBridge: newBridge)\n  }\n  function(:setFee, { newFee: :uint256 }, :public) {\n    onlyOwner!\n    s.fee=newFee\n    emit(:FeeUpdated, newFee: newFee)\n  }\n  function(:callFromBridge, { bridgingUser: :address, addressToCall: :address, base64Calldata: :string }, :public) {\n    require(msg.sender == s.bridge, \"Only the bridge can callFromBridge\")\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    calldata = base64Calldata.base64Decode\n    initialBalance = _balance\n    calculatedFee = if initialBalance < s.fee\n      initialBalance\n    else\n      s.fee\n    end\n    if calculatedFee > 0\n      _transfer(s.owner, calculatedFee)\n    end\n    _approve(addressToCall, initialBalance - calculatedFee)\n    (success, data) = addressToCall.call(calldata)\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(bridgingUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallFromBridge, bridgingUser: bridgingUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, feeAmount: calculatedFee, resultStatus: success, resultData: data)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.bridge).transfer(to, amount)\n  }\n}\ncontract(:EtherBridge02, is: [:ERC20, :Upgradeable, :Ownable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  address(:public, :trustedSmartContract)\n  address(:public, :bridgeAndCallHelper)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(name: :string, symbol: :string, trustedSmartContract: :address, bridgeAndCallHelper: :address) {\n    require(trustedSmartContract != address(0), \"Invalid smart contract\")\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: 18)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: msg.sender)\n    s.trustedSmartContract=trustedSmartContract\n    s.bridgeAndCallHelper=bridgeAndCallHelper\n  }\n  function(:onUpgrade, { owner: :address, bridgeAndCallHelper: :address }, :public) {\n    require(msg.sender == address(this), \"Only the contract itself can upgrade\")\n    s.owner=owner\n    s.bridgeAndCallHelper=bridgeAndCallHelper\n    return nil\n  }\n  function(:setBridgeAndCallHelper, { bridgeAndCallHelper: :address }, :public) {\n    onlyOwner!\n    s.bridgeAndCallHelper=bridgeAndCallHelper\n    nil\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can bridge in tokens\")\n    _mint(to: to, amount: amount)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeAndCall, { to: :address, amount: :uint256, addressToCall: :address, base64Calldata: :string }, :public) {\n    if s.bridgeAndCallHelper == address(0)\n      return bridgeIn(to: to, amount: amount)\n    end\n    bridgeIn(to: s.bridgeAndCallHelper, amount: amount)\n    BridgeAndCallHelper(s.bridgeAndCallHelper).callFromBridge(bridgingUser: to, addressToCall: addressToCall, base64Calldata: base64Calldata)\n  }\n  function(:bridgeOut, { amount: :uint256 }, :public) {\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[msg.sender] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(amount > 0, \"Invalid amount\")\n    s.userWithdrawalId[msg.sender] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    _burn(from: msg.sender, amount: amount)\n    emit(:InitiateWithdrawal, from: msg.sender, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can mark withdrawals as complete\")\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n}\n",
    "init_code_hash": "0xf6165ed921e31487fd67838477eccf9c6e226d728e467f5bc8f8898864e290ee",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      },
      {
        "abi": null,
        "name": "BridgeAndCallHelper",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:BridgeAndCallHelper, is: [:Upgradeable, :Ownable], upgradeable: true) {\n  event(:CallFromBridge, { bridgingUser: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, feeAmount: :uint256, resultStatus: :bool, resultData: :string })\n  event(:BridgeUpdated, { newBridge: :address })\n  event(:FeeUpdated, { newFee: :uint256 })\n  address(:public, :bridge)\n  uint256(:public, :fee)\n  bool(:locked)\n  constructor(bridge: :address, fee: :uint256, owner: :address) {\n    self.Ownable.constructor(owner: owner)\n    self.Upgradeable.constructor(upgradeAdmin: owner)\n    s.bridge=bridge\n    s.fee=fee\n  }\n  function(:setBridge, { newBridge: :address }, :public) {\n    onlyOwner!\n    s.bridge=newBridge\n    emit(:BridgeUpdated, newBridge: newBridge)\n  }\n  function(:setFee, { newFee: :uint256 }, :public) {\n    onlyOwner!\n    s.fee=newFee\n    emit(:FeeUpdated, newFee: newFee)\n  }\n  function(:callFromBridge, { bridgingUser: :address, addressToCall: :address, base64Calldata: :string }, :public) {\n    require(msg.sender == s.bridge, \"Only the bridge can callFromBridge\")\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    calldata = base64Calldata.base64Decode\n    initialBalance = _balance\n    calculatedFee = if initialBalance < s.fee\n      initialBalance\n    else\n      s.fee\n    end\n    if calculatedFee > 0\n      _transfer(s.owner, calculatedFee)\n    end\n    _approve(addressToCall, initialBalance - calculatedFee)\n    (success, data) = addressToCall.call(calldata)\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(bridgingUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallFromBridge, bridgingUser: bridgingUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, feeAmount: calculatedFee, resultStatus: success, resultData: data)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.bridge).transfer(to, amount)\n  }\n}\n",
        "init_code_hash": "0xfd29ff1ad62a78d7c552167b1417f900e3095bfc603b84849e36488ae3017c14"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-14T16:16:33.644Z",
    "updated_at": "2024-02-14T16:16:33.644Z"
  },
  {
    "id": 20,
    "transaction_hash": "0xd7001f642807c927eb0911c2a22955c50989313e314f25b080ada7a6484d784a",
    "internal_transaction_index": 0,
    "block_number": 19227395,
    "transaction_index": 82,
    "name": "EditionMetadataRenderer01",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:INFTCollection01, abstract: true) {\n  function(:owner, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:EditionMetadataRenderer01, is: :Upgradeable, upgradeable: true) {\n  struct(:TokenEditionInfo) {\n    string(:name)\n    string(:description)\n    string(:imageURI)\n    string(:animationURI)\n  }\n  event(:MediaURIsUpdated, { target: :address, sender: :address, imageURI: :string, animationURI: :string })\n  event(:EditionInitialized, { target: :address, description: :string, imageURI: :string, animationURI: :string, name: :string })\n  event(:DescriptionUpdated, { target: :address, sender: :address, newDescription: :string })\n  mapping(({ address: :TokenEditionInfo }), :public, :tokenInfos)\n  constructor {\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n  }\n  function(:requireSenderAdmin, { target: :address }, :internal, :pure) {\n    require(target == msg.sender || INFTCollection01(target).owner == msg.sender, \"Admin access only\")\n  }\n  function(:updateMediaURIs, { target: :address, imageURI: :string, animationURI: :string }, :external) {\n    requireSenderAdmin(target)\n    s.tokenInfos[target].imageURI=imageURI\n    s.tokenInfos[target].animationURI=animationURI\n    emit(:MediaURIsUpdated, target: target, sender: msg.sender, imageURI: imageURI, animationURI: animationURI)\n  }\n  function(:updateDescription, { target: :address, newDescription: :string }, :external) {\n    requireSenderAdmin(target)\n    s.tokenInfos[target].description=newDescription\n    emit(:DescriptionUpdated, target: target, sender: msg.sender, newDescription: newDescription)\n  }\n  function(:initializeWithData, { info: :TokenEditionInfo }, :external) {\n    s.tokenInfos[msg.sender] = info\n    emit(:EditionInitialized, target: msg.sender, description: info.description, imageURI: info.imageURI, animationURI: info.animationURI, name: info.name)\n  }\n  function(:contractURI, :external, :view, returns: :string) {\n    target = msg.sender\n    editionInfo = s.tokenInfos[target]\n    encodeContractURIJSON(editionInfo.name, editionInfo.description, editionInfo.imageURI, editionInfo.animationURI)\n  }\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string) {\n    target = msg.sender\n    info = s.tokenInfos[target]\n    createMetadataEdition(info.name, info.description, info.imageURI, info.animationURI, tokenId)\n  }\n  function(:createMetadataEdition, { name: :string, description: :string, imageURI: :string, animationURI: :string, tokenOfEdition: :uint256 }, :internal, :pure, returns: :string) {\n    _tokenMediaData = tokenMediaData(imageURI, animationURI)\n    json = createMetadataJSON(name, description, _tokenMediaData, tokenOfEdition)\n    encodeMetadataJSON(json)\n  }\n  function(:encodeContractURIJSON, { name: :string, description: :string, imageURI: :string, animationURI: :string }, :internal, :pure, returns: :string) {\n    imageSpace = if imageURI.length > 0\n      \"\\\", \\\"image\\\": \\\"\" + imageURI\n    else\n      \"\"\n    end\n    animationSpace = if animationURI.length > 0\n      \"\\\", \\\"animation_url\\\": \\\"\" + animationURI\n    else\n      \"\"\n    end\n    encodeMetadataJSON(\"{\\\"name\\\": \\\"\" + name + \"\\\", \\\"description\\\": \\\"\" + description + imageSpace + animationSpace + \"\\\"}\")\n  }\n  function(:createMetadataJSON, { name: :string, description: :string, mediaData: :string, tokenOfEdition: :uint256 }, :internal, :pure, returns: :string) {\n    \"{\\\"name\\\": \\\"\" + name + \" \" + tokenOfEdition.toString + \"\\\", \\\"description\\\": \\\"\" + description + \"\\\", \\\"\" + mediaData + \"properties\\\": {\\\"number\\\": \" + tokenOfEdition.toString + \", \\\"name\\\": \\\"\" + name + \"\\\"}}\"\n  }\n  function(:encodeMetadataJSON, { json: :string }, :internal, :pure, returns: :string) {\n    \"data:application/json;base64,\" + json.base64Encode\n  }\n  function(:tokenMediaData, { imageUrl: :string, animationUrl: :string }, :internal, :pure, returns: :string) {\n    hasImage = imageUrl.length > 0\n    hasAnimation = animationUrl.length > 0\n    if hasImage && hasAnimation\n      return \"image\\\": \\\"\" + imageUrl + \"\\\", \\\"animation_url\\\": \\\"\" + animationUrl + \"\\\", \\\"\"\n    else\n      if hasImage\n        return \"image\\\": \\\"\" + imageUrl + \"\\\", \\\"\"\n      else\n        if hasAnimation\n          return \"animation_url\\\": \\\"\" + animationUrl + \"\\\", \\\"\"\n        end\n      end\n    end\n    \"\"\n  }\n}\n",
    "init_code_hash": "0xd7ecfb5c3eb58b7875a7c70799632006a0c00e4e002aea6b1e03809442f763f8",
    "references": [
      {
        "abi": null,
        "name": "INFTCollection01",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:INFTCollection01, abstract: true) {\n  function(:owner, :external, :view, returns: :address)\n}\n",
        "init_code_hash": "0xc029d89424bf16cb275e56c1012009aab295f9591b78f23bcce9f172493d46e4"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-14T16:29:46.095Z",
    "updated_at": "2024-02-14T16:29:46.095Z"
  },
  {
    "id": 21,
    "transaction_hash": "0xd405eee42325ddfccea58ea010d6e99316122104b9097932e37b6809359afd6c",
    "internal_transaction_index": 0,
    "block_number": 19240671,
    "transaction_index": 137,
    "name": "NFTCollection01",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:IEditionMetadataRenderer01, abstract: true) {\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string)\n  function(:contractURI, :external, :view, returns: :string)\n  function(:initializeWithData, { data: [:string] }, :external)\n}\ncontract(:MerkleProof, abstract: true) {\n  function(:verify, { proof: [:bytes32], root: :bytes32, leaf: :bytes32 }, :internal, :pure, returns: :bool) {\n    processProof(proof, leaf) == root\n  }\n  function(:processProof, { proof: [:bytes32], leaf: :bytes32 }, :internal, :pure, returns: :bytes32) {\n    computedHash = leaf\n    forLoop(condition: ->(i) {\n      i < proof.length\n    }, max_iterations: 25) { |i|\n      computedHash = _hashPair(computedHash, proof[i])\n    }\n    computedHash\n  }\n  function(:_hashPair, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    if a.cast(:uint256) < b.cast(:uint256)\n      _efficientHash(a, b)\n    else\n      _efficientHash(b, a)\n    end\n  }\n  function(:_efficientHash, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    keccak256(abi.encodePacked(a, b))\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:NFTCollection01, is: [:ERC721, :ERC2981, :Upgradeable, :Ownable, :Pausable, :MerkleProof], upgradeable: true) {\n  event(:Minted, { to: :address, amount: :uint256, mintPrice: :uint256, totalCost: :uint256, newTotalSupply: :uint256, isPublic: :bool })\n  event(:PublicMaxPerAddressUpdated, { publicMaxPerAddress: :uint256 })\n  event(:PublicMintStartUpdated, { publicMintStart: :uint256 })\n  event(:PublicMintEndUpdated, { publicMintEnd: :uint256 })\n  event(:PublicMintPriceUpdated, { publicMintPrice: :uint256 })\n  event(:AllowListMerkleRootUpdated, { allowListMerkleRoot: :bytes32 })\n  event(:AllowListMaxPerAddressUpdated, { allowListMaxPerAddress: :uint256 })\n  event(:AllowListMintStartUpdated, { allowListMintStart: :uint256 })\n  event(:AllowListMintEndUpdated, { allowListMintEnd: :uint256 })\n  event(:AllowListMintPriceUpdated, { allowListMintPrice: :uint256 })\n  event(:MaxSupplyUpdated, { maxSupply: :uint256 })\n  event(:BaseURIUpdated, { baseURI: :string })\n  event(:MetadataRendererUpdated, { metadataRenderer: :string })\n  uint256(:public, :maxSupply)\n  uint256(:public, :totalSupply)\n  uint256(:public, :maxPerMint)\n  string(:public, :baseURI)\n  address(:public, :WETH)\n  address(:public, :metadataRenderer)\n  uint256(:public, :publicMaxPerAddress)\n  uint256(:public, :publicMintStart)\n  uint256(:public, :publicMintEnd)\n  uint256(:public, :publicMintPrice)\n  bytes32(:public, :allowListMerkleRoot)\n  uint256(:public, :allowListMaxPerAddress)\n  uint256(:public, :allowListMintStart)\n  uint256(:public, :allowListMintEnd)\n  uint256(:public, :allowListMintPrice)\n  uint256(:public, :perMintFee)\n  address(:public, :feeTo)\n  mapping(({ address: :uint256 }), :public, :publicNumberMinted)\n  mapping(({ address: :uint256 }), :public, :allowListNumberMinted)\n  constructor(name: :string, symbol: :string, maxSupply: :uint256, baseURI: :string, weth: :address, perMintFee: :uint256, feeTo: :address) {\n    self.ERC721.constructor(name: name, symbol: symbol)\n    self.Ownable.constructor(owner: msg.sender)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.maxSupply=maxSupply\n    s.baseURI=baseURI\n    s.WETH=weth\n    s.maxPerMint=100\n    s.perMintFee=perMintFee\n    s.feeTo=feeTo\n  }\n  function(:_handleMint, { to: :address, amount: :uint256, merkleProof: [:bytes32] }, :internal) {\n    whenNotPaused!\n    require(isMintActive, \"Mint is not active\")\n    require(amount > 0, \"Amount must be positive\")\n    require(s.maxSupply == 0 || s.totalSupply + amount <= s.maxSupply, \"Exceeded max supply\")\n    require(amount <= s.maxPerMint, \"Exceeded max per mint\")\n    isAllowListMint = merkleProof.length > 0 && isAllowListMintActive\n    (numberMinted, mintPrice, maxPerAddress) = if isAllowListMint\n      require(isOnAllowList(to, merkleProof), \"Not on allow list\")\n      s.allowListNumberMinted[to] += amount\n      [s.allowListNumberMinted[to], s.allowListMintPrice, s.allowListMaxPerAddress]\n    else\n      s.publicNumberMinted[to] += amount\n      [s.publicNumberMinted[to], s.publicMintPrice, s.publicMaxPerAddress]\n    end\n    require(maxPerAddress == 0 || numberMinted <= maxPerAddress, \"Exceeded mint limit\")\n    totalFee = s.perMintFee * amount\n    if totalFee > 0 && s.feeTo != address(0)\n      ERC20(s.WETH).transferFrom(msg.sender, s.feeTo, totalFee)\n    end\n    totalCost = mintPrice * amount\n    if totalCost > 0\n      require(s.WETH != address(0), \"WETH not set\")\n      ERC20(s.WETH).transferFrom(msg.sender, address(this), totalCost)\n    end\n    initialId = s.totalSupply + 1\n    s.totalSupply += amount\n    forLoop(condition: ->(i) {\n      i < amount\n    }, max_iterations: s.maxPerMint) { |i|\n      _mint(to: to, id: initialId + i)\n    }\n    emit(:Minted, to: to, amount: amount, mintPrice: mintPrice, totalCost: totalCost, newTotalSupply: s.totalSupply, isPublic: !isAllowListMint)\n  }\n  function(:_isMintActive, { mintStart: :uint256, mintEnd: :uint256 }, :internal, :view, returns: :bool) {\n    isNotMintedOut = s.maxSupply == 0 || s.totalSupply < s.maxSupply\n    isOwner = s.owner == msg.sender\n    isOrAfterStart = block.timestamp >= mintStart && mintStart > 0\n    isBeforeEnd = block.timestamp < mintEnd || mintEnd == 0\n    isNotMintedOut && isBeforeEnd && (isOwner || isOrAfterStart)\n  }\n  function(:isPublicMintActive, :public, :view, returns: :bool) {\n    _isMintActive(mintStart: s.publicMintStart, mintEnd: s.publicMintEnd)\n  }\n  function(:isAllowListMintActive, :public, :view, returns: :bool) {\n    _isMintActive(mintStart: s.allowListMintStart, mintEnd: s.allowListMintEnd)\n  }\n  function(:isMintActive, :public, :view, returns: :bool) {\n    isPublicMintActive || isAllowListMintActive\n  }\n  function(:isOnAllowList, { wallet: :address, merkleProof: [:bytes32] }, :public, :view, returns: :bool) {\n    self.MerkleProof.verify(merkleProof, s.allowListMerkleRoot, keccak256(abi.encodePacked(wallet)))\n  }\n  function(:tokenURI, { tokenId: :uint256 }, :public, :view, :override, returns: :string) {\n    require(_exists(id: tokenId), \"URI query for nonexistent token\")\n    if s.metadataRenderer != address(0)\n      return IEditionMetadataRenderer01(s.metadataRenderer).tokenURI(tokenId)\n    end\n    if s.baseURI.length == 0\n      return \"\"\n    end\n    if s.baseURI[s.baseURI.length - 1] != \"/\"\n      return s.baseURI\n    end\n    s.baseURI + tokenId.toString\n  }\n  function(:contractURI, :public, :view, returns: :string) {\n    if s.metadataRenderer == address(0)\n      return \"\"\n    end\n    IEditionMetadataRenderer01(s.metadataRenderer).contractURI\n  }\n  function(:airdrop, { to: :address, amount: :uint256, merkleProof: [:bytes32] }, :public) {\n    _handleMint(to: to, amount: amount, merkleProof: merkleProof)\n  }\n  function(:mint, { amount: :uint256, merkleProof: [:bytes32] }, :public) {\n    _handleMint(to: msg.sender, amount: amount, merkleProof: merkleProof)\n  }\n  function(:setPublicMaxPerAddress, { publicMaxPerAddress: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMaxPerAddress=publicMaxPerAddress\n    emit(:PublicMaxPerAddressUpdated, publicMaxPerAddress: publicMaxPerAddress)\n  }\n  function(:setPublicMintStart, { publicMintStart: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintStart=publicMintStart\n    emit(:PublicMintStartUpdated, publicMintStart: publicMintStart)\n  }\n  function(:setPublicMintEnd, { publicMintEnd: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintEnd=publicMintEnd\n    emit(:PublicMintEndUpdated, publicMintEnd: publicMintEnd)\n  }\n  function(:setPublicMintPrice, { publicMintPrice: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintPrice=publicMintPrice\n    emit(:PublicMintPriceUpdated, publicMintPrice: publicMintPrice)\n  }\n  function(:setAllowListMerkleRoot, { allowListMerkleRoot: :bytes32 }, :public) {\n    onlyOwner!\n    s.allowListMerkleRoot=allowListMerkleRoot\n    emit(:AllowListMerkleRootUpdated, allowListMerkleRoot: allowListMerkleRoot)\n  }\n  function(:setAllowListMaxPerAddress, { allowListMaxPerAddress: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMaxPerAddress=allowListMaxPerAddress\n    emit(:AllowListMaxPerAddressUpdated, allowListMaxPerAddress: allowListMaxPerAddress)\n  }\n  function(:setAllowListMintStart, { allowListMintStart: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintStart=allowListMintStart\n    emit(:AllowListMintStartUpdated, allowListMintStart: allowListMintStart)\n  }\n  function(:setAllowListMintEnd, { allowListMintEnd: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintEnd=allowListMintEnd\n    emit(:AllowListMintEndUpdated, allowListMintEnd: allowListMintEnd)\n  }\n  function(:setAllowListMintPrice, { allowListMintPrice: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintPrice=allowListMintPrice\n    emit(:AllowListMintPriceUpdated, allowListMintPrice: allowListMintPrice)\n  }\n  function(:setMaxSupply, { maxSupply: :uint256 }, :public) {\n    onlyOwner!\n    require(s.maxSupply == 0, \"Max supply already set\")\n    require(maxSupply >= s.totalSupply, \"New max supply must be greater than total supply\")\n    s.maxSupply=maxSupply\n    emit(:MaxSupplyUpdated, maxSupply: maxSupply)\n  }\n  function(:setMetadataRenderer, { metadataRenderer: :address, data: :string }, :public) {\n    onlyOwner!\n    s.metadataRenderer=metadataRenderer\n    (success, _) = metadataRenderer.call(data)\n    require(success, \"setMetadataRenderer failed\")\n    emit(:MetadataRendererUpdated, metadataRenderer: metadataRenderer)\n  }\n  function(:setPublicMintSettings, { publicMaxPerAddress: :uint256, publicMintStart: :uint256, publicMintEnd: :uint256, publicMintPrice: :uint256 }, :public) {\n    setPublicMaxPerAddress(publicMaxPerAddress)\n    setPublicMintStart(publicMintStart)\n    setPublicMintEnd(publicMintEnd)\n    setPublicMintPrice(publicMintPrice)\n  }\n  function(:setAllowListMintSettings, { allowListMerkleRoot: :bytes32, allowListMaxPerAddress: :uint256, allowListMintStart: :uint256, allowListMintEnd: :uint256, allowListMintPrice: :uint256 }, :public) {\n    setAllowListMerkleRoot(allowListMerkleRoot)\n    setAllowListMaxPerAddress(allowListMaxPerAddress)\n    setAllowListMintStart(allowListMintStart)\n    setAllowListMintEnd(allowListMintEnd)\n    setAllowListMintPrice(allowListMintPrice)\n  }\n  function(:setBaseURI, { baseURI: :string }, :public) {\n    onlyOwner!\n    s.baseURI=baseURI\n    emit(:BaseURIUpdated, baseURI: baseURI)\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:withdrawWETH, :public, returns: :bool) {\n    onlyOwner!\n    amount = ERC20(s.WETH).balanceOf(address(this))\n    ERC20(s.WETH).transfer(s.owner, amount)\n  }\n  function(:setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :public) {\n    onlyOwner!\n    _setDefaultRoyalty(receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:deleteDefaultRoyalty, :public) {\n    onlyOwner!\n    _deleteDefaultRoyalty\n  }\n  function(:setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :public) {\n    onlyOwner!\n    _setTokenRoyalty(tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:deleteTokenRoyalty, { tokenId: :uint256 }, :public) {\n    onlyOwner!\n    _deleteTokenRoyalty(tokenId)\n  }\n  function(:setFeeTo, { feeTo: :address }, :public) {\n    require(msg.sender == s.feeTo, \"Only feeTo can change feeTo\")\n    s.feeTo=feeTo\n    nil\n  }\n}\n",
    "init_code_hash": "0x0974b723d3a7c688be3a60ea523f902d56b4eb825eda09306925588f6d36c5f8",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC2981",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\n",
        "init_code_hash": "0xc25feb0d950d0fa605e6acd6a7b91c21ec886e57ee132177cf9856bb5f00a9fb"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "IEditionMetadataRenderer01",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IEditionMetadataRenderer01, abstract: true) {\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string)\n  function(:contractURI, :external, :view, returns: :string)\n  function(:initializeWithData, { data: [:string] }, :external)\n}\n",
        "init_code_hash": "0x8d542108f995e96ecfe8796365e1c6b24c703fd27a709e8a38858bc1f866f05a"
      },
      {
        "abi": null,
        "name": "MerkleProof",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:MerkleProof, abstract: true) {\n  function(:verify, { proof: [:bytes32], root: :bytes32, leaf: :bytes32 }, :internal, :pure, returns: :bool) {\n    processProof(proof, leaf) == root\n  }\n  function(:processProof, { proof: [:bytes32], leaf: :bytes32 }, :internal, :pure, returns: :bytes32) {\n    computedHash = leaf\n    forLoop(condition: ->(i) {\n      i < proof.length\n    }, max_iterations: 25) { |i|\n      computedHash = _hashPair(computedHash, proof[i])\n    }\n    computedHash\n  }\n  function(:_hashPair, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    if a.cast(:uint256) < b.cast(:uint256)\n      _efficientHash(a, b)\n    else\n      _efficientHash(b, a)\n    end\n  }\n  function(:_efficientHash, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    keccak256(abi.encodePacked(a, b))\n  }\n}\n",
        "init_code_hash": "0xc134d1a3fdd6d2b91b43961380d5d9cfaaaecbad1ce9c8258bee7657dfa2b3a8"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-16T13:11:20.762Z",
    "updated_at": "2024-02-16T13:11:20.762Z"
  },
  {
    "id": 22,
    "transaction_hash": "0x297eb49469d084a6f3cf9f7d6411de0d3448ef07a17ae70b3ff358ba6f04a907",
    "internal_transaction_index": 0,
    "block_number": 19242701,
    "transaction_index": 56,
    "name": "FacetPortV101",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetPortV101, is: [:Upgradeable, :Ownable, :Pausable], upgradeable: true) {\n  event(:OfferAccepted, { success: :bool, offerType: :string, offerer: :address, buyer: :address, seller: :address, recipient: :address, assetContract: :address, assetId: :uint256, considerationAmount: :uint256, considerationToken: :address, offerId: :bytes16 })\n  event(:OfferCancelled, { offerer: :address, offerId: :bytes16 })\n  event(:AllOffersOnAssetCancelledForUser, { offerType: :string, offerer: :address, assetContract: :address, assetId: :uint256 })\n  event(:AllOffersCancelledForUser, { offerType: :string, offerer: :address })\n  mapping(({ address: mapping(bytes16: :bool) }), :public, :userOfferCancellations)\n  mapping(({ string: mapping(address: mapping(address: mapping(uint256: :uint256))) }), :public, :userOffersOnAssetValidAfterTime)\n  mapping(({ string: mapping(address: :uint256) }), :public, :userOffersValidAfterTime)\n  uint96(:feeBps)\n  constructor(_feeBps: :uint96, _upgradeAdmin: :address, _owner: :address) {\n    s.feeBps=_feeBps\n    self.Upgradeable.constructor(upgradeAdmin: _upgradeAdmin)\n    self.Ownable.constructor(owner: _owner)\n    _pause\n  }\n  function(:setFeeBps, { _feeBps: :uint96 }, :external) {\n    onlyOwner!\n    s.feeBps=_feeBps\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:acceptOfferWithSignature, { offerType: :string, offerId: :bytes16, offerer: :address, recipient: :address, assetContract: :address, assetId: :uint256, assetType: :string, assetAmount: :uint256, considerationToken: :address, considerationAmount: :uint256, startTime: :uint256, endTime: :uint256, signature: :bytes }, :external) {\n    success = _acceptOfferWithSignature(offerType: offerType, offerId: offerId, offerer: offerer, recipient: recipient, assetContract: assetContract, assetId: assetId, assetType: assetType, assetAmount: assetAmount, considerationToken: considerationToken, considerationAmount: considerationAmount, startTime: startTime, endTime: endTime, signature: signature)\n    require(success, \"Offer was not successfully accepted\")\n  }\n  function(:acceptMultipleOffersWithSignatures, { offerTypes: [:string], offerIds: [:bytes16], offerers: [:address], recipients: [:address], assetContracts: [:address], assetIds: [:uint256], assetTypes: [:string], assetAmounts: [:uint256], considerationTokens: [:address], considerationAmounts: [:uint256], startTimes: [:uint256], endTimes: [:uint256], signatures: [:bytes] }, :external) {\n    require(offerIds.length == offerers.length, \"Offer ID and offerer arrays must be the same length\")\n    require(offerIds.length == offerTypes.length, \"Offer ID and offer types arrays must be the same length\")\n    require(offerIds.length == assetContracts.length, \"Offer ID and asset contracts arrays must be the same length\")\n    require(offerIds.length == assetIds.length, \"Offer ID and asset IDs arrays must be the same length\")\n    require(offerIds.length == assetTypes.length, \"Offer ID and assetTypes arrays must be the same length\")\n    require(offerIds.length == assetAmounts.length, \"Offer ID and assetAmounts arrays must be the same length\")\n    require(offerIds.length == considerationTokens.length, \"Offer ID and consideration tokens arrays must be the same length\")\n    require(offerIds.length == considerationAmounts.length, \"Offer ID and consideration amounts arrays must be the same length\")\n    require(offerIds.length == startTimes.length, \"Offer ID and start times arrays must be the same length\")\n    require(offerIds.length == endTimes.length, \"Offer ID and end times arrays must be the same length\")\n    require(offerIds.length == signatures.length, \"Offer ID and signatures arrays must be the same length\")\n    require(offerIds.length == recipients.length, \"Offer ID and recipients arrays must be the same length\")\n    require(offerIds.length <= 20, \"Cannot accept more than 20 offers at a time\")\n    atLeastOneSuccess = false\n    forLoop(condition: ->(i) {\n      i < offerIds.length\n    }) { |i|\n      success = _acceptOfferWithSignature(offerType: offerTypes[i], offerId: offerIds[i], offerer: offerers[i], recipient: recipients[i], assetContract: assetContracts[i], assetId: assetIds[i], assetType: assetTypes[i], assetAmount: assetAmounts[i], considerationToken: considerationTokens[i], considerationAmount: considerationAmounts[i], startTime: startTimes[i], endTime: endTimes[i], signature: signatures[i])\n      if success\n        atLeastOneSuccess = true\n      end\n    }\n    require(atLeastOneSuccess, \"No offers were successfully accepted\")\n  }\n  function(:_acceptOfferWithSignature, { offerType: :string, offerId: :bytes16, offerer: :address, recipient: :address, assetContract: :address, assetId: :uint256, assetType: :string, assetAmount: :uint256, considerationToken: :address, considerationAmount: :uint256, startTime: :uint256, endTime: :uint256, signature: :bytes }, :internal, returns: :bool) {\n    whenNotPaused!\n    signatureValid = signature.verifyTypedDataSignature({ Offer: [{ name: \"offerType\", type: \"string\" }, { name: \"offerId\", type: \"bytes16\" }, { name: \"offerer\", type: \"address\" }, { name: \"assetContract\", type: \"address\" }, { name: \"assetId\", type: \"uint256\" }, { name: \"assetType\", type: \"string\" }, { name: \"assetAmount\", type: \"uint256\" }, { name: \"considerationToken\", type: \"address\" }, { name: \"considerationAmount\", type: \"uint256\" }, { name: \"startTime\", type: \"uint256\" }, { name: \"endTime\", type: \"uint256\" }] }, { offerType: offerType, offerId: offerId, offerer: offerer, assetContract: assetContract, assetId: assetId, assetType: assetType, assetAmount: assetAmount, considerationToken: considerationToken, considerationAmount: considerationAmount, startTime: startTime, endTime: endTime }, verifyingContract: address(this), domainName: \"FacetPort\", domainVersion: \"1\", signer: offerer)\n    require(signatureValid, \"Invalid signature\")\n    require(!s.userOfferCancellations[offerer][offerId], \"Offer cancelled\")\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    require(assetType == \"ERC721\" && assetAmount == 1, \"Only ERC721 assets are supported\")\n    require(block.timestamp >= startTime, \"Current time is before the start time\")\n    require(block.timestamp < endTime, \"Current time is after the end time\")\n    require(startTime > s.userOffersOnAssetValidAfterTime[offerType][offerer][assetContract][assetId], \"Start time is before the offerer's valid after time\")\n    require(startTime > s.userOffersValidAfterTime[offerType][offerer], \"Start time is before the valid after time for the offerer\")\n    (buyer, seller) = if offerType == \"Bid\"\n      [offerer, msg.sender]\n    else\n      [msg.sender, offerer]\n    end\n    transferSucceeded = _payRoyaltiesAndTransfer(assetContract: assetContract, assetId: assetId, seller: seller, buyer: buyer, recipient: recipient, considerationAmount: considerationAmount, considerationToken: considerationToken)\n    emit(:OfferAccepted, { success: transferSucceeded, offerType: offerType, offerer: offerer, buyer: buyer, seller: seller, recipient: recipient, assetContract: assetContract, assetId: assetId, considerationAmount: considerationAmount, considerationToken: considerationToken, offerId: offerId })\n    transferSucceeded\n  }\n  function(:_payRoyaltiesAndTransfer, { assetContract: :address, assetId: :uint256, seller: :address, buyer: :address, recipient: :address, considerationAmount: :uint256, considerationToken: :address }, :internal, returns: :bool) {\n    require(recipient == address(0) || msg.sender == buyer, \"Only buyer can add recipient\")\n    currentOwner = ERC721(assetContract).ownerOf(assetId)\n    unless currentOwner == seller\n      return false\n    end\n    (success, data) = assetContract.call(function: \"supportsERC2981\")\n    royaltyAmount = 0\n    if success && data == \"true\"\n      (receiver, royaltyAmount) = ERC2981(assetContract).royaltyInfo(tokenId: assetId, salePrice: considerationAmount)\n      if receiver == address(0)\n        royaltyAmount = 0\n      end\n      if royaltyAmount > 0\n        ERC20(considerationToken).transferFrom(from: buyer, to: receiver, amount: royaltyAmount)\n      end\n    end\n    marketplaceFee = computeFee(considerationAmount)\n    sellerAmount = considerationAmount - royaltyAmount - marketplaceFee\n    if sellerAmount > 0\n      ERC20(considerationToken).transferFrom(from: buyer, to: seller, amount: sellerAmount)\n    end\n    if marketplaceFee > 0\n      ERC20(considerationToken).transferFrom(from: buyer, to: owner, amount: marketplaceFee)\n    end\n    _transferNFT(assetContract: assetContract, assetId: assetId, recipient: if recipient == address(0)\n      buyer\n    else\n      recipient\n    end, from: seller)\n    return true\n  }\n  function(:transferNFTs, { assetContracts: [:address], assetIds: [:uint256], recipients: [:address] }, :external) {\n    require(assetContracts.length == assetIds.length, \"Asset contracts and asset IDs must be the same length\")\n    require(assetContracts.length == recipients.length, \"Asset contracts and recipients must be the same length\")\n    require(assetIds.length <= 20, \"Cannot transfer more than 20 NFTs at a time\")\n    forLoop(condition: ->(i) {\n      i < recipients.length\n    }) { |i|\n      _transferNFT(assetContract: assetContracts[i], assetId: assetIds[i], recipient: recipients[i], from: msg.sender)\n    }\n  }\n  function(:_transferNFT, { assetContract: :address, assetId: :uint256, recipient: :address, from: :address }, :internal) {\n    whenNotPaused!\n    ERC721(assetContract).transferFrom(from: from, to: recipient, id: assetId)\n    s.userOffersOnAssetValidAfterTime[\"Listing\"][from][assetContract][assetId] = block.timestamp\n    s.userOffersOnAssetValidAfterTime[\"Bid\"][recipient][assetContract][assetId] = block.timestamp\n    nil\n  }\n  function(:cancelOffer, { offerId: :bytes16 }, :external) {\n    s.userOfferCancellations[msg.sender][offerId] = true\n    emit(:OfferCancelled, offerer: msg.sender, offerId: offerId)\n  }\n  function(:cancelAllOffersForAsset, { offerType: :string, assetContract: :address, assetId: :uint256 }, :external) {\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    s.userOffersOnAssetValidAfterTime[offerType][msg.sender][assetContract][assetId] = block.timestamp\n    emit(:AllOffersOnAssetCancelledForUser, offerType: offerType, offerer: msg.sender, assetContract: assetContract, assetId: assetId)\n  }\n  function(:cancelAllOffersOfUser, { offerType: :string }, :external) {\n    require(offerType == \"Listing\" || offerType == \"Bid\", \"Invalid offer type\")\n    s.userOffersValidAfterTime[offerType][msg.sender] = block.timestamp\n    emit(:AllOffersCancelledForUser, offerType: offerType, offerer: msg.sender)\n  }\n  function(:computeFee, { amount: :uint256 }, :public, :view, returns: :uint256) {\n    return (amount * s.feeBps).div(10000)\n  }\n}\n",
    "init_code_hash": "0xee18008875b9e2ecadebb7566928a6a853a23f15c2393221f6a9db8d81fd5670",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC2981",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\n",
        "init_code_hash": "0xc25feb0d950d0fa605e6acd6a7b91c21ec886e57ee132177cf9856bb5f00a9fb"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-16T20:02:33.372Z",
    "updated_at": "2024-02-16T20:02:33.372Z"
  },
  {
    "id": 23,
    "transaction_hash": "0xba8f68e9deef4bf13899aac7164ccc62a6e8d35b76e7f2f776aa984167908f58",
    "internal_transaction_index": 0,
    "block_number": 19250584,
    "transaction_index": 104,
    "name": "NFTCollection01",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:IEditionMetadataRenderer01, abstract: true) {\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string)\n  function(:contractURI, :external, :view, returns: :string)\n  function(:initializeWithData, { data: [:string] }, :external)\n}\ncontract(:MerkleProof, abstract: true) {\n  function(:verify, { proof: [:bytes32], root: :bytes32, leaf: :bytes32 }, :internal, :pure, returns: :bool) {\n    processProof(proof, leaf) == root\n  }\n  function(:processProof, { proof: [:bytes32], leaf: :bytes32 }, :internal, :pure, returns: :bytes32) {\n    computedHash = leaf\n    forLoop(condition: ->(i) {\n      i < proof.length\n    }, max_iterations: 25) { |i|\n      computedHash = _hashPair(computedHash, proof[i])\n    }\n    computedHash\n  }\n  function(:_hashPair, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    if a.cast(:uint256) < b.cast(:uint256)\n      _efficientHash(a, b)\n    else\n      _efficientHash(b, a)\n    end\n  }\n  function(:_efficientHash, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    keccak256(abi.encodePacked(a, b))\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:NFTCollection01, is: [:ERC721, :ERC2981, :Upgradeable, :Ownable, :Pausable, :MerkleProof], upgradeable: true) {\n  event(:Minted, { to: :address, amount: :uint256, mintPrice: :uint256, totalCost: :uint256, newTotalSupply: :uint256, isPublic: :bool })\n  event(:PublicMaxPerAddressUpdated, { publicMaxPerAddress: :uint256 })\n  event(:PublicMintStartUpdated, { publicMintStart: :uint256 })\n  event(:PublicMintEndUpdated, { publicMintEnd: :uint256 })\n  event(:PublicMintPriceUpdated, { publicMintPrice: :uint256 })\n  event(:AllowListMerkleRootUpdated, { allowListMerkleRoot: :bytes32 })\n  event(:AllowListMaxPerAddressUpdated, { allowListMaxPerAddress: :uint256 })\n  event(:AllowListMintStartUpdated, { allowListMintStart: :uint256 })\n  event(:AllowListMintEndUpdated, { allowListMintEnd: :uint256 })\n  event(:AllowListMintPriceUpdated, { allowListMintPrice: :uint256 })\n  event(:MaxSupplyUpdated, { maxSupply: :uint256 })\n  event(:BaseURIUpdated, { baseURI: :string })\n  event(:MetadataRendererUpdated, { metadataRenderer: :string })\n  uint256(:public, :maxSupply)\n  uint256(:public, :totalSupply)\n  uint256(:public, :nextTokenId)\n  uint256(:public, :maxPerMint)\n  string(:public, :baseURI)\n  address(:public, :WETH)\n  address(:public, :metadataRenderer)\n  uint256(:public, :publicMaxPerAddress)\n  uint256(:public, :publicMintStart)\n  uint256(:public, :publicMintEnd)\n  uint256(:public, :publicMintPrice)\n  bytes32(:public, :allowListMerkleRoot)\n  uint256(:public, :allowListMaxPerAddress)\n  uint256(:public, :allowListMintStart)\n  uint256(:public, :allowListMintEnd)\n  uint256(:public, :allowListMintPrice)\n  uint256(:public, :perMintFee)\n  address(:public, :feeTo)\n  mapping(({ address: :uint256 }), :public, :publicNumberMinted)\n  mapping(({ address: :uint256 }), :public, :allowListNumberMinted)\n  constructor(name: :string, symbol: :string, maxSupply: :uint256, baseURI: :string, weth: :address, perMintFee: :uint256, feeTo: :address) {\n    self.ERC721.constructor(name: name, symbol: symbol)\n    self.Ownable.constructor(owner: msg.sender)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.maxSupply=maxSupply\n    s.baseURI=baseURI\n    s.WETH=weth\n    s.maxPerMint=25\n    s.perMintFee=perMintFee\n    s.feeTo=feeTo\n    s.nextTokenId=1\n  }\n  function(:_handleMint, { to: :address, amount: :uint256, merkleProof: [:bytes32] }, :internal) {\n    whenNotPaused!\n    require(isMintActive, \"Mint is not active\")\n    require(amount > 0, \"Amount must be positive\")\n    require(s.maxSupply == 0 || s.totalSupply + amount <= s.maxSupply, \"Exceeded max supply\")\n    require(amount <= s.maxPerMint, \"Exceeded max per mint\")\n    isAllowListMint = merkleProof.length > 0 && isAllowListMintActive\n    (numberMinted, mintPrice, maxPerAddress) = if isAllowListMint\n      require(isOnAllowList(to, merkleProof), \"Not on allow list\")\n      s.allowListNumberMinted[to] += amount\n      [s.allowListNumberMinted[to], s.allowListMintPrice, s.allowListMaxPerAddress]\n    else\n      s.publicNumberMinted[to] += amount\n      [s.publicNumberMinted[to], s.publicMintPrice, s.publicMaxPerAddress]\n    end\n    require(maxPerAddress == 0 || numberMinted <= maxPerAddress, \"Exceeded mint limit\")\n    totalFee = s.perMintFee * amount\n    if totalFee > 0 && s.feeTo != address(0)\n      ERC20(s.WETH).transferFrom(msg.sender, s.feeTo, totalFee)\n    end\n    totalCost = mintPrice * amount\n    if totalCost > 0\n      require(s.WETH != address(0), \"WETH not set\")\n      ERC20(s.WETH).transferFrom(msg.sender, address(this), totalCost)\n    end\n    initialId = s.nextTokenId\n    s.nextTokenId += amount\n    s.totalSupply += amount\n    forLoop(condition: ->(i) {\n      i < amount\n    }, max_iterations: s.maxPerMint) { |i|\n      _mint(to: to, id: initialId + i)\n    }\n    emit(:Minted, to: to, amount: amount, mintPrice: mintPrice, totalCost: totalCost, newTotalSupply: s.totalSupply, isPublic: !isAllowListMint)\n  }\n  function(:_isMintActive, { mintStart: :uint256, mintEnd: :uint256 }, :internal, :view, returns: :bool) {\n    isNotMintedOut = s.maxSupply == 0 || s.totalSupply < s.maxSupply\n    isOwner = s.owner == msg.sender\n    isOrAfterStart = block.timestamp >= mintStart && mintStart > 0\n    isBeforeEnd = block.timestamp < mintEnd || mintEnd == 0\n    isNotMintedOut && isBeforeEnd && (isOwner || isOrAfterStart)\n  }\n  function(:isPublicMintActive, :public, :view, returns: :bool) {\n    _isMintActive(mintStart: s.publicMintStart, mintEnd: s.publicMintEnd)\n  }\n  function(:isAllowListMintActive, :public, :view, returns: :bool) {\n    _isMintActive(mintStart: s.allowListMintStart, mintEnd: s.allowListMintEnd)\n  }\n  function(:isMintActive, :public, :view, returns: :bool) {\n    isPublicMintActive || isAllowListMintActive\n  }\n  function(:isOnAllowList, { wallet: :address, merkleProof: [:bytes32] }, :public, :view, returns: :bool) {\n    self.MerkleProof.verify(merkleProof, s.allowListMerkleRoot, keccak256(abi.encodePacked(wallet)))\n  }\n  function(:tokenURI, { tokenId: :uint256 }, :public, :view, :override, returns: :string) {\n    require(_exists(id: tokenId), \"URI query for nonexistent token\")\n    if s.metadataRenderer != address(0)\n      return IEditionMetadataRenderer01(s.metadataRenderer).tokenURI(tokenId)\n    end\n    if s.baseURI.length == 0\n      return \"\"\n    end\n    if s.baseURI[s.baseURI.length - 1] != \"/\"\n      return s.baseURI\n    end\n    s.baseURI + tokenId.toString\n  }\n  function(:contractURI, :public, :view, returns: :string) {\n    if s.metadataRenderer == address(0)\n      return \"\"\n    end\n    IEditionMetadataRenderer01(s.metadataRenderer).contractURI\n  }\n  function(:airdrop, { to: :address, amount: :uint256, merkleProof: [:bytes32] }, :public) {\n    _handleMint(to: to, amount: amount, merkleProof: merkleProof)\n  }\n  function(:mint, { amount: :uint256, merkleProof: [:bytes32] }, :public) {\n    _handleMint(to: msg.sender, amount: amount, merkleProof: merkleProof)\n  }\n  function(:setPublicMaxPerAddress, { publicMaxPerAddress: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMaxPerAddress=publicMaxPerAddress\n    emit(:PublicMaxPerAddressUpdated, publicMaxPerAddress: publicMaxPerAddress)\n  }\n  function(:setPublicMintStart, { publicMintStart: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintStart=publicMintStart\n    emit(:PublicMintStartUpdated, publicMintStart: publicMintStart)\n  }\n  function(:setPublicMintEnd, { publicMintEnd: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintEnd=publicMintEnd\n    emit(:PublicMintEndUpdated, publicMintEnd: publicMintEnd)\n  }\n  function(:setPublicMintPrice, { publicMintPrice: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintPrice=publicMintPrice\n    emit(:PublicMintPriceUpdated, publicMintPrice: publicMintPrice)\n  }\n  function(:setAllowListMerkleRoot, { allowListMerkleRoot: :bytes32 }, :public) {\n    onlyOwner!\n    s.allowListMerkleRoot=allowListMerkleRoot\n    emit(:AllowListMerkleRootUpdated, allowListMerkleRoot: allowListMerkleRoot)\n  }\n  function(:setAllowListMaxPerAddress, { allowListMaxPerAddress: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMaxPerAddress=allowListMaxPerAddress\n    emit(:AllowListMaxPerAddressUpdated, allowListMaxPerAddress: allowListMaxPerAddress)\n  }\n  function(:setAllowListMintStart, { allowListMintStart: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintStart=allowListMintStart\n    emit(:AllowListMintStartUpdated, allowListMintStart: allowListMintStart)\n  }\n  function(:setAllowListMintEnd, { allowListMintEnd: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintEnd=allowListMintEnd\n    emit(:AllowListMintEndUpdated, allowListMintEnd: allowListMintEnd)\n  }\n  function(:setAllowListMintPrice, { allowListMintPrice: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintPrice=allowListMintPrice\n    emit(:AllowListMintPriceUpdated, allowListMintPrice: allowListMintPrice)\n  }\n  function(:setMaxSupply, { maxSupply: :uint256 }, :public) {\n    onlyOwner!\n    require(s.maxSupply == 0, \"Max supply already set\")\n    require(maxSupply >= s.totalSupply, \"New max supply must be greater than total supply\")\n    s.maxSupply=maxSupply\n    emit(:MaxSupplyUpdated, maxSupply: maxSupply)\n  }\n  function(:setMetadataRenderer, { metadataRenderer: :address, data: :string }, :public) {\n    onlyOwner!\n    s.metadataRenderer=metadataRenderer\n    (success, _) = metadataRenderer.call(data)\n    require(success, \"setMetadataRenderer failed\")\n    emit(:MetadataRendererUpdated, metadataRenderer: metadataRenderer)\n  }\n  function(:setPublicMintSettings, { publicMaxPerAddress: :uint256, publicMintStart: :uint256, publicMintEnd: :uint256, publicMintPrice: :uint256 }, :public) {\n    setPublicMaxPerAddress(publicMaxPerAddress)\n    setPublicMintStart(publicMintStart)\n    setPublicMintEnd(publicMintEnd)\n    setPublicMintPrice(publicMintPrice)\n  }\n  function(:setAllowListMintSettings, { allowListMerkleRoot: :bytes32, allowListMaxPerAddress: :uint256, allowListMintStart: :uint256, allowListMintEnd: :uint256, allowListMintPrice: :uint256 }, :public) {\n    setAllowListMerkleRoot(allowListMerkleRoot)\n    setAllowListMaxPerAddress(allowListMaxPerAddress)\n    setAllowListMintStart(allowListMintStart)\n    setAllowListMintEnd(allowListMintEnd)\n    setAllowListMintPrice(allowListMintPrice)\n  }\n  function(:setBaseURI, { baseURI: :string }, :public) {\n    onlyOwner!\n    s.baseURI=baseURI\n    emit(:BaseURIUpdated, baseURI: baseURI)\n  }\n  function(:burn, { tokenId: :uint256 }, :public) {\n    require(isApprovedOrOwner(spender: msg.sender, id: tokenId), \"ERC721: msg.sender not authorized to burn id #{tokenId.toString}\")\n    s.totalSupply -= 1\n    _burn(tokenId)\n  }\n  function(:burnMultiple, { tokenIds: [:uint256] }, :public) {\n    require(tokenIds.length > 0, \"No token ids provided\")\n    require(tokenIds.length <= 20, \"Too many token ids provided\")\n    forLoop(condition: ->(i) {\n      i < tokenIds.length\n    }, max_iterations: 20) { |i|\n      burn(tokenIds[i])\n    }\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:withdrawWETH, :public, returns: :bool) {\n    onlyOwner!\n    amount = ERC20(s.WETH).balanceOf(address(this))\n    ERC20(s.WETH).transfer(s.owner, amount)\n  }\n  function(:setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :public) {\n    onlyOwner!\n    _setDefaultRoyalty(receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:deleteDefaultRoyalty, :public) {\n    onlyOwner!\n    _deleteDefaultRoyalty\n  }\n  function(:setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :public) {\n    onlyOwner!\n    _setTokenRoyalty(tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:deleteTokenRoyalty, { tokenId: :uint256 }, :public) {\n    onlyOwner!\n    _deleteTokenRoyalty(tokenId)\n  }\n  function(:setFeeTo, { feeTo: :address }, :public) {\n    require(msg.sender == s.feeTo, \"Only feeTo can change feeTo\")\n    s.feeTo=feeTo\n    nil\n  }\n}\n",
    "init_code_hash": "0xff325d0139ddecca5c76d9e6737d48d005c5842a76e79f545e850e03c502fa11",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC2981",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\n",
        "init_code_hash": "0xc25feb0d950d0fa605e6acd6a7b91c21ec886e57ee132177cf9856bb5f00a9fb"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "IEditionMetadataRenderer01",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IEditionMetadataRenderer01, abstract: true) {\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string)\n  function(:contractURI, :external, :view, returns: :string)\n  function(:initializeWithData, { data: [:string] }, :external)\n}\n",
        "init_code_hash": "0x8d542108f995e96ecfe8796365e1c6b24c703fd27a709e8a38858bc1f866f05a"
      },
      {
        "abi": null,
        "name": "MerkleProof",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:MerkleProof, abstract: true) {\n  function(:verify, { proof: [:bytes32], root: :bytes32, leaf: :bytes32 }, :internal, :pure, returns: :bool) {\n    processProof(proof, leaf) == root\n  }\n  function(:processProof, { proof: [:bytes32], leaf: :bytes32 }, :internal, :pure, returns: :bytes32) {\n    computedHash = leaf\n    forLoop(condition: ->(i) {\n      i < proof.length\n    }, max_iterations: 25) { |i|\n      computedHash = _hashPair(computedHash, proof[i])\n    }\n    computedHash\n  }\n  function(:_hashPair, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    if a.cast(:uint256) < b.cast(:uint256)\n      _efficientHash(a, b)\n    else\n      _efficientHash(b, a)\n    end\n  }\n  function(:_efficientHash, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    keccak256(abi.encodePacked(a, b))\n  }\n}\n",
        "init_code_hash": "0xc134d1a3fdd6d2b91b43961380d5d9cfaaaecbad1ce9c8258bee7657dfa2b3a8"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-02-17T22:36:23.516Z",
    "updated_at": "2024-02-17T22:36:23.516Z"
  },
  {
    "id": 24,
    "transaction_hash": "0x56b0e924555f1d12c0c80924e3f8c8f34482b07278dfc59c9709d5c7e4abdd12",
    "internal_transaction_index": 0,
    "block_number": 19379032,
    "transaction_index": 90,
    "name": "EtherBridge03",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetBuddy) {\n  event(:CallOnBehalfOfUser, { onBehalfOf: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, resultSuccess: :bool, resultData: :string })\n  address(:public, :factory)\n  address(:public, :erc20Bridge)\n  address(:public, :forUser)\n  bool(:locked)\n  constructor(erc20Bridge: :address, forUser: :address) {\n    s.factory=msg.sender\n    s.erc20Bridge=erc20Bridge\n    s.forUser=forUser\n  }\n  function(:_makeCall, { addressToCall: :address, calldata: :string, revertOnFailure: :bool }, :internal) {\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    initialBalance = _balance\n    _approve(addressToCall, initialBalance)\n    (success, data) = addressToCall.call(calldata)\n    require(success || !revertOnFailure, \"Call failed: (#{calldata})\")\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(s.forUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallOnBehalfOfUser, onBehalfOf: s.forUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, resultSuccess: success, resultData: data)\n  }\n  function(:callForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.forUser || msg.sender == s.factory, \"Only the user or factory can callForUser\")\n    ERC20(s.erc20Bridge).transferFrom(s.forUser, address(this), amountToSpend)\n    _makeCall(addressToCall, calldata, true)\n  }\n  function(:callFromBridge, { addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.erc20Bridge, \"Only the bridge can callFromBridge\")\n    _makeCall(addressToCall, calldata, false)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.erc20Bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).transfer(to, amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetBuddyFactory, is: [:Upgradeable], upgradeable: true) {\n  event(:BuddyCreated, { forUser: :address, buddy: :address })\n  address(:public, :erc20Bridge)\n  mapping(({ address: :address }), :public, :buddyForUser)\n  mapping(({ address: :address }), :public, :userForBuddy)\n  constructor(erc20Bridge: :address) {\n    require(erc20Bridge != address(0), \"Invalid smart contract\")\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.erc20Bridge=erc20Bridge\n  }\n  function(:findOrCreateBuddy, { forUser: :address }, :public, returns: :address) {\n    existingBuddy = s.buddyForUser[forUser]\n    if existingBuddy != address(0)\n      return existingBuddy\n    end\n    salt = keccak256(abi.encodePacked(forUser))\n    buddy = new(FacetBuddy(s.erc20Bridge, forUser, { salt: salt }))\n    require(s.userForBuddy[buddy] == address(0), \"Buddy already exists for user\")\n    s.buddyForUser[forUser] = buddy\n    s.userForBuddy[buddy] = forUser\n    emit(:BuddyCreated, forUser: forUser, buddy: buddy)\n    return buddy\n  }\n  function(:callBuddyForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    buddy = findOrCreateBuddy(msg.sender)\n    FacetBuddy(buddy).callForUser(amountToSpend: amountToSpend, addressToCall: addressToCall, calldata: calldata)\n  }\n  function(:predictBuddyAddress, { forUser: :address }, :public, :view, returns: :address) {\n    return create2_address(salt: keccak256(abi.encodePacked(forUser)), deployer: address(this), contract_type: \"FacetBuddy\")\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:EtherBridge03, is: [:ERC20, :Upgradeable, :Ownable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  address(:public, :trustedSmartContract)\n  address(:public, :facetBuddyFactory)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(name: :string, symbol: :string, trustedSmartContract: :address) {\n    require(trustedSmartContract != address(0), \"Invalid smart contract\")\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: 18)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: msg.sender)\n    s.trustedSmartContract=trustedSmartContract\n  }\n  function(:setFacetBuddyFactory, { facetBuddyFactory: :address }, :public) {\n    onlyOwner!\n    s.facetBuddyFactory=facetBuddyFactory\n    nil\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can bridge in tokens\")\n    _mint(to: to, amount: amount)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeAndCall, { to: :address, amount: :uint256, addressToCall: :address, base64Calldata: :string }, :public) {\n    if s.facetBuddyFactory == address(0)\n      return bridgeIn(to: to, amount: amount)\n    end\n    buddy = FacetBuddyFactory(s.facetBuddyFactory).findOrCreateBuddy(to)\n    bridgeIn(to: buddy, amount: amount)\n    FacetBuddy(buddy).callFromBridge(addressToCall: addressToCall, calldata: base64Calldata.base64Decode)\n  }\n  function(:predictBuddyAddress, { forUser: :address }, :public, :view, returns: :address) {\n    return FacetBuddyFactory(s.facetBuddyFactory).predictBuddyAddress(forUser)\n  }\n  function(:bridgeOut, { amount: :uint256 }, :public) {\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[msg.sender] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(amount > 0, \"Invalid amount\")\n    s.userWithdrawalId[msg.sender] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    _burn(from: msg.sender, amount: amount)\n    emit(:InitiateWithdrawal, from: msg.sender, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can mark withdrawals as complete\")\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n}\n",
    "init_code_hash": "0xdf13c05ccd7d54d7b9a8f3e2be83630c4d38d8bed6ce7e8f6a1a15466f3e9d58",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetBuddy",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetBuddy) {\n  event(:CallOnBehalfOfUser, { onBehalfOf: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, resultSuccess: :bool, resultData: :string })\n  address(:public, :factory)\n  address(:public, :erc20Bridge)\n  address(:public, :forUser)\n  bool(:locked)\n  constructor(erc20Bridge: :address, forUser: :address) {\n    s.factory=msg.sender\n    s.erc20Bridge=erc20Bridge\n    s.forUser=forUser\n  }\n  function(:_makeCall, { addressToCall: :address, calldata: :string, revertOnFailure: :bool }, :internal) {\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    initialBalance = _balance\n    _approve(addressToCall, initialBalance)\n    (success, data) = addressToCall.call(calldata)\n    require(success || !revertOnFailure, \"Call failed: (#{calldata})\")\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(s.forUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallOnBehalfOfUser, onBehalfOf: s.forUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, resultSuccess: success, resultData: data)\n  }\n  function(:callForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.forUser || msg.sender == s.factory, \"Only the user or factory can callForUser\")\n    ERC20(s.erc20Bridge).transferFrom(s.forUser, address(this), amountToSpend)\n    _makeCall(addressToCall, calldata, true)\n  }\n  function(:callFromBridge, { addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.erc20Bridge, \"Only the bridge can callFromBridge\")\n    _makeCall(addressToCall, calldata, false)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.erc20Bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).transfer(to, amount)\n  }\n}\n",
        "init_code_hash": "0xb71fdafae3610cb8e74900b8e6d43163aaab54cc6e6c54ff5b7c7570a2dabe5c"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      },
      {
        "abi": null,
        "name": "FacetBuddyFactory",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetBuddy) {\n  event(:CallOnBehalfOfUser, { onBehalfOf: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, resultSuccess: :bool, resultData: :string })\n  address(:public, :factory)\n  address(:public, :erc20Bridge)\n  address(:public, :forUser)\n  bool(:locked)\n  constructor(erc20Bridge: :address, forUser: :address) {\n    s.factory=msg.sender\n    s.erc20Bridge=erc20Bridge\n    s.forUser=forUser\n  }\n  function(:_makeCall, { addressToCall: :address, calldata: :string, revertOnFailure: :bool }, :internal) {\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    initialBalance = _balance\n    _approve(addressToCall, initialBalance)\n    (success, data) = addressToCall.call(calldata)\n    require(success || !revertOnFailure, \"Call failed: (#{calldata})\")\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(s.forUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallOnBehalfOfUser, onBehalfOf: s.forUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, resultSuccess: success, resultData: data)\n  }\n  function(:callForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.forUser || msg.sender == s.factory, \"Only the user or factory can callForUser\")\n    ERC20(s.erc20Bridge).transferFrom(s.forUser, address(this), amountToSpend)\n    _makeCall(addressToCall, calldata, true)\n  }\n  function(:callFromBridge, { addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.erc20Bridge, \"Only the bridge can callFromBridge\")\n    _makeCall(addressToCall, calldata, false)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.erc20Bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).transfer(to, amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetBuddyFactory, is: [:Upgradeable], upgradeable: true) {\n  event(:BuddyCreated, { forUser: :address, buddy: :address })\n  address(:public, :erc20Bridge)\n  mapping(({ address: :address }), :public, :buddyForUser)\n  mapping(({ address: :address }), :public, :userForBuddy)\n  constructor(erc20Bridge: :address) {\n    require(erc20Bridge != address(0), \"Invalid smart contract\")\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.erc20Bridge=erc20Bridge\n  }\n  function(:findOrCreateBuddy, { forUser: :address }, :public, returns: :address) {\n    existingBuddy = s.buddyForUser[forUser]\n    if existingBuddy != address(0)\n      return existingBuddy\n    end\n    salt = keccak256(abi.encodePacked(forUser))\n    buddy = new(FacetBuddy(s.erc20Bridge, forUser, { salt: salt }))\n    require(s.userForBuddy[buddy] == address(0), \"Buddy already exists for user\")\n    s.buddyForUser[forUser] = buddy\n    s.userForBuddy[buddy] = forUser\n    emit(:BuddyCreated, forUser: forUser, buddy: buddy)\n    return buddy\n  }\n  function(:callBuddyForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    buddy = findOrCreateBuddy(msg.sender)\n    FacetBuddy(buddy).callForUser(amountToSpend: amountToSpend, addressToCall: addressToCall, calldata: calldata)\n  }\n  function(:predictBuddyAddress, { forUser: :address }, :public, :view, returns: :address) {\n    return create2_address(salt: keccak256(abi.encodePacked(forUser)), deployer: address(this), contract_type: \"FacetBuddy\")\n  }\n}\n",
        "init_code_hash": "0xa26bdad3c05ec5c4a0e234b5f755ca9cf7311dd857250a183b74a779e3c96ef8"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-03-06T22:11:45.610Z",
    "updated_at": "2024-03-06T22:11:45.610Z"
  },
  {
    "id": 25,
    "transaction_hash": "0xc906bb1507cec6731cf89b1de348bbee677111a212f611965d4653aea01ff1e6",
    "internal_transaction_index": 0,
    "block_number": 19379037,
    "transaction_index": 100,
    "name": "TokenUpgradeRenderer01",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:INFTCollection01, abstract: true) {\n  function(:owner, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:TokenUpgradeRenderer01, is: :Upgradeable, upgradeable: true) {\n  event(:CollectionInitialized, { collection: :address, contractInfo: :ContractInfo, initialLevel: :TokenUpgradeLevel })\n  event(:UpgradeLevelUpdated, { collection: :address, index: :uint256, name: :string, imageURI: :string, animationURI: :string, startTime: :uint256, endTime: :uint256, newRecord: :bool })\n  event(:TokenUpgraded, { collection: :address, tokenId: :uint256, upgradeLevel: :uint256 })\n  event(:ContractInfoUpdated, { collection: :address, newInfo: :ContractInfo })\n  struct(:TokenUpgradeLevel) {\n    string(:name)\n    string(:imageURI)\n    string(:animationURI)\n    string(:extraAttributesJson)\n    uint256(:startTime)\n    uint256(:endTime)\n  }\n  struct(:TokenStatus) {\n    uint256(:upgradeLevel)\n    uint256(:lastUpgradeTime)\n  }\n  struct(:ContractInfo) {\n    string(:name)\n    string(:description)\n    string(:imageURI)\n  }\n  mapping(({ address: array(:TokenUpgradeLevel, 1) }), :public, :tokenUpgradeLevelsByCollection)\n  mapping(({ address: mapping(uint256: :TokenStatus) }), :public, :tokenStatusByCollection)\n  mapping(({ address: :ContractInfo }), :public, :contractInfoByCollection)\n  uint256(:public, :perUpgradeFee)\n  address(:public, :feeTo)\n  address(:public, :WETH)\n  uint256(:public, :maxUpgradeLevelCount)\n  constructor(perUpgradeFee: :uint256, feeTo: :address, weth: :address) {\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.maxUpgradeLevelCount=30\n    s.perUpgradeFee=perUpgradeFee\n    s.feeTo=feeTo\n    s.WETH=weth\n  }\n  function(:addUpgradeLevel, { collection: :address, newLevel: :TokenUpgradeLevel }, :public) {\n    requireSenderAdmin(collection)\n    lastLevel = s.tokenUpgradeLevelsByCollection[collection].last\n    require(newLevel.endTime > newLevel.startTime, \"End time must be after start time\")\n    require(newLevel.startTime > lastLevel.endTime, \"Start time must be after last level end time\")\n    require(s.tokenUpgradeLevelsByCollection[collection].length + 1 <= s.maxUpgradeLevelCount, \"Max upgrade level count reached\")\n    s.tokenUpgradeLevelsByCollection[collection].push(newLevel)\n    emit(:UpgradeLevelUpdated, collection: collection, index: s.tokenUpgradeLevelsByCollection[collection].length - 1, name: newLevel.name, imageURI: newLevel.imageURI, animationURI: newLevel.animationURI, startTime: newLevel.startTime, endTime: newLevel.endTime, newRecord: true)\n  }\n  function(:editUpgradeLevel, { collection: :address, index: :uint256, newLevel: :TokenUpgradeLevel }, :public) {\n    requireSenderAdmin(collection)\n    editingFirstLevel = index == 0\n    editingLastLevel = index == s.tokenUpgradeLevelsByCollection[collection].length.-(1)\n    unless editingLastLevel\n      nextLevel = s.tokenUpgradeLevelsByCollection[collection][index + 1]\n      require(newLevel.endTime < nextLevel.startTime, \"End time must be before next level start time\")\n    end\n    if editingFirstLevel\n      newLevel.startTime=0\n      newLevel.endTime=0\n    else\n      precedingLevel = s.tokenUpgradeLevelsByCollection[collection][index - 1]\n      require(newLevel.startTime > precedingLevel.endTime, \"Start time must be after preceding level end time\")\n      require(newLevel.endTime > newLevel.startTime, \"End time must be after start time\")\n    end\n    s.tokenUpgradeLevelsByCollection[collection][index] = newLevel\n    emit(:UpgradeLevelUpdated, collection: collection, index: index, name: newLevel.name, imageURI: newLevel.imageURI, animationURI: newLevel.animationURI, startTime: newLevel.startTime, endTime: newLevel.endTime, newRecord: false)\n  }\n  function(:activeUpgradeLevelIndex, { collection: :address }, :public, :view, returns: :uint256) {\n    forLoop(condition: ->(i) {\n      i < s.tokenUpgradeLevelsByCollection[collection].length\n    }) { |i|\n      level = s.tokenUpgradeLevelsByCollection[collection][i]\n      if level.startTime <= block.timestamp && level.endTime > block.timestamp\n        return i\n      else\n        if level.startTime > block.timestamp\n          return 0\n        end\n      end\n    }\n    return 0\n  }\n  function(:activeUpgradeLevel, { collection: :address }, :public, :view, returns: :TokenUpgradeLevel) {\n    index = activeUpgradeLevelIndex(collection)\n    return index == 0 ? TokenUpgradeLevel() : s.tokenUpgradeLevelsByCollection[collection][index]\n  }\n  function(:_upgradeToken, { collection: :address, tokenId: :uint256, activeUpgrade: :TokenUpgradeLevel }, :internal) {\n    require(ERC721(collection).isApprovedOrOwner(spender: msg.sender, id: tokenId), \"TokenUpgradeRenderer: msg.sender not authorized to upgrade id #{tokenId.toString}\")\n    tokenStatus = s.tokenStatusByCollection[collection][tokenId]\n    require(tokenStatus.lastUpgradeTime < activeUpgrade.startTime, \"TokenUpgradeRenderer: Token already upgraded during this period\")\n    targetLevelIndex = tokenStatus.upgradeLevel + 1\n    require(targetLevelIndex < s.tokenUpgradeLevelsByCollection[collection].length, \"TokenUpgradeRenderer: No more upgrade levels\")\n    tokenStatus.upgradeLevel=targetLevelIndex\n    tokenStatus.lastUpgradeTime=block.timestamp\n    emit(:TokenUpgraded, collection: collection, tokenId: tokenId, upgradeLevel: tokenStatus.upgradeLevel)\n  }\n  function(:upgradeMultipleTokens, { collection: :address, tokenIds: [:uint256] }, :public) {\n    require(tokenIds.length <= 100, \"TokenUpgradeRenderer: Cannot upgrade more than 50 tokens at once\")\n    totalFee = s.perUpgradeFee * tokenIds.length\n    if totalFee > 0 && s.feeTo != address(0)\n      ERC20(s.WETH).transferFrom(msg.sender, s.feeTo, totalFee)\n    end\n    activeUpgradeIndex = activeUpgradeLevelIndex(collection)\n    require(activeUpgradeIndex > 0, \"TokenUpgradeRenderer: No active upgrade level\")\n    activeUpgrade = s.tokenUpgradeLevelsByCollection[collection][activeUpgradeIndex]\n    forLoop(condition: ->(i) {\n      i < tokenIds.length\n    }) { |i|\n      _upgradeToken(collection: collection, tokenId: tokenIds[i], activeUpgrade: activeUpgrade)\n    }\n  }\n  function(:setContractInfo, { collection: :address, info: :ContractInfo }, :public) {\n    requireSenderAdmin(collection)\n    s.contractInfoByCollection[collection] = info\n    emit(:ContractInfoUpdated, collection: collection, newInfo: info)\n  }\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string) {\n    collection = msg.sender\n    status = s.tokenStatusByCollection[collection][tokenId]\n    upgradeLevel = s.tokenUpgradeLevelsByCollection[collection][status.upgradeLevel]\n    name_json = json.stringify(\"#{upgradeLevel.name} ##{tokenId.toString}\")\n    description_json = json.stringify(s.contractInfoByCollection[collection].description)\n    image_field = if upgradeLevel.imageURI.length == 0\n      \"\"\n    else\n      \"\\\"image\\\": #{json.stringify(upgradeLevel.imageURI)},\"\n    end\n    animation_url_field = if upgradeLevel.animationURI.length == 0\n      \"\"\n    else\n      \"\\\"animation_url\\\": #{json.stringify(upgradeLevel.animationURI)},\"\n    end\n    basic_attributes_json = json.stringify([{ trait_type: \"Number\", display_type: \"number\", value: tokenId }, { trait_type: \"Level\", value: upgradeLevel.name }])\n    extra_attributes_json = if upgradeLevel.extraAttributesJson != \"\"\n      \", \" + upgradeLevel.extraAttributesJson\n    else\n      \"\"\n    end\n    json_data = <<-HEREDOC\n    {\n      \"name\": #{name_json},\n      \"description\": #{description_json},\n      #{image_field}\n      #{animation_url_field}\n      \"attributes\": [#{basic_attributes_json[1..-2]}#{extra_attributes_json}]\n    }\n    HEREDOC\n    \"data:application/json;base64,\" + json_data.base64Encode\n  }\n  function(:initializeWithData, { contractInfo: :ContractInfo, initialLevel: :TokenUpgradeLevel }, :external) {\n    setContractInfo(collection: msg.sender, info: contractInfo)\n    editUpgradeLevel(collection: msg.sender, index: 0, newLevel: initialLevel)\n    emit(:CollectionInitialized, collection: msg.sender, contractInfo: contractInfo, initialLevel: initialLevel)\n  }\n  function(:contractURI, :external, :view, returns: :string) {\n    collection = msg.sender\n    contractInfo = s.contractInfoByCollection[collection]\n    json_data = json.stringify(name: contractInfo.name, description: contractInfo.description, image: contractInfo.imageURI)\n    \"data:application/json;base64,\" + json_data.base64Encode\n  }\n  function(:upgradeLevelCount, { collection: :address }, :public, :view, returns: :uint256) {\n    return s.tokenUpgradeLevelsByCollection[collection].length\n  }\n  function(:requireSenderAdmin, { target: :address }, :internal, :view) {\n    require(target == msg.sender || INFTCollection01(target).owner == msg.sender, \"Admin access only\")\n  }\n  function(:setFeeTo, { feeTo: :address }, :public) {\n    require(msg.sender == s.feeTo, \"Only feeTo can change feeTo\")\n    s.feeTo=feeTo\n    nil\n  }\n}\n",
    "init_code_hash": "0x070a0c891fd75ceaf600d45f7edfc18d02285a683a9db40bc8b3df0c54975859",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "INFTCollection01",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:INFTCollection01, abstract: true) {\n  function(:owner, :external, :view, returns: :address)\n}\n",
        "init_code_hash": "0xc029d89424bf16cb275e56c1012009aab295f9591b78f23bcce9f172493d46e4"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-03-06T22:12:46.303Z",
    "updated_at": "2024-03-06T22:12:46.303Z"
  },
  {
    "id": 26,
    "transaction_hash": "0x1d8731dc4ea7249b4c8333f9493c867efd0c5fdcc6e54a5f6aa562f4592cba04",
    "internal_transaction_index": 0,
    "block_number": 19379053,
    "transaction_index": 171,
    "name": "FacetBuddyFactory",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetBuddy) {\n  event(:CallOnBehalfOfUser, { onBehalfOf: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, resultSuccess: :bool, resultData: :string })\n  address(:public, :factory)\n  address(:public, :erc20Bridge)\n  address(:public, :forUser)\n  bool(:locked)\n  constructor(erc20Bridge: :address, forUser: :address) {\n    s.factory=msg.sender\n    s.erc20Bridge=erc20Bridge\n    s.forUser=forUser\n  }\n  function(:_makeCall, { addressToCall: :address, calldata: :string, revertOnFailure: :bool }, :internal) {\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    initialBalance = _balance\n    _approve(addressToCall, initialBalance)\n    (success, data) = addressToCall.call(calldata)\n    require(success || !revertOnFailure, \"Call failed: (#{calldata})\")\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(s.forUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallOnBehalfOfUser, onBehalfOf: s.forUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, resultSuccess: success, resultData: data)\n  }\n  function(:callForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.forUser || msg.sender == s.factory, \"Only the user or factory can callForUser\")\n    ERC20(s.erc20Bridge).transferFrom(s.forUser, address(this), amountToSpend)\n    _makeCall(addressToCall, calldata, true)\n  }\n  function(:callFromBridge, { addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.erc20Bridge, \"Only the bridge can callFromBridge\")\n    _makeCall(addressToCall, calldata, false)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.erc20Bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).transfer(to, amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:FacetBuddyFactory, is: [:Upgradeable], upgradeable: true) {\n  event(:BuddyCreated, { forUser: :address, buddy: :address })\n  address(:public, :erc20Bridge)\n  mapping(({ address: :address }), :public, :buddyForUser)\n  mapping(({ address: :address }), :public, :userForBuddy)\n  constructor(erc20Bridge: :address) {\n    require(erc20Bridge != address(0), \"Invalid smart contract\")\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.erc20Bridge=erc20Bridge\n  }\n  function(:findOrCreateBuddy, { forUser: :address }, :public, returns: :address) {\n    existingBuddy = s.buddyForUser[forUser]\n    if existingBuddy != address(0)\n      return existingBuddy\n    end\n    salt = keccak256(abi.encodePacked(forUser))\n    buddy = new(FacetBuddy(s.erc20Bridge, forUser, { salt: salt }))\n    require(s.userForBuddy[buddy] == address(0), \"Buddy already exists for user\")\n    s.buddyForUser[forUser] = buddy\n    s.userForBuddy[buddy] = forUser\n    emit(:BuddyCreated, forUser: forUser, buddy: buddy)\n    return buddy\n  }\n  function(:callBuddyForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    buddy = findOrCreateBuddy(msg.sender)\n    FacetBuddy(buddy).callForUser(amountToSpend: amountToSpend, addressToCall: addressToCall, calldata: calldata)\n  }\n  function(:predictBuddyAddress, { forUser: :address }, :public, :view, returns: :address) {\n    return create2_address(salt: keccak256(abi.encodePacked(forUser)), deployer: address(this), contract_type: \"FacetBuddy\")\n  }\n}\n",
    "init_code_hash": "0xa26bdad3c05ec5c4a0e234b5f755ca9cf7311dd857250a183b74a779e3c96ef8",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "FacetBuddy",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetBuddy) {\n  event(:CallOnBehalfOfUser, { onBehalfOf: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, resultSuccess: :bool, resultData: :string })\n  address(:public, :factory)\n  address(:public, :erc20Bridge)\n  address(:public, :forUser)\n  bool(:locked)\n  constructor(erc20Bridge: :address, forUser: :address) {\n    s.factory=msg.sender\n    s.erc20Bridge=erc20Bridge\n    s.forUser=forUser\n  }\n  function(:_makeCall, { addressToCall: :address, calldata: :string, revertOnFailure: :bool }, :internal) {\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    initialBalance = _balance\n    _approve(addressToCall, initialBalance)\n    (success, data) = addressToCall.call(calldata)\n    require(success || !revertOnFailure, \"Call failed: (#{calldata})\")\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(s.forUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallOnBehalfOfUser, onBehalfOf: s.forUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, resultSuccess: success, resultData: data)\n  }\n  function(:callForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.forUser || msg.sender == s.factory, \"Only the user or factory can callForUser\")\n    ERC20(s.erc20Bridge).transferFrom(s.forUser, address(this), amountToSpend)\n    _makeCall(addressToCall, calldata, true)\n  }\n  function(:callFromBridge, { addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.erc20Bridge, \"Only the bridge can callFromBridge\")\n    _makeCall(addressToCall, calldata, false)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.erc20Bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).transfer(to, amount)\n  }\n}\n",
        "init_code_hash": "0xb71fdafae3610cb8e74900b8e6d43163aaab54cc6e6c54ff5b7c7570a2dabe5c"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-03-06T22:15:59.061Z",
    "updated_at": "2024-03-06T22:15:59.061Z"
  },
  {
    "id": 27,
    "transaction_hash": "0x83bf95a5141a0a511774811f7a2a949bb3bb0bd299b7734a3d224fd5874a5e25",
    "internal_transaction_index": 1,
    "block_number": 19379273,
    "transaction_index": 72,
    "name": "FacetBuddy",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:FacetBuddy) {\n  event(:CallOnBehalfOfUser, { onBehalfOf: :address, addressToCall: :address, calldata: :string, initialAmount: :uint256, finalAmount: :uint256, resultSuccess: :bool, resultData: :string })\n  address(:public, :factory)\n  address(:public, :erc20Bridge)\n  address(:public, :forUser)\n  bool(:locked)\n  constructor(erc20Bridge: :address, forUser: :address) {\n    s.factory=msg.sender\n    s.erc20Bridge=erc20Bridge\n    s.forUser=forUser\n  }\n  function(:_makeCall, { addressToCall: :address, calldata: :string, revertOnFailure: :bool }, :internal) {\n    require(addressToCall != address(this), \"Cannot call self\")\n    require(!s.locked, \"No reentrancy allowed\")\n    s.locked=true\n    initialBalance = _balance\n    _approve(addressToCall, initialBalance)\n    (success, data) = addressToCall.call(calldata)\n    require(success || !revertOnFailure, \"Call failed: (#{calldata})\")\n    _approve(addressToCall, 0)\n    finalBalance = _balance\n    if finalBalance > 0\n      _transfer(s.forUser, finalBalance)\n    end\n    s.locked=false\n    emit(:CallOnBehalfOfUser, onBehalfOf: s.forUser, addressToCall: addressToCall, calldata: calldata, initialAmount: initialBalance, finalAmount: finalBalance, resultSuccess: success, resultData: data)\n  }\n  function(:callForUser, { amountToSpend: :uint256, addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.forUser || msg.sender == s.factory, \"Only the user or factory can callForUser\")\n    ERC20(s.erc20Bridge).transferFrom(s.forUser, address(this), amountToSpend)\n    _makeCall(addressToCall, calldata, true)\n  }\n  function(:callFromBridge, { addressToCall: :address, calldata: :string }, :public) {\n    require(msg.sender == s.erc20Bridge, \"Only the bridge can callFromBridge\")\n    _makeCall(addressToCall, calldata, false)\n  }\n  function(:_balance, :internal, :view, returns: :uint256) {\n    ERC20(s.erc20Bridge).balanceOf(address(this))\n  }\n  function(:_approve, { spender: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).approve(spender, amount)\n  }\n  function(:_transfer, { to: :address, amount: :uint256 }, :internal, returns: :bool) {\n    ERC20(s.erc20Bridge).transfer(to, amount)\n  }\n}\n",
    "init_code_hash": "0xb71fdafae3610cb8e74900b8e6d43163aaab54cc6e6c54ff5b7c7570a2dabe5c",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-03-06T23:00:12.690Z",
    "updated_at": "2024-03-06T23:00:12.690Z"
  },
  {
    "id": 28,
    "transaction_hash": "0xae1141cada867b2158c5431ce1fb0485302bce905ab76fb344ffa71147f4aad0",
    "internal_transaction_index": 0,
    "block_number": 19406883,
    "transaction_index": 31,
    "name": "NFTCollection01",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:IEditionMetadataRenderer01, abstract: true) {\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string)\n  function(:contractURI, :external, :view, returns: :string)\n  function(:initializeWithData, { data: [:string] }, :external)\n}\ncontract(:MerkleProof, abstract: true) {\n  function(:verify, { proof: [:bytes32], root: :bytes32, leaf: :bytes32 }, :internal, :pure, returns: :bool) {\n    processProof(proof, leaf) == root\n  }\n  function(:processProof, { proof: [:bytes32], leaf: :bytes32 }, :internal, :pure, returns: :bytes32) {\n    computedHash = leaf\n    forLoop(condition: ->(i) {\n      i < proof.length\n    }, max_iterations: 25) { |i|\n      computedHash = _hashPair(computedHash, proof[i])\n    }\n    computedHash\n  }\n  function(:_hashPair, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    if a.cast(:uint256) < b.cast(:uint256)\n      _efficientHash(a, b)\n    else\n      _efficientHash(b, a)\n    end\n  }\n  function(:_efficientHash, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    keccak256(abi.encodePacked(a, b))\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:NFTCollection01, is: [:ERC721, :ERC2981, :Upgradeable, :Ownable, :Pausable, :MerkleProof], upgradeable: true) {\n  event(:Minted, { to: :address, amount: :uint256, mintPrice: :uint256, totalCost: :uint256, newTotalSupply: :uint256, isPublic: :bool })\n  event(:PublicMaxPerAddressUpdated, { publicMaxPerAddress: :uint256 })\n  event(:PublicMintStartUpdated, { publicMintStart: :uint256 })\n  event(:PublicMintEndUpdated, { publicMintEnd: :uint256 })\n  event(:PublicMintPriceUpdated, { publicMintPrice: :uint256 })\n  event(:AllowListMerkleRootUpdated, { allowListMerkleRoot: :bytes32 })\n  event(:AllowListMaxPerAddressUpdated, { allowListMaxPerAddress: :uint256 })\n  event(:AllowListMintStartUpdated, { allowListMintStart: :uint256 })\n  event(:AllowListMintEndUpdated, { allowListMintEnd: :uint256 })\n  event(:AllowListMintPriceUpdated, { allowListMintPrice: :uint256 })\n  event(:MaxSupplyUpdated, { maxSupply: :uint256 })\n  event(:BaseURIUpdated, { baseURI: :string })\n  event(:MetadataRendererUpdated, { metadataRenderer: :string })\n  uint256(:public, :maxSupply)\n  uint256(:public, :totalSupply)\n  uint256(:public, :nextTokenId)\n  uint256(:public, :maxPerMint)\n  string(:public, :baseURI)\n  address(:public, :WETH)\n  address(:public, :metadataRenderer)\n  uint256(:public, :publicMaxPerAddress)\n  uint256(:public, :publicMintStart)\n  uint256(:public, :publicMintEnd)\n  uint256(:public, :publicMintPrice)\n  bytes32(:public, :allowListMerkleRoot)\n  uint256(:public, :allowListMaxPerAddress)\n  uint256(:public, :allowListMintStart)\n  uint256(:public, :allowListMintEnd)\n  uint256(:public, :allowListMintPrice)\n  uint256(:public, :perMintFee)\n  address(:public, :feeTo)\n  mapping(({ address: :uint256 }), :public, :publicNumberMinted)\n  mapping(({ address: :uint256 }), :public, :allowListNumberMinted)\n  constructor(name: :string, symbol: :string, maxSupply: :uint256, baseURI: :string, weth: :address, perMintFee: :uint256, feeTo: :address) {\n    self.ERC721.constructor(name: name, symbol: symbol)\n    self.Ownable.constructor(owner: msg.sender)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.maxSupply=maxSupply\n    s.baseURI=baseURI\n    s.WETH=weth\n    s.maxPerMint=25\n    s.perMintFee=perMintFee\n    s.feeTo=feeTo\n    s.nextTokenId=1\n  }\n  function(:_handleMint, { to: :address, amount: :uint256, merkleProof: [:bytes32] }, :internal) {\n    whenNotPaused!\n    require(isMintActive, \"Mint is not active\")\n    require(amount > 0, \"Amount must be positive\")\n    require(s.maxSupply == 0 || s.totalSupply + amount <= s.maxSupply, \"Exceeded max supply\")\n    require(amount <= s.maxPerMint, \"Exceeded max per mint\")\n    isAllowListMint = merkleProof.length > 0 && isAllowListMintActive\n    (numberMinted, mintPrice, maxPerAddress) = if isAllowListMint\n      require(isOnAllowList(to, merkleProof), \"Not on allow list\")\n      s.allowListNumberMinted[to] += amount\n      [s.allowListNumberMinted[to], s.allowListMintPrice, s.allowListMaxPerAddress]\n    else\n      s.publicNumberMinted[to] += amount\n      [s.publicNumberMinted[to], s.publicMintPrice, s.publicMaxPerAddress]\n    end\n    require(maxPerAddress == 0 || numberMinted <= maxPerAddress, \"Exceeded mint limit\")\n    totalFee = s.perMintFee * amount\n    if totalFee > 0 && s.feeTo != address(0)\n      ERC20(s.WETH).transferFrom(msg.sender, s.feeTo, totalFee)\n    end\n    totalCost = mintPrice * amount\n    if totalCost > 0\n      require(s.WETH != address(0), \"WETH not set\")\n      ERC20(s.WETH).transferFrom(msg.sender, address(this), totalCost)\n    end\n    initialId = s.nextTokenId\n    s.nextTokenId += amount\n    s.totalSupply += amount\n    forLoop(condition: ->(i) {\n      i < amount\n    }, max_iterations: s.maxPerMint) { |i|\n      _mint(to: to, id: initialId + i)\n    }\n    emit(:Minted, to: to, amount: amount, mintPrice: mintPrice, totalCost: totalCost, newTotalSupply: s.totalSupply, isPublic: !isAllowListMint)\n  }\n  function(:_isMintActive, { mintStart: :uint256, mintEnd: :uint256 }, :internal, :view, returns: :bool) {\n    isNotMintedOut = s.maxSupply == 0 || s.totalSupply < s.maxSupply\n    isOwner = s.owner == msg.sender\n    isOrAfterStart = block.timestamp >= mintStart && mintStart > 0\n    isBeforeEnd = block.timestamp < mintEnd || mintEnd == 0\n    isNotMintedOut && isBeforeEnd && (isOwner || isOrAfterStart)\n  }\n  function(:isPublicMintActive, :public, :view, returns: :bool) {\n    _isMintActive(mintStart: s.publicMintStart, mintEnd: s.publicMintEnd)\n  }\n  function(:isAllowListMintActive, :public, :view, returns: :bool) {\n    _isMintActive(mintStart: s.allowListMintStart, mintEnd: s.allowListMintEnd)\n  }\n  function(:isMintActive, :public, :view, returns: :bool) {\n    isPublicMintActive || isAllowListMintActive\n  }\n  function(:isOnAllowList, { wallet: :address, merkleProof: [:bytes32] }, :public, :view, returns: :bool) {\n    self.MerkleProof.verify(merkleProof, s.allowListMerkleRoot, keccak256(abi.encodePacked(wallet)))\n  }\n  function(:tokenURI, { tokenId: :uint256 }, :public, :view, :override, returns: :string) {\n    require(_exists(id: tokenId), \"URI query for nonexistent token\")\n    if s.metadataRenderer != address(0)\n      return IEditionMetadataRenderer01(s.metadataRenderer).tokenURI(tokenId)\n    end\n    if s.baseURI.length == 0\n      return \"\"\n    end\n    if s.baseURI[s.baseURI.length - 1] != \"/\"\n      return s.baseURI\n    end\n    s.baseURI + tokenId.toString\n  }\n  function(:contractURI, :public, :view, returns: :string) {\n    if s.metadataRenderer == address(0)\n      return \"\"\n    end\n    IEditionMetadataRenderer01(s.metadataRenderer).contractURI\n  }\n  function(:airdrop, { to: :address, amount: :uint256, merkleProof: [:bytes32] }, :public) {\n    _handleMint(to: to, amount: amount, merkleProof: merkleProof)\n  }\n  function(:mint, { amount: :uint256, merkleProof: [:bytes32] }, :public) {\n    _handleMint(to: msg.sender, amount: amount, merkleProof: merkleProof)\n  }\n  function(:setPublicMaxPerAddress, { publicMaxPerAddress: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMaxPerAddress=publicMaxPerAddress\n    emit(:PublicMaxPerAddressUpdated, publicMaxPerAddress: publicMaxPerAddress)\n  }\n  function(:setPublicMintStart, { publicMintStart: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintStart=publicMintStart\n    emit(:PublicMintStartUpdated, publicMintStart: publicMintStart)\n  }\n  function(:setPublicMintEnd, { publicMintEnd: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintEnd=publicMintEnd\n    emit(:PublicMintEndUpdated, publicMintEnd: publicMintEnd)\n  }\n  function(:setPublicMintPrice, { publicMintPrice: :uint256 }, :public) {\n    onlyOwner!\n    s.publicMintPrice=publicMintPrice\n    emit(:PublicMintPriceUpdated, publicMintPrice: publicMintPrice)\n  }\n  function(:setAllowListMerkleRoot, { allowListMerkleRoot: :bytes32 }, :public) {\n    onlyOwner!\n    s.allowListMerkleRoot=allowListMerkleRoot\n    emit(:AllowListMerkleRootUpdated, allowListMerkleRoot: allowListMerkleRoot)\n  }\n  function(:setAllowListMaxPerAddress, { allowListMaxPerAddress: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMaxPerAddress=allowListMaxPerAddress\n    emit(:AllowListMaxPerAddressUpdated, allowListMaxPerAddress: allowListMaxPerAddress)\n  }\n  function(:setAllowListMintStart, { allowListMintStart: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintStart=allowListMintStart\n    emit(:AllowListMintStartUpdated, allowListMintStart: allowListMintStart)\n  }\n  function(:setAllowListMintEnd, { allowListMintEnd: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintEnd=allowListMintEnd\n    emit(:AllowListMintEndUpdated, allowListMintEnd: allowListMintEnd)\n  }\n  function(:setAllowListMintPrice, { allowListMintPrice: :uint256 }, :public) {\n    onlyOwner!\n    s.allowListMintPrice=allowListMintPrice\n    emit(:AllowListMintPriceUpdated, allowListMintPrice: allowListMintPrice)\n  }\n  function(:setMaxSupply, { maxSupply: :uint256 }, :public) {\n    onlyOwner!\n    require(s.maxSupply == 0, \"Max supply already set\")\n    require(maxSupply >= s.totalSupply, \"New max supply must be greater than total supply\")\n    s.maxSupply=maxSupply\n    emit(:MaxSupplyUpdated, maxSupply: maxSupply)\n  }\n  function(:setMetadataRenderer, { metadataRenderer: :address, data: :string }, :public) {\n    onlyOwner!\n    s.metadataRenderer=metadataRenderer\n    if data.length > 0\n      (success, _) = metadataRenderer.call(data)\n      require(success, \"setMetadataRenderer failed\")\n    end\n    emit(:MetadataRendererUpdated, metadataRenderer: metadataRenderer)\n  }\n  function(:setPublicMintSettings, { publicMaxPerAddress: :uint256, publicMintStart: :uint256, publicMintEnd: :uint256, publicMintPrice: :uint256 }, :public) {\n    setPublicMaxPerAddress(publicMaxPerAddress)\n    setPublicMintStart(publicMintStart)\n    setPublicMintEnd(publicMintEnd)\n    setPublicMintPrice(publicMintPrice)\n  }\n  function(:setAllowListMintSettings, { allowListMerkleRoot: :bytes32, allowListMaxPerAddress: :uint256, allowListMintStart: :uint256, allowListMintEnd: :uint256, allowListMintPrice: :uint256 }, :public) {\n    setAllowListMerkleRoot(allowListMerkleRoot)\n    setAllowListMaxPerAddress(allowListMaxPerAddress)\n    setAllowListMintStart(allowListMintStart)\n    setAllowListMintEnd(allowListMintEnd)\n    setAllowListMintPrice(allowListMintPrice)\n  }\n  function(:setBaseURI, { baseURI: :string }, :public) {\n    onlyOwner!\n    s.baseURI=baseURI\n    emit(:BaseURIUpdated, baseURI: baseURI)\n  }\n  function(:burn, { tokenId: :uint256 }, :public) {\n    require(isApprovedOrOwner(spender: msg.sender, id: tokenId), \"ERC721: msg.sender not authorized to burn id #{tokenId.toString}\")\n    s.totalSupply -= 1\n    _burn(tokenId)\n  }\n  function(:burnMultiple, { tokenIds: [:uint256] }, :public) {\n    require(tokenIds.length > 0, \"No token ids provided\")\n    require(tokenIds.length <= 20, \"Too many token ids provided\")\n    forLoop(condition: ->(i) {\n      i < tokenIds.length\n    }, max_iterations: 20) { |i|\n      burn(tokenIds[i])\n    }\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n  function(:withdrawWETH, :public, returns: :bool) {\n    onlyOwner!\n    amount = ERC20(s.WETH).balanceOf(address(this))\n    ERC20(s.WETH).transfer(s.owner, amount)\n  }\n  function(:setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :public) {\n    onlyOwner!\n    _setDefaultRoyalty(receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:deleteDefaultRoyalty, :public) {\n    onlyOwner!\n    _deleteDefaultRoyalty\n  }\n  function(:setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :public) {\n    onlyOwner!\n    _setTokenRoyalty(tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:deleteTokenRoyalty, { tokenId: :uint256 }, :public) {\n    onlyOwner!\n    _deleteTokenRoyalty(tokenId)\n  }\n  function(:setFeeTo, { feeTo: :address }, :public) {\n    require(msg.sender == s.feeTo, \"Only feeTo can change feeTo\")\n    s.feeTo=feeTo\n    nil\n  }\n}\n",
    "init_code_hash": "0xb5b742d755877bac6b80e2f0af4d97792fce2b2a58ff0ee2274b86eac91e977f",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC2981",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC2981, abstract: true) {\n  event(:DefaultRoyaltyUpdated, { receiver: :address, feeNumerator: :uint96 })\n  event(:TokenRoyaltyUpdated, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 })\n  mapping(({ uint256: :address }), :internal, :_tokenIdToReceiver)\n  mapping(({ uint256: :uint96 }), :internal, :_tokenIdToFeeNumerator)\n  address(:internal, :_defaultRoyaltyReceiver)\n  uint96(:internal, :_defaultFeeNumerator)\n  function(:royaltyInfo, { tokenId: :uint256, salePrice: :uint256 }, :public, :view, :virtual, returns: { receiver: :address, royaltyAmount: :uint256 }) {\n    receiver = s._tokenIdToReceiver[tokenId]\n    feeNumerator = s._tokenIdToFeeNumerator[tokenId]\n    if receiver == address(0)\n      receiver = s._defaultRoyaltyReceiver\n      feeNumerator = s._defaultFeeNumerator\n    end\n    royaltyAmount = (salePrice * feeNumerator).div(_feeDenominator)\n    return { receiver: receiver, royaltyAmount: royaltyAmount }\n  }\n  function(:_setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidDefaultRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidDefaultRoyaltyReceiver: address(0)\")\n    s._defaultRoyaltyReceiver=receiver\n    s._defaultFeeNumerator=feeNumerator\n    emit(:DefaultRoyaltyUpdated, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteDefaultRoyalty, :internal, :virtual) {\n    s._defaultRoyaltyReceiver=address(0)\n    s._defaultFeeNumerator=0\n    emit(:DefaultRoyaltyUpdated, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :internal, :virtual) {\n    require(feeNumerator <= _feeDenominator, \"ERC2981InvalidTokenRoyalty\")\n    require(receiver != address(0), \"ERC2981InvalidTokenRoyaltyReceiver\")\n    s._tokenIdToReceiver[tokenId] = receiver\n    s._tokenIdToFeeNumerator[tokenId] = feeNumerator\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)\n  }\n  function(:_deleteTokenRoyalty, { tokenId: :uint256 }, :internal, :virtual) {\n    s._tokenIdToReceiver[tokenId] = address(0)\n    s._tokenIdToFeeNumerator[tokenId] = 0\n    emit(:TokenRoyaltyUpdated, tokenId: tokenId, receiver: address(0), feeNumerator: 0)\n  }\n  function(:_feeDenominator, :internal, :view, :virtual, returns: :uint96) {\n    return 10000\n  }\n  function(:supportsERC2981, :public, :pure, :virtual, returns: :bool) {\n    return true\n  }\n}\n",
        "init_code_hash": "0xc25feb0d950d0fa605e6acd6a7b91c21ec886e57ee132177cf9856bb5f00a9fb"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "IEditionMetadataRenderer01",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IEditionMetadataRenderer01, abstract: true) {\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string)\n  function(:contractURI, :external, :view, returns: :string)\n  function(:initializeWithData, { data: [:string] }, :external)\n}\n",
        "init_code_hash": "0x8d542108f995e96ecfe8796365e1c6b24c703fd27a709e8a38858bc1f866f05a"
      },
      {
        "abi": null,
        "name": "MerkleProof",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:MerkleProof, abstract: true) {\n  function(:verify, { proof: [:bytes32], root: :bytes32, leaf: :bytes32 }, :internal, :pure, returns: :bool) {\n    processProof(proof, leaf) == root\n  }\n  function(:processProof, { proof: [:bytes32], leaf: :bytes32 }, :internal, :pure, returns: :bytes32) {\n    computedHash = leaf\n    forLoop(condition: ->(i) {\n      i < proof.length\n    }, max_iterations: 25) { |i|\n      computedHash = _hashPair(computedHash, proof[i])\n    }\n    computedHash\n  }\n  function(:_hashPair, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    if a.cast(:uint256) < b.cast(:uint256)\n      _efficientHash(a, b)\n    else\n      _efficientHash(b, a)\n    end\n  }\n  function(:_efficientHash, { a: :bytes32, b: :bytes32 }, :private, :pure, returns: :bytes32) {\n    keccak256(abi.encodePacked(a, b))\n  }\n}\n",
        "init_code_hash": "0xc134d1a3fdd6d2b91b43961380d5d9cfaaaecbad1ce9c8258bee7657dfa2b3a8"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-03-10T19:48:32.551Z",
    "updated_at": "2024-03-10T19:48:32.551Z"
  },
  {
    "id": 29,
    "transaction_hash": "0xf9444f81311be032cae6c9ce6c5c396b430f0705c4c8b8c68d70b7e28df5301e",
    "internal_transaction_index": 0,
    "block_number": 19413769,
    "transaction_index": 152,
    "name": "ERC20BatchTransfer",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC20BatchTransfer) {\n  event(:BatchTransfer, { tokenAddress: :address, recipients: [:address], amounts: [:uint256] })\n  event(:WithdrawStuckTokens, { tokenAddress: :address, to: :address, amount: :uint256 })\n  uint256(:public, :singleTxAirdropLimit)\n  constructor {\n    s.singleTxAirdropLimit=50\n  }\n  function(:batchTransfer, { tokenAddress: :address, recipients: [:address], amounts: [:uint256] }, :public) {\n    require(recipients.length > 0, \"Must import at least one address\")\n    require(recipients.length == amounts.length, \"Address and amount arrays must be the same length\")\n    require(recipients.length <= s.singleTxAirdropLimit, \"Cannot import more than #{s.singleTxAirdropLimit.toString} addresses at a time\")\n    forLoop(condition: ->(i) {\n      i < recipients.length\n    }, max_iterations: s.singleTxAirdropLimit) { |i|\n      to = recipients[i]\n      amount = amounts[i]\n      ERC20(tokenAddress).transferFrom(from: msg.sender, to: to, amount: amount)\n    }\n    emit(:BatchTransfer, tokenAddress: tokenAddress, recipients: recipients, amounts: amounts)\n  }\n  function(:withdrawStuckTokens, { tokenAddress: :address, to: :address, amount: :uint256 }, :public) {\n    ERC20(tokenAddress).transfer(to: to, amount: amount)\n    emit(:WithdrawStuckTokens, tokenAddress: tokenAddress, to: to, amount: amount)\n  }\n}\n",
    "init_code_hash": "0x52c3226b3e5045a92e0a3975978997b7e5af223021470a1deb14211511dd04c9",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-03-11T18:54:54.110Z",
    "updated_at": "2024-03-11T18:54:54.110Z"
  },
  {
    "id": 30,
    "transaction_hash": "0x7a42626da516d461642e0331a7dfdb8af9108b5499750603c9f43c8903a17059",
    "internal_transaction_index": 0,
    "block_number": 19413789,
    "transaction_index": 94,
    "name": "TokenUpgradeRenderer01",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:INFTCollection01, abstract: true) {\n  function(:owner, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:TokenUpgradeRenderer01, is: :Upgradeable, upgradeable: true) {\n  event(:CollectionInitialized, { collection: :address, contractInfo: :ContractInfo, initialLevel: :TokenUpgradeLevel })\n  event(:UpgradeLevelUpdated, { collection: :address, index: :uint256, name: :string, imageURI: :string, animationURI: :string, startTime: :uint256, endTime: :uint256, newRecord: :bool })\n  event(:TokenUpgraded, { collection: :address, tokenId: :uint256, upgradeLevel: :uint256 })\n  event(:ContractInfoUpdated, { collection: :address, newInfo: :ContractInfo })\n  struct(:TokenUpgradeLevel) {\n    string(:name)\n    string(:imageURI)\n    string(:animationURI)\n    string(:extraAttributesJson)\n    uint256(:startTime)\n    uint256(:endTime)\n  }\n  struct(:TokenStatus) {\n    uint256(:upgradeLevel)\n    uint256(:lastUpgradeTime)\n  }\n  struct(:ContractInfo) {\n    string(:name)\n    string(:description)\n    string(:imageURI)\n  }\n  mapping(({ address: array(:TokenUpgradeLevel, 1) }), :public, :tokenUpgradeLevelsByCollection)\n  mapping(({ address: mapping(uint256: :TokenStatus) }), :public, :tokenStatusByCollection)\n  mapping(({ address: :ContractInfo }), :public, :contractInfoByCollection)\n  uint256(:public, :perUpgradeFee)\n  address(:public, :feeTo)\n  address(:public, :WETH)\n  uint256(:public, :maxUpgradeLevelCount)\n  constructor(perUpgradeFee: :uint256, feeTo: :address, weth: :address) {\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.maxUpgradeLevelCount=30\n    s.perUpgradeFee=perUpgradeFee\n    s.feeTo=feeTo\n    s.WETH=weth\n  }\n  function(:addUpgradeLevel, { collection: :address, newLevel: :TokenUpgradeLevel }, :public) {\n    requireSenderAdmin(collection)\n    lastLevel = s.tokenUpgradeLevelsByCollection[collection].last\n    require(newLevel.endTime > newLevel.startTime, \"End time must be after start time\")\n    require(newLevel.startTime > lastLevel.endTime, \"Start time must be after last level end time\")\n    require(s.tokenUpgradeLevelsByCollection[collection].length + 1 <= s.maxUpgradeLevelCount, \"Max upgrade level count reached\")\n    s.tokenUpgradeLevelsByCollection[collection].push(newLevel)\n    emit(:UpgradeLevelUpdated, collection: collection, index: s.tokenUpgradeLevelsByCollection[collection].length - 1, name: newLevel.name, imageURI: newLevel.imageURI, animationURI: newLevel.animationURI, startTime: newLevel.startTime, endTime: newLevel.endTime, newRecord: true)\n  }\n  function(:editUpgradeLevel, { collection: :address, index: :uint256, newLevel: :TokenUpgradeLevel }, :public) {\n    requireSenderAdmin(collection)\n    editingFirstLevel = index == 0\n    editingLastLevel = index == s.tokenUpgradeLevelsByCollection[collection].length.-(1)\n    unless editingLastLevel\n      nextLevel = s.tokenUpgradeLevelsByCollection[collection][index + 1]\n      require(newLevel.endTime < nextLevel.startTime, \"End time must be before next level start time\")\n    end\n    if editingFirstLevel\n      newLevel.startTime=0\n      newLevel.endTime=0\n    else\n      precedingLevel = s.tokenUpgradeLevelsByCollection[collection][index - 1]\n      require(newLevel.startTime > precedingLevel.endTime, \"Start time must be after preceding level end time\")\n      require(newLevel.endTime > newLevel.startTime, \"End time must be after start time\")\n    end\n    s.tokenUpgradeLevelsByCollection[collection][index] = newLevel\n    emit(:UpgradeLevelUpdated, collection: collection, index: index, name: newLevel.name, imageURI: newLevel.imageURI, animationURI: newLevel.animationURI, startTime: newLevel.startTime, endTime: newLevel.endTime, newRecord: false)\n  }\n  function(:activeUpgradeLevelIndex, { collection: :address }, :public, :view, returns: :uint256) {\n    forLoop(condition: ->(i) {\n      i < s.tokenUpgradeLevelsByCollection[collection].length\n    }) { |i|\n      level = s.tokenUpgradeLevelsByCollection[collection][i]\n      if level.startTime <= block.timestamp && level.endTime > block.timestamp\n        return i\n      else\n        if level.startTime > block.timestamp\n          return 0\n        end\n      end\n    }\n    return 0\n  }\n  function(:activeUpgradeLevel, { collection: :address }, :public, :view, returns: :TokenUpgradeLevel) {\n    index = activeUpgradeLevelIndex(collection)\n    return index == 0 ? TokenUpgradeLevel() : s.tokenUpgradeLevelsByCollection[collection][index]\n  }\n  function(:_upgradeToken, { collection: :address, tokenId: :uint256, activeUpgrade: :TokenUpgradeLevel }, :internal) {\n    require(ERC721(collection).isApprovedOrOwner(spender: msg.sender, id: tokenId), \"TokenUpgradeRenderer: msg.sender not authorized to upgrade id #{tokenId.toString}\")\n    tokenStatus = s.tokenStatusByCollection[collection][tokenId]\n    require(tokenStatus.lastUpgradeTime < activeUpgrade.startTime, \"TokenUpgradeRenderer: Token already upgraded during this period\")\n    targetLevelIndex = tokenStatus.upgradeLevel + 1\n    require(targetLevelIndex < s.tokenUpgradeLevelsByCollection[collection].length, \"TokenUpgradeRenderer: No more upgrade levels\")\n    tokenStatus.upgradeLevel=targetLevelIndex\n    tokenStatus.lastUpgradeTime=block.timestamp\n    emit(:TokenUpgraded, collection: collection, tokenId: tokenId, upgradeLevel: tokenStatus.upgradeLevel)\n  }\n  function(:upgradeMultipleTokens, { collection: :address, tokenIds: [:uint256] }, :public) {\n    require(tokenIds.length <= 100, \"TokenUpgradeRenderer: Cannot upgrade more than 50 tokens at once\")\n    totalFee = s.perUpgradeFee * tokenIds.length\n    if totalFee > 0 && s.feeTo != address(0)\n      ERC20(s.WETH).transferFrom(msg.sender, s.feeTo, totalFee)\n    end\n    activeUpgradeIndex = activeUpgradeLevelIndex(collection)\n    require(activeUpgradeIndex > 0, \"TokenUpgradeRenderer: No active upgrade level\")\n    activeUpgrade = s.tokenUpgradeLevelsByCollection[collection][activeUpgradeIndex]\n    forLoop(condition: ->(i) {\n      i < tokenIds.length\n    }) { |i|\n      _upgradeToken(collection: collection, tokenId: tokenIds[i], activeUpgrade: activeUpgrade)\n    }\n  }\n  function(:setContractInfo, { collection: :address, info: :ContractInfo }, :public) {\n    requireSenderAdmin(collection)\n    s.contractInfoByCollection[collection] = info\n    emit(:ContractInfoUpdated, collection: collection, newInfo: info)\n  }\n  function(:lastUpgradeLevel, { collection: :address, tokenId: :uint256 }, :public, :view, returns: :TokenUpgradeLevel) {\n    status = s.tokenStatusByCollection[collection][tokenId]\n    upgradeTime = status.lastUpgradeTime\n    if upgradeTime == 0\n      return TokenUpgradeLevel()\n    end\n    forLoop(condition: ->(i) {\n      i < s.tokenUpgradeLevelsByCollection[collection].length\n    }) { |i|\n      level = s.tokenUpgradeLevelsByCollection[collection][i]\n      if level.startTime <= upgradeTime && level.endTime > upgradeTime\n        return level\n      end\n    }\n    return TokenUpgradeLevel()\n  }\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string) {\n    collection = msg.sender\n    status = s.tokenStatusByCollection[collection][tokenId]\n    upgradeLevel = s.tokenUpgradeLevelsByCollection[collection][status.upgradeLevel]\n    name_json = json.stringify(\"#{upgradeLevel.name} ##{tokenId.toString}\")\n    description_json = json.stringify(s.contractInfoByCollection[collection].description)\n    image_field = if upgradeLevel.imageURI.length == 0\n      \"\"\n    else\n      \"\\\"image\\\": #{json.stringify(upgradeLevel.imageURI)},\\n\"\n    end\n    animation_url_field = if upgradeLevel.animationURI.length == 0\n      \"\"\n    else\n      \"\\\"animation_url\\\": #{json.stringify(upgradeLevel.animationURI)},\\n\"\n    end\n    last_level = lastUpgradeLevel(collection: collection, tokenId: tokenId)\n    last_upgrade_level_json = if last_level != TokenUpgradeLevel()\n      \", {\\\"trait_type\\\": \\\"Last Upgrade Level\\\", \\\"value\\\": #{json.stringify(last_level.name)}}\\n\"\n    else\n      \"\"\n    end\n    extra_attributes_json = if upgradeLevel.extraAttributesJson != \"\"\n      \", \" + upgradeLevel.extraAttributesJson\n    else\n      \"\"\n    end\n    json_data = <<-HEREDOC\n    {\n      \"name\": #{name_json},\n      \"description\": #{description_json},\n      #{image_field}\n      #{animation_url_field}\n      \"attributes\": [\n        {\"trait_type\": \"Number\", \"display_type\": \"number\", \"value\": #{tokenId.toString}},\n        {\"trait_type\": \"Level\", \"value\": #{json.stringify(upgradeLevel.name)}}\n        #{last_upgrade_level_json}\n        #{extra_attributes_json}\n      ]\n    }\n    HEREDOC\n    \"data:application/json;base64,\" + json_data.base64Encode\n  }\n  function(:initializeWithData, { contractInfo: :ContractInfo, initialLevel: :TokenUpgradeLevel }, :external) {\n    setContractInfo(collection: msg.sender, info: contractInfo)\n    editUpgradeLevel(collection: msg.sender, index: 0, newLevel: initialLevel)\n    emit(:CollectionInitialized, collection: msg.sender, contractInfo: contractInfo, initialLevel: initialLevel)\n  }\n  function(:contractURI, :external, :view, returns: :string) {\n    collection = msg.sender\n    contractInfo = s.contractInfoByCollection[collection]\n    json_data = json.stringify(name: contractInfo.name, description: contractInfo.description, image: contractInfo.imageURI)\n    \"data:application/json;base64,\" + json_data.base64Encode\n  }\n  function(:upgradeLevelCount, { collection: :address }, :public, :view, returns: :uint256) {\n    return s.tokenUpgradeLevelsByCollection[collection].length\n  }\n  function(:requireSenderAdmin, { target: :address }, :internal, :view) {\n    require(target == msg.sender || INFTCollection01(target).owner == msg.sender, \"Admin access only\")\n  }\n  function(:setFeeTo, { feeTo: :address }, :public) {\n    require(msg.sender == s.feeTo, \"Only feeTo can change feeTo\")\n    s.feeTo=feeTo\n    nil\n  }\n}\n",
    "init_code_hash": "0x2dbec15cf7c23393357f0336e0058ca1c48e8f694324a6d95334f539598d9bf5",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "INFTCollection01",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:INFTCollection01, abstract: true) {\n  function(:owner, :external, :view, returns: :address)\n}\n",
        "init_code_hash": "0xc029d89424bf16cb275e56c1012009aab295f9591b78f23bcce9f172493d46e4"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-03-11T18:58:58.434Z",
    "updated_at": "2024-03-11T18:58:58.434Z"
  },
  {
    "id": 31,
    "transaction_hash": "0xb76862add39dae62fa1aefede5fc3fd87f1d98d7f9bc3ea2d3a4c568484b5c1e",
    "internal_transaction_index": 0,
    "block_number": 19561604,
    "transaction_index": 102,
    "name": "ERC20BridgeFactory",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:ERC20Bridge, is: [:ERC20, :Upgradeable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  address(:public, :factory)\n  address(:public, :tokenSmartContract)\n  address(:public, :trustedSmartContract)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(tokenSmartContract: :address, trustedSmartContract: :address, name: :string, symbol: :string, decimals: :uint8) {\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: decimals)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.tokenSmartContract=tokenSmartContract\n    s.trustedSmartContract=trustedSmartContract\n    s.factory=msg.sender\n  }\n  function(:onlyFactory!, :internal) {\n    require(msg.sender == s.factory, \"Only the factory can call this function\")\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    onlyFactory!\n    _mint(to: to, amount: amount)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeOut, { from: :address, amount: :uint256 }, :public) {\n    onlyFactory!\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[from] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(amount > 0, \"Invalid amount\")\n    s.userWithdrawalId[from] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    _burn(from: from, amount: amount)\n    emit(:InitiateWithdrawal, from: from, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    onlyFactory!\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:ERC20BridgeFactory, is: [:Ownable, :Pausable, :Upgradeable], upgradeable: true) {\n  event(:FactoryBridgedIn, { to: :address, amount: :uint256, smartContract: :address, dumbContract: :address })\n  event(:FactoryInitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32, smartContract: :address, dumbContract: :address })\n  event(:FactoryWithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32, smartContract: :address, dumbContract: :address })\n  event(:BridgeCreated, { newBridge: :address, tokenSmartContract: :address })\n  address(:public, :trustedSmartContract)\n  mapping(({ address: :address }), :public, :bridgeDumbContractToTokenSmartContract)\n  mapping(({ address: :address }), :public, :tokenSmartContractToBridgeDumbContract)\n  constructor(trustedSmartContract: :address) {\n    require(trustedSmartContract != address(0), \"Invalid smart contract\")\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: msg.sender)\n    s.trustedSmartContract=trustedSmartContract\n  }\n  function(:onlyTrustedSmartContract!, :internal) {\n    require(msg.sender == s.trustedSmartContract, \"Only the trusted smart contract can call this function\")\n  }\n  function(:bridgeIn, { tokenSmartContract: :address, decimals: :uint8, symbol: :string, name: :string, to: :address, amount: :uint256 }, :public) {\n    onlyTrustedSmartContract!\n    bridge = findOrCreateBridge(tokenSmartContract: tokenSmartContract, decimals: decimals, symbol: symbol, name: name)\n    ERC20Bridge(bridge).bridgeIn(to: to, amount: amount)\n    emit(:FactoryBridgedIn, to: to, amount: amount, dumbContract: bridge, smartContract: tokenSmartContract)\n  }\n  function(:bridgeIntoExistingBridge, { tokenSmartContract: :address, to: :address, amount: :uint256 }, :public) {\n    onlyTrustedSmartContract!\n    bridge = s.tokenSmartContractToBridgeDumbContract[tokenSmartContract]\n    require(bridge != address(0), \"Bridge not found\")\n    ERC20Bridge(bridge).bridgeIn(to: to, amount: amount)\n    emit(:FactoryBridgedIn, to: to, amount: amount, dumbContract: bridge, smartContract: tokenSmartContract)\n  }\n  function(:findOrCreateBridge, { tokenSmartContract: :address, decimals: :uint8, symbol: :string, name: :string }, :internal, returns: :address) {\n    existingBridge = s.tokenSmartContractToBridgeDumbContract[tokenSmartContract]\n    if existingBridge != address(0)\n      return existingBridge\n    end\n    salt = keccak256(abi.encodePacked(tokenSmartContract))\n    bridge = new(ERC20Bridge(tokenSmartContract, s.trustedSmartContract, \"Facet #{name}\", \"f#{symbol.upcase}\", decimals, { salt: salt }))\n    require(s.bridgeDumbContractToTokenSmartContract[bridge] == address(0), \"Bridge already exists\")\n    s.tokenSmartContractToBridgeDumbContract[tokenSmartContract] = bridge\n    s.bridgeDumbContractToTokenSmartContract[bridge] = tokenSmartContract\n    emit(:BridgeCreated, newBridge: bridge, tokenSmartContract: tokenSmartContract)\n    return bridge\n  }\n  function(:bridgeOut, { bridgeDumbContract: :address, amount: :uint256 }, :public) {\n    whenNotPaused!\n    smartContract = s.bridgeDumbContractToTokenSmartContract[bridgeDumbContract]\n    require(smartContract != address(0), \"Bridge not found\")\n    ERC20Bridge(bridgeDumbContract).bridgeOut(from: msg.sender, amount: amount)\n    emit(:FactoryInitiateWithdrawal, from: msg.sender, amount: amount, withdrawalId: tx.current_transaction_hash, dumbContract: bridgeDumbContract, smartContract: smartContract)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32, tokenSmartContract: :address }, :public) {\n    onlyTrustedSmartContract!\n    dumbContract = s.tokenSmartContractToBridgeDumbContract[tokenSmartContract]\n    amount = ERC20Bridge(dumbContract).withdrawalIdAmount(withdrawalId)\n    ERC20Bridge(dumbContract).markWithdrawalComplete(to: to, withdrawalId: withdrawalId)\n    emit(:FactoryWithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId, dumbContract: dumbContract, smartContract: tokenSmartContract)\n  }\n  function(:predictBridgeAddress, { tokenSmartContract: :address }, :public, :view, returns: :address) {\n    existing = s.tokenSmartContractToBridgeDumbContract[tokenSmartContract]\n    if existing != address(0)\n      return existing\n    end\n    return create2_address(salt: keccak256(abi.encodePacked(tokenSmartContract)), deployer: address(this), contract_type: \"ERC20Bridge\")\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n}\n",
    "init_code_hash": "0x9022ced2f52aee8b28119f0490767a6e0b80b492642364382e609b6e84d85ce0",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      },
      {
        "abi": null,
        "name": "ERC20Bridge",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:ERC20Bridge, is: [:ERC20, :Upgradeable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  address(:public, :factory)\n  address(:public, :tokenSmartContract)\n  address(:public, :trustedSmartContract)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(tokenSmartContract: :address, trustedSmartContract: :address, name: :string, symbol: :string, decimals: :uint8) {\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: decimals)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.tokenSmartContract=tokenSmartContract\n    s.trustedSmartContract=trustedSmartContract\n    s.factory=msg.sender\n  }\n  function(:onlyFactory!, :internal) {\n    require(msg.sender == s.factory, \"Only the factory can call this function\")\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    onlyFactory!\n    _mint(to: to, amount: amount)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeOut, { from: :address, amount: :uint256 }, :public) {\n    onlyFactory!\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[from] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(amount > 0, \"Invalid amount\")\n    s.userWithdrawalId[from] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    _burn(from: from, amount: amount)\n    emit(:InitiateWithdrawal, from: from, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    onlyFactory!\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n}\n",
        "init_code_hash": "0xcae364f38cd61ae19f32d460fc14eb8e62ebd0a5cc26b1a95dfac3d5d834c1aa"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-04-01T14:34:55.398Z",
    "updated_at": "2024-04-01T14:34:55.398Z"
  },
  {
    "id": 32,
    "transaction_hash": "0x16a3fb3005571e87effe2d1f43b60351842545e80dafc026b0c6af2b0b0903d6",
    "internal_transaction_index": 1,
    "block_number": 19561922,
    "transaction_index": 248,
    "name": "ERC20Bridge",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:ERC20Bridge, is: [:ERC20, :Upgradeable], upgradeable: true) {\n  event(:BridgedIn, { to: :address, amount: :uint256 })\n  event(:InitiateWithdrawal, { from: :address, amount: :uint256, withdrawalId: :bytes32 })\n  event(:WithdrawalComplete, { to: :address, amount: :uint256, withdrawalId: :bytes32 })\n  address(:public, :factory)\n  address(:public, :tokenSmartContract)\n  address(:public, :trustedSmartContract)\n  mapping(({ bytes32: :uint256 }), :public, :withdrawalIdAmount)\n  mapping(({ address: :bytes32 }), :public, :userWithdrawalId)\n  constructor(tokenSmartContract: :address, trustedSmartContract: :address, name: :string, symbol: :string, decimals: :uint8) {\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: decimals)\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.tokenSmartContract=tokenSmartContract\n    s.trustedSmartContract=trustedSmartContract\n    s.factory=msg.sender\n  }\n  function(:onlyFactory!, :internal) {\n    require(msg.sender == s.factory, \"Only the factory can call this function\")\n  }\n  function(:bridgeIn, { to: :address, amount: :uint256 }, :public) {\n    onlyFactory!\n    _mint(to: to, amount: amount)\n    emit(:BridgedIn, to: to, amount: amount)\n  }\n  function(:bridgeOut, { from: :address, amount: :uint256 }, :public) {\n    onlyFactory!\n    withdrawalId = tx.current_transaction_hash\n    require(s.userWithdrawalId[from] == bytes32(0), \"Withdrawal pending\")\n    require(s.withdrawalIdAmount[withdrawalId] == 0, \"Already bridged out\")\n    require(amount > 0, \"Invalid amount\")\n    s.userWithdrawalId[from] = withdrawalId\n    s.withdrawalIdAmount[withdrawalId] = amount\n    _burn(from: from, amount: amount)\n    emit(:InitiateWithdrawal, from: from, amount: amount, withdrawalId: withdrawalId)\n  }\n  function(:markWithdrawalComplete, { to: :address, withdrawalId: :bytes32 }, :public) {\n    onlyFactory!\n    require(s.userWithdrawalId[to] == withdrawalId, \"Withdrawal id not found\")\n    amount = s.withdrawalIdAmount[withdrawalId]\n    s.withdrawalIdAmount[withdrawalId] = 0\n    s.userWithdrawalId[to] = bytes32(0)\n    emit(:WithdrawalComplete, to: to, amount: amount, withdrawalId: withdrawalId)\n  }\n}\n",
    "init_code_hash": "0xcae364f38cd61ae19f32d460fc14eb8e62ebd0a5cc26b1a95dfac3d5d834c1aa",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-04-01T15:38:44.057Z",
    "updated_at": "2024-04-01T15:38:44.057Z"
  },
  {
    "id": 33,
    "transaction_hash": "0x62f8c2119001e221d181889000262947cda71c051e61efc82081c6e87ce14540",
    "internal_transaction_index": 0,
    "block_number": 19562525,
    "transaction_index": 158,
    "name": "ERC20Locker",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:ERC20Locker, is: [:Ownable, :Upgradeable, :Pausable], upgradeable: true) {\n  event(:Deposit, { token: :address, amount: :uint256, lockDate: :uint256, unlockDate: :uint256, withdrawer: :address, lockId: :uint256 })\n  event(:Relock, { token: :address, lockId: :uint256, unlockDate: :uint256 })\n  event(:Withdraw, { token: :address, amount: :uint256, withdrawer: :address, lockId: :uint256 })\n  struct(:TokenLock) {\n    uint256(:lockId)\n    address(:token)\n    address(:owner)\n    uint256(:amount)\n    uint256(:lockDate)\n    uint256(:unlockDate)\n  }\n  uint256(:public, :nextLockId)\n  mapping(({ uint256: :TokenLock }), :public, :tokenLocks)\n  constructor {\n    s.nextLockId=1\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    self.Ownable.constructor(owner: msg.sender)\n  }\n  function(:lockToken, { token: :address, amount: :uint256, unlockDate: :uint256, withdrawer: :address }, :public) {\n    whenNotPaused!\n    require(unlockDate < 10000000000, \"Timestamp is in seconds\")\n    require(unlockDate > block.timestamp, \"Unlock time must be in the future\")\n    require(amount > 0, \"Amount must be greater than 0\")\n    require(withdrawer != address(0), \"Invalid withdrawer\")\n    require(ERC20(token).transferFrom(msg.sender, address(this), amount), \"Transfer failed\")\n    tokenLock = TokenLock(lockId: s.nextLockId, token: token, owner: withdrawer, amount: amount, lockDate: block.timestamp, unlockDate: unlockDate)\n    require(s.tokenLocks[tokenLock.lockId] == TokenLock(), \"Lock already exists\")\n    s.tokenLocks[tokenLock.lockId] = tokenLock\n    s.nextLockId += 1\n    emit(:Deposit, token: tokenLock.token, amount: tokenLock.amount, lockDate: tokenLock.lockDate, unlockDate: tokenLock.unlockDate, withdrawer: tokenLock.owner, lockId: tokenLock.lockId)\n  }\n  function(:relock, { lockId: :uint256, unlockDate: :uint256 }, :public) {\n    tokenLock = s.tokenLocks[lockId]\n    require(tokenLock.owner == msg.sender, \"Only owner\")\n    require(unlockDate < 10000000000, \"Timestamp is in seconds\")\n    require(unlockDate > block.timestamp, \"Unlock time must be in the future\")\n    require(unlockDate > tokenLock.unlockDate, \"Unlock date must be after current unlock date\")\n    tokenLock.unlockDate=unlockDate\n    emit(:Relock, token: tokenLock.token, lockId: lockId, unlockDate: unlockDate)\n  }\n  function(:withdraw, { lockId: :uint256, amount: :uint256 }, :public) {\n    tokenLock = s.tokenLocks[lockId]\n    require(tokenLock.owner == msg.sender, \"Only owner\")\n    require(amount > 0, \"Amount must be greater than 0\")\n    require(tokenLock != TokenLock(), \"Lock does not exist\")\n    require(block.timestamp > tokenLock.unlockDate, \"Tokens are still locked\")\n    require(tokenLock.amount >= amount, \"Insufficient balance\")\n    tokenLock.amount -= amount\n    token = tokenLock.token\n    if tokenLock.amount == 0\n      s.tokenLocks[lockId] = TokenLock()\n    end\n    require(ERC20(token).transfer(msg.sender, amount), \"Transfer failed\")\n    emit(:Withdraw, token: token, amount: amount, withdrawer: msg.sender, lockId: lockId)\n  }\n  function(:pause, :public) {\n    onlyOwner!\n    _pause\n  }\n  function(:unpause, :public) {\n    onlyOwner!\n    _unpause\n  }\n}\n",
    "init_code_hash": "0xa2a9d5bf9901d7a15ae08ceb568dac12d14dab2d5994ec8037feae7aeeb4e2c7",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      },
      {
        "abi": null,
        "name": "Pausable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Pausable, abstract: true) {\n  bool(:public, :paused)\n  event(:Paused, { account: :address })\n  event(:Unpaused, { account: :address })\n  constructor(initialPauseState: :bool) {\n    s.paused=initialPauseState\n  }\n  function(:_pause, :internal) {\n    s.paused=true\n    emit(:Paused, account: msg.sender)\n  }\n  function(:_unpause, :internal) {\n    s.paused=false\n    emit(:Unpaused, account: msg.sender)\n  }\n  function(:whenPaused!, :internal) {\n    require(s.paused, \"Contract is not paused\")\n  }\n  function(:whenNotPaused!, :internal) {\n    require(!s.paused, \"Contract is paused\")\n  }\n}\n",
        "init_code_hash": "0xd4e665c2e4682e834df21d993a1a1755363401ff922e8d15f8835b5bdb369f66"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-04-01T17:40:37.649Z",
    "updated_at": "2024-04-01T17:40:37.649Z"
  },
  {
    "id": 66,
    "transaction_hash": "0xd686627e8c583e214e9a6dad52dcfc98f3c2c94afb04f37498f734bc0b12e0f4",
    "internal_transaction_index": 0,
    "block_number": 19835191,
    "transaction_index": 55,
    "name": "PresaleERC20",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:getPair, { arg0: :address, arg1: :address }, :public, returns: :address)\n}\ncontract(:IFacetSwapV1Router, abstract: true) {\n  function(:addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, returns: { amountA: :uint256, amountB: :uint256, liquidity: :uint256 })\n  function(:factory, :public, returns: :address)\n}\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\ncontract(:PresaleERC20, is: [:ERC20, :Ownable]) {\n  event(:PresaleStarted, {})\n  event(:PresaleFinalized, {})\n  event(:PresaleBuy, { buyer: :address, amount: :uint256 })\n  event(:PresaleSell, { seller: :address, amount: :uint256 })\n  event(:TokensClaimed, { user: :address, shareAmount: :uint256, tokenAmount: :uint256 })\n  address(:public, :wethAddress)\n  address(:public, :facetSwapRouterAddress)\n  address(:public, :pairAddress)\n  uint256(:public, :presaleEndTime)\n  uint256(:public, :presaleDuration)\n  mapping(({ address: :uint256 }), :public, :shares)\n  uint256(:public, :totalShares)\n  uint256(:public, :maxSupply)\n  uint256(:public, :tokensForPresale)\n  constructor(name: :string, symbol: :string, _wethAddress: :address, _facetSwapRouterAddress: :address, _maxSupply: :uint256, _presaleTokenPercentage: :uint256, _presaleDuration: :uint256) {\n    require(_presaleTokenPercentage <= 50, \"Presale token percentage must not exceed 50\")\n    require(_presaleTokenPercentage > 0, \"Presale token percentage must exceed 0\")\n    require(_wethAddress != address(0), \"WETH address not set\")\n    decimals = ERC20(_wethAddress).decimals\n    self.ERC20.constructor(name: name, symbol: symbol, decimals: decimals)\n    self.Ownable.constructor(owner: msg.sender)\n    s.wethAddress=_wethAddress\n    s.facetSwapRouterAddress=_facetSwapRouterAddress\n    s.maxSupply=_maxSupply\n    s.tokensForPresale=(_maxSupply * _presaleTokenPercentage) / 100\n    s.presaleDuration=_presaleDuration\n  }\n  function(:buyShares, { recipient: :address, amount: :uint256 }, :public) {\n    require(s.presaleEndTime > 0, \"Presale has not started\")\n    require(block.timestamp < s.presaleEndTime, \"Presale has ended\")\n    require(amount > 0, \"Amount must be greater than 0\")\n    s.shares[recipient] += amount\n    s.totalShares += amount\n    ERC20(s.wethAddress).transferFrom(msg.sender, address(this), amount)\n    emit(:PresaleBuy, buyer: recipient, amount: amount)\n  }\n  function(:sellShares, { amount: :uint256 }, :public) {\n    require(s.presaleEndTime > 0, \"Presale has not started\")\n    require(block.timestamp < s.presaleEndTime, \"Presale has ended\")\n    require(amount > 0, \"Amount must be greater than 0\")\n    require(s.shares[msg.sender] >= amount, \"Not enough shares\")\n    s.shares[msg.sender] -= amount\n    s.totalShares -= amount\n    ERC20(s.wethAddress).transfer(msg.sender, amount)\n    emit(:PresaleSell, seller: msg.sender, amount: amount)\n  }\n  function(:claimTokens, :public) {\n    userShares = s.shares[msg.sender]\n    require(userShares > 0, \"User does not own shares\")\n    if s.pairAddress == address(0)\n      finalize\n    end\n    tokensPerShare = s.tokensForPresale / s.totalShares\n    tokenAmount = userShares * tokensPerShare\n    _mint(to: msg.sender, amount: tokenAmount)\n    s.shares[msg.sender] = 0\n    emit(:TokensClaimed, user: msg.sender, shareAmount: userShares, tokenAmount: tokenAmount)\n  }\n  function(:calculateDust, :internal, :view, returns: :uint256) {\n    tokensPerShare = s.tokensForPresale / s.totalShares\n    totalDistributedTokens = tokensPerShare * s.totalShares\n    return s.tokensForPresale - totalDistributedTokens\n  }\n  function(:finalize, :public) {\n    require(s.pairAddress == address(0), \"Already finalized\")\n    require(block.timestamp >= s.presaleEndTime, \"Presale not finished\")\n    dust = calculateDust\n    tokensForTeam = s.maxSupply - s.tokensForPresale.*(2)\n    _mint(to: address(this), amount: s.tokensForPresale + dust + tokensForTeam)\n    s.allowance[address(this)][s.facetSwapRouterAddress] = s.tokensForPresale\n    ERC20(s.wethAddress).approve(spender: s.facetSwapRouterAddress, amount: s.totalShares)\n    IFacetSwapV1Router(s.facetSwapRouterAddress).addLiquidity(tokenA: address(this), tokenB: s.wethAddress, amountADesired: s.tokensForPresale, amountBDesired: s.totalShares, amountAMin: 0, amountBMin: 0, to: address(0), deadline: block.timestamp)\n    factoryAddress = IFacetSwapV1Router(s.facetSwapRouterAddress).factory\n    s.pairAddress=IFacetSwapV1Factory(factoryAddress).getPair(address(this), s.wethAddress)\n    emit(:PresaleFinalized)\n  }\n  function(:burn, { amount: :uint256 }, :public) {\n    _burn(from: msg.sender, amount: amount)\n  }\n  function(:withdrawTokens, { recipient: :address }, :public) {\n    onlyOwner!\n    balance = balanceOf(address(this))\n    require(balance > 0, \"No token balance\")\n    ERC20(address(this)).transfer(recipient, balance)\n    return nil\n  }\n  function(:startPresale, :public) {\n    onlyOwner!\n    require(s.presaleEndTime == 0, \"Already started\")\n    s.presaleEndTime=block.timestamp + s.presaleDuration\n    emit(:PresaleStarted)\n  }\n}\n",
    "init_code_hash": "0x4bddad53945dd1d0b155207b1e6a9d641a7658788ac6b35e02bbfae63ccdd6f0",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Factory",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Factory, abstract: true) {\n  function(:getPair, { arg0: :address, arg1: :address }, :public, returns: :address)\n}\n",
        "init_code_hash": "0x99678d3fa6faed5cc032eaf2f1311e791552339bd02c9b0b23327bc513fccc49"
      },
      {
        "abi": null,
        "name": "IFacetSwapV1Router",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:IFacetSwapV1Router, abstract: true) {\n  function(:addLiquidity, { tokenA: :address, tokenB: :address, amountADesired: :uint256, amountBDesired: :uint256, amountAMin: :uint256, amountBMin: :uint256, to: :address, deadline: :uint256 }, :public, returns: { amountA: :uint256, amountB: :uint256, liquidity: :uint256 })\n  function(:factory, :public, returns: :address)\n}\n",
        "init_code_hash": "0x6c93050b1c2e9c97d50caadb69d97680403d798c3e8aef72108d8a2b1708c7e9"
      },
      {
        "abi": null,
        "name": "Ownable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Ownable, abstract: true) {\n  address(:public, :owner)\n  event(:OwnershipTransferred, { previousOwner: :address, newOwner: :address })\n  constructor(owner: :address) {\n    s.owner=owner\n  }\n  function(:transferOwnership, { newOwner: :address }, :public) {\n    onlyOwner!\n    previousOwner = s.owner\n    s.owner=newOwner\n    emit(:OwnershipTransferred, previousOwner: previousOwner, newOwner: newOwner)\n  }\n  function(:onlyOwner!, :internal) {\n    require(msg.sender == s.owner, \"msg.sender is not the owner\")\n  }\n}\n",
        "init_code_hash": "0xe5b06d7daddedbafdf18d2aa38e5fc914e0141460986738cf6133d808126fad8"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-05-09T21:33:12.443Z",
    "updated_at": "2024-05-09T21:33:12.443Z"
  },
  {
    "id": 67,
    "transaction_hash": "0x67cc6ca8901e376298fe752748da81e477caa821adaaf87b6a311bddbbf3687b",
    "internal_transaction_index": 0,
    "block_number": 19927293,
    "transaction_index": 101,
    "name": "TokenUpgradeRenderer02",
    "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\ncontract(:INFTCollection01, abstract: true) {\n  function(:owner, :external, :view, returns: :address)\n}\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\ncontract(:TokenUpgradeRenderer02, is: :Upgradeable, upgradeable: true) {\n  event(:CollectionInitialized, { collection: :address, contractInfo: :ContractInfo, initialLevel: :TokenUpgradeLevel })\n  event(:UpgradeLevelUpdated, { collection: :address, index: :uint256, name: :string, imageURI: :string, animationURI: :string, startTime: :uint256, endTime: :uint256, newRecord: :bool })\n  event(:TokenUpgraded, { collection: :address, tokenId: :uint256, upgradeLevel: :uint256 })\n  event(:ContractInfoUpdated, { collection: :address, newInfo: :ContractInfo })\n  struct(:TokenUpgradeLevel) {\n    string(:name)\n    string(:imageURI)\n    string(:animationURI)\n    string(:extraAttributesJson)\n    uint256(:startTime)\n    uint256(:endTime)\n  }\n  struct(:TokenStatus) {\n    uint256(:upgradeLevel)\n    uint256(:lastUpgradeTime)\n  }\n  struct(:ContractInfo) {\n    string(:name)\n    string(:description)\n    string(:imageURI)\n  }\n  mapping(({ address: array(:TokenUpgradeLevel, 1) }), :public, :tokenUpgradeLevelsByCollection)\n  mapping(({ address: mapping(uint256: :TokenStatus) }), :public, :tokenStatusByCollection)\n  mapping(({ address: :ContractInfo }), :public, :contractInfoByCollection)\n  mapping(({ address: mapping(uint256: array(:string)) }), :public, :tokenUpgradeLevelImageURIsByCollection)\n  mapping(({ address: mapping(uint256: :bytes32) }), :public, :blockHashByTokenLevelByCollection)\n  uint256(:public, :perUpgradeFee)\n  address(:public, :feeTo)\n  address(:public, :WETH)\n  uint256(:public, :maxUpgradeLevelCount)\n  constructor(perUpgradeFee: :uint256, feeTo: :address, weth: :address) {\n    self.Upgradeable.constructor(upgradeAdmin: msg.sender)\n    s.maxUpgradeLevelCount=30\n    s.perUpgradeFee=perUpgradeFee\n    s.feeTo=feeTo\n    s.WETH=weth\n  }\n  function(:addUpgradeLevel, { collection: :address, newLevel: :TokenUpgradeLevel, imageURIs: [:string] }, :public) {\n    requireSenderAdmin(collection)\n    lastLevel = s.tokenUpgradeLevelsByCollection[collection].last\n    require(newLevel.endTime > newLevel.startTime, \"End time must be after start time\")\n    require(newLevel.startTime > lastLevel.endTime, \"Start time must be after last level end time\")\n    require(s.tokenUpgradeLevelsByCollection[collection].length + 1 <= s.maxUpgradeLevelCount, \"Max upgrade level count reached\")\n    require(imageURIs.length <= 25, \"Max 25 image URIs allowed\")\n    s.tokenUpgradeLevelsByCollection[collection].push(newLevel)\n    index = s.tokenUpgradeLevelsByCollection[collection].length - 1\n    s.tokenUpgradeLevelImageURIsByCollection[collection][index] = imageURIs\n    s.blockHashByTokenLevelByCollection[collection][index] = blockhash(block.number)\n    emit(:UpgradeLevelUpdated, collection: collection, index: s.tokenUpgradeLevelsByCollection[collection].length - 1, name: newLevel.name, imageURI: newLevel.imageURI, animationURI: newLevel.animationURI, startTime: newLevel.startTime, endTime: newLevel.endTime, newRecord: true)\n  }\n  function(:editUpgradeLevel, { collection: :address, index: :uint256, newLevel: :TokenUpgradeLevel, imageURIs: [:string] }, :public) {\n    requireSenderAdmin(collection)\n    require(imageURIs.length <= 25, \"Max 25 image URIs allowed\")\n    editingFirstLevel = index == 0\n    editingLastLevel = index == s.tokenUpgradeLevelsByCollection[collection].length.-(1)\n    unless editingLastLevel\n      nextLevel = s.tokenUpgradeLevelsByCollection[collection][index + 1]\n      require(newLevel.endTime < nextLevel.startTime, \"End time must be before next level start time\")\n    end\n    if editingFirstLevel\n      newLevel.startTime=0\n      newLevel.endTime=0\n    else\n      precedingLevel = s.tokenUpgradeLevelsByCollection[collection][index - 1]\n      require(newLevel.startTime > precedingLevel.endTime, \"Start time must be after preceding level end time\")\n      require(newLevel.endTime > newLevel.startTime, \"End time must be after start time\")\n    end\n    s.tokenUpgradeLevelsByCollection[collection][index] = newLevel\n    s.tokenUpgradeLevelImageURIsByCollection[collection][index] = imageURIs\n    emit(:UpgradeLevelUpdated, collection: collection, index: index, name: newLevel.name, imageURI: newLevel.imageURI, animationURI: newLevel.animationURI, startTime: newLevel.startTime, endTime: newLevel.endTime, newRecord: false)\n  }\n  function(:activeUpgradeLevelIndex, { collection: :address }, :public, :view, returns: :uint256) {\n    forLoop(condition: ->(i) {\n      i < s.tokenUpgradeLevelsByCollection[collection].length\n    }) { |i|\n      level = s.tokenUpgradeLevelsByCollection[collection][i]\n      if level.startTime <= block.timestamp && level.endTime > block.timestamp\n        return i\n      else\n        if level.startTime > block.timestamp\n          return 0\n        end\n      end\n    }\n    return 0\n  }\n  function(:activeUpgradeLevel, { collection: :address }, :public, :view, returns: :TokenUpgradeLevel) {\n    index = activeUpgradeLevelIndex(collection)\n    return index == 0 ? TokenUpgradeLevel() : s.tokenUpgradeLevelsByCollection[collection][index]\n  }\n  function(:_upgradeToken, { collection: :address, tokenId: :uint256, activeUpgrade: :TokenUpgradeLevel }, :internal) {\n    require(ERC721(collection).isApprovedOrOwner(spender: msg.sender, id: tokenId), \"TokenUpgradeRenderer: msg.sender not authorized to upgrade id #{tokenId.toString}\")\n    tokenStatus = s.tokenStatusByCollection[collection][tokenId]\n    require(tokenStatus.lastUpgradeTime < activeUpgrade.startTime, \"TokenUpgradeRenderer: Token already upgraded during this period\")\n    targetLevelIndex = tokenStatus.upgradeLevel + 1\n    require(targetLevelIndex < s.tokenUpgradeLevelsByCollection[collection].length, \"TokenUpgradeRenderer: No more upgrade levels\")\n    tokenStatus.upgradeLevel=targetLevelIndex\n    tokenStatus.lastUpgradeTime=block.timestamp\n    emit(:TokenUpgraded, collection: collection, tokenId: tokenId, upgradeLevel: tokenStatus.upgradeLevel)\n  }\n  function(:upgradeMultipleTokens, { collection: :address, tokenIds: [:uint256] }, :public) {\n    require(tokenIds.length <= 100, \"TokenUpgradeRenderer: Cannot upgrade more than 50 tokens at once\")\n    totalFee = s.perUpgradeFee * tokenIds.length\n    if totalFee > 0 && s.feeTo != address(0)\n      ERC20(s.WETH).transferFrom(msg.sender, s.feeTo, totalFee)\n    end\n    activeUpgradeIndex = activeUpgradeLevelIndex(collection)\n    require(activeUpgradeIndex > 0, \"TokenUpgradeRenderer: No active upgrade level\")\n    activeUpgrade = s.tokenUpgradeLevelsByCollection[collection][activeUpgradeIndex]\n    forLoop(condition: ->(i) {\n      i < tokenIds.length\n    }) { |i|\n      _upgradeToken(collection: collection, tokenId: tokenIds[i], activeUpgrade: activeUpgrade)\n    }\n  }\n  function(:setContractInfo, { collection: :address, info: :ContractInfo }, :public) {\n    requireSenderAdmin(collection)\n    s.contractInfoByCollection[collection] = info\n    emit(:ContractInfoUpdated, collection: collection, newInfo: info)\n  }\n  function(:lastUpgradeLevel, { collection: :address, tokenId: :uint256 }, :public, :view, returns: :TokenUpgradeLevel) {\n    status = s.tokenStatusByCollection[collection][tokenId]\n    upgradeTime = status.lastUpgradeTime\n    if upgradeTime == 0\n      return TokenUpgradeLevel()\n    end\n    forLoop(condition: ->(i) {\n      i < s.tokenUpgradeLevelsByCollection[collection].length\n    }) { |i|\n      level = s.tokenUpgradeLevelsByCollection[collection][i]\n      if level.startTime <= upgradeTime && level.endTime > upgradeTime\n        return level\n      end\n    }\n    return TokenUpgradeLevel()\n  }\n  function(:tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string) {\n    collection = msg.sender\n    status = s.tokenStatusByCollection[collection][tokenId]\n    upgradeLevel = s.tokenUpgradeLevelsByCollection[collection][status.upgradeLevel]\n    name_json = json.stringify(\"#{upgradeLevel.name} ##{tokenId.toString}\")\n    description_json = json.stringify(s.contractInfoByCollection[collection].description)\n    uriAryLength = s.tokenUpgradeLevelImageURIsByCollection[collection][status.upgradeLevel].length\n    imageURI = if uriAryLength > 0\n      blockhash = s.blockHashByTokenLevelByCollection[collection][status.upgradeLevel]\n      entropy = uint256(keccak256(abi.encodePacked(collection, blockhash, tokenId)))\n      s.tokenUpgradeLevelImageURIsByCollection[collection][status.upgradeLevel][entropy % uriAryLength]\n    else\n      upgradeLevel.imageURI\n    end\n    image_field = if imageURI.length == 0\n      \"\"\n    else\n      \"\\\"image\\\": #{json.stringify(imageURI)},\\n\"\n    end\n    animation_url_field = if upgradeLevel.animationURI.length == 0\n      \"\"\n    else\n      \"\\\"animation_url\\\": #{json.stringify(upgradeLevel.animationURI)},\\n\"\n    end\n    last_level = lastUpgradeLevel(collection: collection, tokenId: tokenId)\n    last_upgrade_level_json = if last_level != TokenUpgradeLevel()\n      \", {\\\"trait_type\\\": \\\"Last Upgrade Level\\\", \\\"value\\\": #{json.stringify(last_level.name)}}\\n\"\n    else\n      \"\"\n    end\n    extra_attributes_json = if upgradeLevel.extraAttributesJson != \"\"\n      \", \" + upgradeLevel.extraAttributesJson\n    else\n      \"\"\n    end\n    json_data = <<-HEREDOC\n    {\n      \"name\": #{name_json},\n      \"description\": #{description_json},\n      #{image_field}\n      #{animation_url_field}\n      \"attributes\": [\n        {\"trait_type\": \"Number\", \"display_type\": \"number\", \"value\": #{tokenId.toString}},\n        {\"trait_type\": \"Level\", \"value\": #{json.stringify(upgradeLevel.name)}}\n        #{last_upgrade_level_json}\n        #{extra_attributes_json}\n      ]\n    }\n    HEREDOC\n    \"data:application/json;base64,\" + json_data.base64Encode\n  }\n  function(:initializeWithData, { contractInfo: :ContractInfo, initialLevel: :TokenUpgradeLevel }, :external) {\n    setContractInfo(collection: msg.sender, info: contractInfo)\n    editUpgradeLevel(collection: msg.sender, index: 0, newLevel: initialLevel)\n    emit(:CollectionInitialized, collection: msg.sender, contractInfo: contractInfo, initialLevel: initialLevel)\n  }\n  function(:contractURI, :external, :view, returns: :string) {\n    collection = msg.sender\n    contractInfo = s.contractInfoByCollection[collection]\n    json_data = json.stringify(name: contractInfo.name, description: contractInfo.description, image: contractInfo.imageURI)\n    \"data:application/json;base64,\" + json_data.base64Encode\n  }\n  function(:upgradeLevelCount, { collection: :address }, :public, :view, returns: :uint256) {\n    return s.tokenUpgradeLevelsByCollection[collection].length\n  }\n  function(:requireSenderAdmin, { target: :address }, :internal, :view) {\n    require(target == msg.sender || INFTCollection01(target).owner == msg.sender, \"Admin access only\")\n  }\n  function(:setFeeTo, { feeTo: :address }, :public) {\n    require(msg.sender == s.feeTo, \"Only feeTo can change feeTo\")\n    s.feeTo=feeTo\n    nil\n  }\n}\n",
    "init_code_hash": "0x048cc2bb0751a06b409ab438941182f7c4e753eb2b3c5a40b338d7c44d7b43d1",
    "references": [
      {
        "abi": null,
        "name": "ERC20",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC20, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, amount: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, amount: :uint256 })\n  string(:public, :name)\n  string(:public, :symbol)\n  uint8(:public, :decimals)\n  uint256(:public, :totalSupply)\n  mapping(({ address: :uint256 }), :public, :balanceOf)\n  mapping(({ address: mapping(address: :uint256) }), :public, :allowance)\n  constructor(name: :string, symbol: :string, decimals: :uint8) {\n    s.name=name\n    s.symbol=symbol\n    s.decimals=decimals\n  }\n  function(:approve, { spender: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    s.allowance[msg.sender][spender] = amount\n    emit(:Approval, owner: msg.sender, spender: spender, amount: amount)\n    return true\n  }\n  function(:transfer, { to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    require(s.balanceOf[msg.sender] >= amount, \"Insufficient balance\")\n    s.balanceOf[msg.sender] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: msg.sender, to: to, amount: amount)\n    return true\n  }\n  function(:transferFrom, { from: :address, to: :address, amount: :uint256 }, :public, :virtual, returns: :bool) {\n    allowed = s.allowance[from][msg.sender]\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    require(allowed >= amount, \"Insufficient allowance\")\n    s.allowance[from][msg.sender] = allowed - amount\n    s.balanceOf[from] -= amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: from, to: to, amount: amount)\n    return true\n  }\n  function(:_mint, { to: :address, amount: :uint256 }, :internal, :virtual) {\n    s.totalSupply += amount\n    s.balanceOf[to] += amount\n    emit(:Transfer, from: address(0), to: to, amount: amount)\n  }\n  function(:_burn, { from: :address, amount: :uint256 }, :internal, :virtual) {\n    require(s.balanceOf[from] >= amount, \"Insufficient balance\")\n    s.balanceOf[from] -= amount\n    s.totalSupply -= amount\n    emit(:Transfer, from: from, to: address(0), amount: amount)\n  }\n}\n",
        "init_code_hash": "0x144d1d4e6c9ed18cc43b8790876e6b65206e12cc15e20c366d37ce9adb4fddc7"
      },
      {
        "abi": null,
        "name": "ERC721",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:ERC721, abstract: true) {\n  event(:Transfer, { from: :address, to: :address, id: :uint256 })\n  event(:Approval, { owner: :address, spender: :address, id: :uint256 })\n  event(:ApprovalForAll, { owner: :address, operator: :address, approved: :bool })\n  string(:public, :name)\n  string(:public, :symbol)\n  mapping(({ uint256: :address }), :internal, :_ownerOf)\n  mapping(({ address: :uint256 }), :internal, :_balanceOf)\n  mapping(({ uint256: :address }), :public, :getApproved)\n  mapping(({ address: mapping(address: :bool) }), :public, :isApprovedForAll)\n  constructor(name: :string, symbol: :string) {\n    s.name=name\n    s.symbol=symbol\n  }\n  function(:ownerOf, { id: :uint256 }, :public, :view, :virtual, returns: :address) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: owner query for nonexistent token\")\n    return owner\n  }\n  function(:balanceOf, { owner: :address }, :public, :view, :virtual, returns: :uint256) {\n    require(owner != address(0), \"ERC721: balance query for nonexistent owner\")\n    return s._balanceOf[owner]\n  }\n  function(:approve, { spender: :address, id: :uint256 }, :public, :virtual) {\n    owner = ownerOf(id)\n    require(msg.sender == owner || s.isApprovedForAll[owner][msg.sender], \"ERC721: msg.sender not authorized to approve\")\n    s.getApproved[id] = spender\n    emit(:Approval, owner: owner, spender: spender, id: id)\n  }\n  function(:setApprovalForAll, { operator: :address, approved: :bool }, :public, :virtual) {\n    s.isApprovedForAll[msg.sender][operator] = approved\n    emit(:ApprovalForAll, owner: msg.sender, operator: operator, approved: approved)\n  }\n  function(:transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :virtual) {\n    require(from == ownerOf(id), \"ERC721: transfer of token that is not own\")\n    require(to != address(0), \"ERC721: transfer to the zero address\")\n    require(isApprovedOrOwner(spender: msg.sender, id: id), \"ERC721: msg.sender not authorized to call transferFrom\")\n    s._balanceOf[from] -= 1\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: from, to: to, id: id)\n  }\n  function(:isApprovedOrOwner, { spender: :address, id: :uint256 }, :public, :view, :virtual, returns: :bool) {\n    owner = ownerOf(id)\n    spender == owner || s.getApproved[id] == spender || s.isApprovedForAll[owner][spender]\n  }\n  function(:_exists, { id: :uint256 }, :internal, :view, :virtual, returns: :bool) {\n    return s._ownerOf[id] != address(0)\n  }\n  function(:_mint, { to: :address, id: :uint256 }, :internal, :virtual) {\n    require(to != address(0), \"ERC721: mint to the zero address\")\n    require(s._ownerOf[id] == address(0), \"ERC721: token already minted\")\n    s._balanceOf[to] += 1\n    s._ownerOf[id] = to\n    emit(:Transfer, from: address(0), to: to, id: id)\n  }\n  function(:_burn, { id: :uint256 }, :internal, :virtual) {\n    owner = s._ownerOf[id]\n    require(owner != address(0), \"ERC721: burn of nonexistent token\")\n    s._balanceOf[owner] -= 1\n    s._ownerOf[id] = address(0)\n    s.getApproved[id] = address(0)\n    emit(:Transfer, from: owner, to: address(0), id: id)\n  }\n  function(:tokenURI, { id: :uint256 }, :public, :view, :virtual, returns: :string) {\n  }\n}\n",
        "init_code_hash": "0x52770e05109e357389cc257018ff783ca05687bddb28e272e6563459aac16547"
      },
      {
        "abi": null,
        "name": "INFTCollection01",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:INFTCollection01, abstract: true) {\n  function(:owner, :external, :view, returns: :address)\n}\n",
        "init_code_hash": "0xc029d89424bf16cb275e56c1012009aab295f9591b78f23bcce9f172493d46e4"
      },
      {
        "abi": null,
        "name": "Upgradeable",
        "source_code": "pragma(:rubidity, \"1.0.0\")\ncontract(:Upgradeable, abstract: true) {\n  address(:public, :upgradeAdmin)\n  event(:ContractUpgraded, { oldHash: :bytes32, newHash: :bytes32 })\n  event(:UpgradeAdminChanged, { newUpgradeAdmin: :address })\n  constructor(upgradeAdmin: :address) {\n    s.upgradeAdmin=upgradeAdmin\n  }\n  function(:setUpgradeAdmin, { newUpgradeAdmin: :address }, :public) {\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    s.upgradeAdmin=newUpgradeAdmin\n    emit(:UpgradeAdminChanged, newUpgradeAdmin: newUpgradeAdmin)\n  }\n  function(:upgradeAndCall, { newHash: :bytes32, newSource: :string, migrationCalldata: :string }, :public) {\n    upgrade(newHash: newHash, newSource: newSource)\n    (success, data) = address(this).call(migrationCalldata)\n    require(success, \"Migration failed\")\n  }\n  function(:upgrade, { newHash: :bytes32, newSource: :string }, :public) {\n    currentHash = this.currentInitCodeHash\n    require(msg.sender == s.upgradeAdmin, \"NOT_AUTHORIZED\")\n    this.upgradeImplementation(newHash, newSource)\n    emit(:ContractUpgraded, oldHash: currentHash, newHash: newHash)\n  }\n}\n",
        "init_code_hash": "0xb992bd7dc85bdfc189374b20dd41b93b45db44fa0394ac618d04828928f6152b"
      }
    ],
    "pragma_language": "rubidity",
    "pragma_version": "1.0.0",
    "created_at": "2024-05-22T18:45:25.376Z",
    "updated_at": "2024-05-22T18:45:25.376Z"
  }
]